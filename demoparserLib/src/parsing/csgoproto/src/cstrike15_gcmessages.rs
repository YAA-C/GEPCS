// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `cstrike15_gcmessages.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:GameServerPing)
pub struct GameServerPing {
    // message fields
    // @@protoc_insertion_point(field:GameServerPing.gameserver_id)
    pub gameserver_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:GameServerPing.ping)
    pub ping: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:GameServerPing.ip)
    pub ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GameServerPing.port)
    pub port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GameServerPing.instances)
    pub instances: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:GameServerPing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GameServerPing {
    fn default() -> &'a GameServerPing {
        <GameServerPing as ::protobuf::Message>::default_instance()
    }
}

impl GameServerPing {
    pub fn new() -> GameServerPing {
        ::std::default::Default::default()
    }

    // optional uint64 gameserver_id = 1;

    pub fn gameserver_id(&self) -> u64 {
        self.gameserver_id.unwrap_or(0)
    }

    pub fn clear_gameserver_id(&mut self) {
        self.gameserver_id = ::std::option::Option::None;
    }

    pub fn has_gameserver_id(&self) -> bool {
        self.gameserver_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameserver_id(&mut self, v: u64) {
        self.gameserver_id = ::std::option::Option::Some(v);
    }

    // optional int32 ping = 2;

    pub fn ping(&self) -> i32 {
        self.ping.unwrap_or(0)
    }

    pub fn clear_ping(&mut self) {
        self.ping = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        self.ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: i32) {
        self.ping = ::std::option::Option::Some(v);
    }

    // optional uint32 ip = 3;

    pub fn ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }

    // optional uint32 port = 4;

    pub fn port(&self) -> u32 {
        self.port.unwrap_or(0)
    }

    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional uint32 instances = 5;

    pub fn instances(&self) -> u32 {
        self.instances.unwrap_or(0)
    }

    pub fn clear_instances(&mut self) {
        self.instances = ::std::option::Option::None;
    }

    pub fn has_instances(&self) -> bool {
        self.instances.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instances(&mut self, v: u32) {
        self.instances = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gameserver_id",
            |m: &GameServerPing| { &m.gameserver_id },
            |m: &mut GameServerPing| { &mut m.gameserver_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ping",
            |m: &GameServerPing| { &m.ping },
            |m: &mut GameServerPing| { &mut m.ping },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ip",
            |m: &GameServerPing| { &m.ip },
            |m: &mut GameServerPing| { &mut m.ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "port",
            |m: &GameServerPing| { &m.port },
            |m: &mut GameServerPing| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "instances",
            |m: &GameServerPing| { &m.instances },
            |m: &mut GameServerPing| { &mut m.instances },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GameServerPing>(
            "GameServerPing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GameServerPing {
    const NAME: &'static str = "GameServerPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gameserver_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.ping = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.port = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.instances = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gameserver_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.ping {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.ip {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.instances {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.gameserver_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.ping {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.instances {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GameServerPing {
        GameServerPing::new()
    }

    fn clear(&mut self) {
        self.gameserver_id = ::std::option::Option::None;
        self.ping = ::std::option::Option::None;
        self.ip = ::std::option::Option::None;
        self.port = ::std::option::Option::None;
        self.instances = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GameServerPing {
        static instance: GameServerPing = GameServerPing {
            gameserver_id: ::std::option::Option::None,
            ping: ::std::option::Option::None,
            ip: ::std::option::Option::None,
            port: ::std::option::Option::None,
            instances: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GameServerPing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GameServerPing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GameServerPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GameServerPing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:DetailedSearchStatistic)
pub struct DetailedSearchStatistic {
    // message fields
    // @@protoc_insertion_point(field:DetailedSearchStatistic.game_type)
    pub game_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DetailedSearchStatistic.search_time_avg)
    pub search_time_avg: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:DetailedSearchStatistic.players_searching)
    pub players_searching: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:DetailedSearchStatistic.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DetailedSearchStatistic {
    fn default() -> &'a DetailedSearchStatistic {
        <DetailedSearchStatistic as ::protobuf::Message>::default_instance()
    }
}

impl DetailedSearchStatistic {
    pub fn new() -> DetailedSearchStatistic {
        ::std::default::Default::default()
    }

    // optional uint32 game_type = 1;

    pub fn game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional uint32 search_time_avg = 2;

    pub fn search_time_avg(&self) -> u32 {
        self.search_time_avg.unwrap_or(0)
    }

    pub fn clear_search_time_avg(&mut self) {
        self.search_time_avg = ::std::option::Option::None;
    }

    pub fn has_search_time_avg(&self) -> bool {
        self.search_time_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_time_avg(&mut self, v: u32) {
        self.search_time_avg = ::std::option::Option::Some(v);
    }

    // optional uint32 players_searching = 4;

    pub fn players_searching(&self) -> u32 {
        self.players_searching.unwrap_or(0)
    }

    pub fn clear_players_searching(&mut self) {
        self.players_searching = ::std::option::Option::None;
    }

    pub fn has_players_searching(&self) -> bool {
        self.players_searching.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_searching(&mut self, v: u32) {
        self.players_searching = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_type",
            |m: &DetailedSearchStatistic| { &m.game_type },
            |m: &mut DetailedSearchStatistic| { &mut m.game_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "search_time_avg",
            |m: &DetailedSearchStatistic| { &m.search_time_avg },
            |m: &mut DetailedSearchStatistic| { &mut m.search_time_avg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "players_searching",
            |m: &DetailedSearchStatistic| { &m.players_searching },
            |m: &mut DetailedSearchStatistic| { &mut m.players_searching },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DetailedSearchStatistic>(
            "DetailedSearchStatistic",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DetailedSearchStatistic {
    const NAME: &'static str = "DetailedSearchStatistic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.search_time_avg = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.players_searching = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.search_time_avg {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.players_searching {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.game_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.search_time_avg {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.players_searching {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DetailedSearchStatistic {
        DetailedSearchStatistic::new()
    }

    fn clear(&mut self) {
        self.game_type = ::std::option::Option::None;
        self.search_time_avg = ::std::option::Option::None;
        self.players_searching = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DetailedSearchStatistic {
        static instance: DetailedSearchStatistic = DetailedSearchStatistic {
            game_type: ::std::option::Option::None,
            search_time_avg: ::std::option::Option::None,
            players_searching: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DetailedSearchStatistic {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DetailedSearchStatistic").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DetailedSearchStatistic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DetailedSearchStatistic {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TournamentPlayer)
pub struct TournamentPlayer {
    // message fields
    // @@protoc_insertion_point(field:TournamentPlayer.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:TournamentPlayer.player_nick)
    pub player_nick: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentPlayer.player_name)
    pub player_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentPlayer.player_dob)
    pub player_dob: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:TournamentPlayer.player_flag)
    pub player_flag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentPlayer.player_location)
    pub player_location: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentPlayer.player_desc)
    pub player_desc: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:TournamentPlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TournamentPlayer {
    fn default() -> &'a TournamentPlayer {
        <TournamentPlayer as ::protobuf::Message>::default_instance()
    }
}

impl TournamentPlayer {
    pub fn new() -> TournamentPlayer {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional string player_nick = 2;

    pub fn player_nick(&self) -> &str {
        match self.player_nick.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_nick(&mut self) {
        self.player_nick = ::std::option::Option::None;
    }

    pub fn has_player_nick(&self) -> bool {
        self.player_nick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_nick(&mut self, v: ::std::string::String) {
        self.player_nick = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_nick(&mut self) -> &mut ::std::string::String {
        if self.player_nick.is_none() {
            self.player_nick = ::std::option::Option::Some(::std::string::String::new());
        }
        self.player_nick.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_nick(&mut self) -> ::std::string::String {
        self.player_nick.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string player_name = 3;

    pub fn player_name(&self) -> &str {
        match self.player_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_name(&mut self) {
        self.player_name = ::std::option::Option::None;
    }

    pub fn has_player_name(&self) -> bool {
        self.player_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_name(&mut self, v: ::std::string::String) {
        self.player_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
        if self.player_name.is_none() {
            self.player_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.player_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_name(&mut self) -> ::std::string::String {
        self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 player_dob = 4;

    pub fn player_dob(&self) -> u32 {
        self.player_dob.unwrap_or(0)
    }

    pub fn clear_player_dob(&mut self) {
        self.player_dob = ::std::option::Option::None;
    }

    pub fn has_player_dob(&self) -> bool {
        self.player_dob.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_dob(&mut self, v: u32) {
        self.player_dob = ::std::option::Option::Some(v);
    }

    // optional string player_flag = 5;

    pub fn player_flag(&self) -> &str {
        match self.player_flag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_flag(&mut self) {
        self.player_flag = ::std::option::Option::None;
    }

    pub fn has_player_flag(&self) -> bool {
        self.player_flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_flag(&mut self, v: ::std::string::String) {
        self.player_flag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_flag(&mut self) -> &mut ::std::string::String {
        if self.player_flag.is_none() {
            self.player_flag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.player_flag.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_flag(&mut self) -> ::std::string::String {
        self.player_flag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string player_location = 6;

    pub fn player_location(&self) -> &str {
        match self.player_location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_location(&mut self) {
        self.player_location = ::std::option::Option::None;
    }

    pub fn has_player_location(&self) -> bool {
        self.player_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_location(&mut self, v: ::std::string::String) {
        self.player_location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_location(&mut self) -> &mut ::std::string::String {
        if self.player_location.is_none() {
            self.player_location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.player_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_location(&mut self) -> ::std::string::String {
        self.player_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string player_desc = 7;

    pub fn player_desc(&self) -> &str {
        match self.player_desc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_player_desc(&mut self) {
        self.player_desc = ::std::option::Option::None;
    }

    pub fn has_player_desc(&self) -> bool {
        self.player_desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_desc(&mut self, v: ::std::string::String) {
        self.player_desc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_player_desc(&mut self) -> &mut ::std::string::String {
        if self.player_desc.is_none() {
            self.player_desc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.player_desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_player_desc(&mut self) -> ::std::string::String {
        self.player_desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &TournamentPlayer| { &m.account_id },
            |m: &mut TournamentPlayer| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_nick",
            |m: &TournamentPlayer| { &m.player_nick },
            |m: &mut TournamentPlayer| { &mut m.player_nick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_name",
            |m: &TournamentPlayer| { &m.player_name },
            |m: &mut TournamentPlayer| { &mut m.player_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_dob",
            |m: &TournamentPlayer| { &m.player_dob },
            |m: &mut TournamentPlayer| { &mut m.player_dob },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_flag",
            |m: &TournamentPlayer| { &m.player_flag },
            |m: &mut TournamentPlayer| { &mut m.player_flag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_location",
            |m: &TournamentPlayer| { &m.player_location },
            |m: &mut TournamentPlayer| { &mut m.player_location },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_desc",
            |m: &TournamentPlayer| { &m.player_desc },
            |m: &mut TournamentPlayer| { &mut m.player_desc },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TournamentPlayer>(
            "TournamentPlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TournamentPlayer {
    const NAME: &'static str = "TournamentPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.player_nick = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.player_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.player_dob = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.player_flag = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.player_location = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.player_desc = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.player_nick.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.player_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.player_dob {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.player_flag.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.player_location.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.player_desc.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.player_nick.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.player_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.player_dob {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.player_flag.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.player_location.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.player_desc.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TournamentPlayer {
        TournamentPlayer::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.player_nick = ::std::option::Option::None;
        self.player_name = ::std::option::Option::None;
        self.player_dob = ::std::option::Option::None;
        self.player_flag = ::std::option::Option::None;
        self.player_location = ::std::option::Option::None;
        self.player_desc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TournamentPlayer {
        static instance: TournamentPlayer = TournamentPlayer {
            account_id: ::std::option::Option::None,
            player_nick: ::std::option::Option::None,
            player_name: ::std::option::Option::None,
            player_dob: ::std::option::Option::None,
            player_flag: ::std::option::Option::None,
            player_location: ::std::option::Option::None,
            player_desc: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TournamentPlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TournamentPlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TournamentPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentPlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TournamentTeam)
pub struct TournamentTeam {
    // message fields
    // @@protoc_insertion_point(field:TournamentTeam.team_id)
    pub team_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:TournamentTeam.team_tag)
    pub team_tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentTeam.team_flag)
    pub team_flag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentTeam.team_name)
    pub team_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentTeam.players)
    pub players: ::std::vec::Vec<TournamentPlayer>,
    // special fields
    // @@protoc_insertion_point(special_field:TournamentTeam.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TournamentTeam {
    fn default() -> &'a TournamentTeam {
        <TournamentTeam as ::protobuf::Message>::default_instance()
    }
}

impl TournamentTeam {
    pub fn new() -> TournamentTeam {
        ::std::default::Default::default()
    }

    // optional int32 team_id = 1;

    pub fn team_id(&self) -> i32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: i32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional string team_tag = 2;

    pub fn team_tag(&self) -> &str {
        match self.team_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_team_tag(&mut self) {
        self.team_tag = ::std::option::Option::None;
    }

    pub fn has_team_tag(&self) -> bool {
        self.team_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_tag(&mut self, v: ::std::string::String) {
        self.team_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_tag(&mut self) -> &mut ::std::string::String {
        if self.team_tag.is_none() {
            self.team_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.team_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_tag(&mut self) -> ::std::string::String {
        self.team_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string team_flag = 3;

    pub fn team_flag(&self) -> &str {
        match self.team_flag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_team_flag(&mut self) {
        self.team_flag = ::std::option::Option::None;
    }

    pub fn has_team_flag(&self) -> bool {
        self.team_flag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_flag(&mut self, v: ::std::string::String) {
        self.team_flag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_flag(&mut self) -> &mut ::std::string::String {
        if self.team_flag.is_none() {
            self.team_flag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.team_flag.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_flag(&mut self) -> ::std::string::String {
        self.team_flag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string team_name = 4;

    pub fn team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_team_name(&mut self) {
        self.team_name = ::std::option::Option::None;
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id",
            |m: &TournamentTeam| { &m.team_id },
            |m: &mut TournamentTeam| { &mut m.team_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_tag",
            |m: &TournamentTeam| { &m.team_tag },
            |m: &mut TournamentTeam| { &mut m.team_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_flag",
            |m: &TournamentTeam| { &m.team_flag },
            |m: &mut TournamentTeam| { &mut m.team_flag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_name",
            |m: &TournamentTeam| { &m.team_name },
            |m: &mut TournamentTeam| { &mut m.team_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "players",
            |m: &TournamentTeam| { &m.players },
            |m: &mut TournamentTeam| { &mut m.players },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TournamentTeam>(
            "TournamentTeam",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TournamentTeam {
    const NAME: &'static str = "TournamentTeam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.team_tag = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.team_flag = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.team_name = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.team_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.team_flag.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.team_name.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.team_tag.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.team_flag.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.team_name.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.players {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TournamentTeam {
        TournamentTeam::new()
    }

    fn clear(&mut self) {
        self.team_id = ::std::option::Option::None;
        self.team_tag = ::std::option::Option::None;
        self.team_flag = ::std::option::Option::None;
        self.team_name = ::std::option::Option::None;
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TournamentTeam {
        static instance: TournamentTeam = TournamentTeam {
            team_id: ::std::option::Option::None,
            team_tag: ::std::option::Option::None,
            team_flag: ::std::option::Option::None,
            team_name: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TournamentTeam {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TournamentTeam").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TournamentTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentTeam {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TournamentEvent)
pub struct TournamentEvent {
    // message fields
    // @@protoc_insertion_point(field:TournamentEvent.event_id)
    pub event_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:TournamentEvent.event_tag)
    pub event_tag: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentEvent.event_name)
    pub event_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentEvent.event_time_start)
    pub event_time_start: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:TournamentEvent.event_time_end)
    pub event_time_end: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:TournamentEvent.event_public)
    pub event_public: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:TournamentEvent.event_stage_id)
    pub event_stage_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:TournamentEvent.event_stage_name)
    pub event_stage_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:TournamentEvent.active_section_id)
    pub active_section_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:TournamentEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TournamentEvent {
    fn default() -> &'a TournamentEvent {
        <TournamentEvent as ::protobuf::Message>::default_instance()
    }
}

impl TournamentEvent {
    pub fn new() -> TournamentEvent {
        ::std::default::Default::default()
    }

    // optional int32 event_id = 1;

    pub fn event_id(&self) -> i32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: i32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional string event_tag = 2;

    pub fn event_tag(&self) -> &str {
        match self.event_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_tag(&mut self) {
        self.event_tag = ::std::option::Option::None;
    }

    pub fn has_event_tag(&self) -> bool {
        self.event_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_tag(&mut self, v: ::std::string::String) {
        self.event_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_tag(&mut self) -> &mut ::std::string::String {
        if self.event_tag.is_none() {
            self.event_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_tag(&mut self) -> ::std::string::String {
        self.event_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string event_name = 3;

    pub fn event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_name(&mut self) {
        self.event_name = ::std::option::Option::None;
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 event_time_start = 4;

    pub fn event_time_start(&self) -> u32 {
        self.event_time_start.unwrap_or(0)
    }

    pub fn clear_event_time_start(&mut self) {
        self.event_time_start = ::std::option::Option::None;
    }

    pub fn has_event_time_start(&self) -> bool {
        self.event_time_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time_start(&mut self, v: u32) {
        self.event_time_start = ::std::option::Option::Some(v);
    }

    // optional uint32 event_time_end = 5;

    pub fn event_time_end(&self) -> u32 {
        self.event_time_end.unwrap_or(0)
    }

    pub fn clear_event_time_end(&mut self) {
        self.event_time_end = ::std::option::Option::None;
    }

    pub fn has_event_time_end(&self) -> bool {
        self.event_time_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time_end(&mut self, v: u32) {
        self.event_time_end = ::std::option::Option::Some(v);
    }

    // optional int32 event_public = 6;

    pub fn event_public(&self) -> i32 {
        self.event_public.unwrap_or(0)
    }

    pub fn clear_event_public(&mut self) {
        self.event_public = ::std::option::Option::None;
    }

    pub fn has_event_public(&self) -> bool {
        self.event_public.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_public(&mut self, v: i32) {
        self.event_public = ::std::option::Option::Some(v);
    }

    // optional int32 event_stage_id = 7;

    pub fn event_stage_id(&self) -> i32 {
        self.event_stage_id.unwrap_or(0)
    }

    pub fn clear_event_stage_id(&mut self) {
        self.event_stage_id = ::std::option::Option::None;
    }

    pub fn has_event_stage_id(&self) -> bool {
        self.event_stage_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stage_id(&mut self, v: i32) {
        self.event_stage_id = ::std::option::Option::Some(v);
    }

    // optional string event_stage_name = 8;

    pub fn event_stage_name(&self) -> &str {
        match self.event_stage_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_stage_name(&mut self) {
        self.event_stage_name = ::std::option::Option::None;
    }

    pub fn has_event_stage_name(&self) -> bool {
        self.event_stage_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stage_name(&mut self, v: ::std::string::String) {
        self.event_stage_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_stage_name(&mut self) -> &mut ::std::string::String {
        if self.event_stage_name.is_none() {
            self.event_stage_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_stage_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_stage_name(&mut self) -> ::std::string::String {
        self.event_stage_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 active_section_id = 9;

    pub fn active_section_id(&self) -> u32 {
        self.active_section_id.unwrap_or(0)
    }

    pub fn clear_active_section_id(&mut self) {
        self.active_section_id = ::std::option::Option::None;
    }

    pub fn has_active_section_id(&self) -> bool {
        self.active_section_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_section_id(&mut self, v: u32) {
        self.active_section_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &TournamentEvent| { &m.event_id },
            |m: &mut TournamentEvent| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_tag",
            |m: &TournamentEvent| { &m.event_tag },
            |m: &mut TournamentEvent| { &mut m.event_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_name",
            |m: &TournamentEvent| { &m.event_name },
            |m: &mut TournamentEvent| { &mut m.event_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_time_start",
            |m: &TournamentEvent| { &m.event_time_start },
            |m: &mut TournamentEvent| { &mut m.event_time_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_time_end",
            |m: &TournamentEvent| { &m.event_time_end },
            |m: &mut TournamentEvent| { &mut m.event_time_end },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_public",
            |m: &TournamentEvent| { &m.event_public },
            |m: &mut TournamentEvent| { &mut m.event_public },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_stage_id",
            |m: &TournamentEvent| { &m.event_stage_id },
            |m: &mut TournamentEvent| { &mut m.event_stage_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_stage_name",
            |m: &TournamentEvent| { &m.event_stage_name },
            |m: &mut TournamentEvent| { &mut m.event_stage_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_section_id",
            |m: &TournamentEvent| { &m.active_section_id },
            |m: &mut TournamentEvent| { &mut m.active_section_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TournamentEvent>(
            "TournamentEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TournamentEvent {
    const NAME: &'static str = "TournamentEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.event_tag = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.event_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.event_time_start = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.event_time_end = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.event_public = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.event_stage_id = ::std::option::Option::Some(is.read_int32()?);
                },
                66 => {
                    self.event_stage_name = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.active_section_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.event_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.event_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.event_time_start {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.event_time_end {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.event_public {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.event_stage_id {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.event_stage_name.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.active_section_id {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.event_tag.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.event_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.event_time_start {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.event_time_end {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.event_public {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.event_stage_id {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.event_stage_name.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.active_section_id {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TournamentEvent {
        TournamentEvent::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.event_tag = ::std::option::Option::None;
        self.event_name = ::std::option::Option::None;
        self.event_time_start = ::std::option::Option::None;
        self.event_time_end = ::std::option::Option::None;
        self.event_public = ::std::option::Option::None;
        self.event_stage_id = ::std::option::Option::None;
        self.event_stage_name = ::std::option::Option::None;
        self.active_section_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TournamentEvent {
        static instance: TournamentEvent = TournamentEvent {
            event_id: ::std::option::Option::None,
            event_tag: ::std::option::Option::None,
            event_name: ::std::option::Option::None,
            event_time_start: ::std::option::Option::None,
            event_time_end: ::std::option::Option::None,
            event_public: ::std::option::Option::None,
            event_stage_id: ::std::option::Option::None,
            event_stage_name: ::std::option::Option::None,
            active_section_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TournamentEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TournamentEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TournamentEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:GlobalStatistics)
pub struct GlobalStatistics {
    // message fields
    // @@protoc_insertion_point(field:GlobalStatistics.players_online)
    pub players_online: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.servers_online)
    pub servers_online: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.players_searching)
    pub players_searching: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.servers_available)
    pub servers_available: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.ongoing_matches)
    pub ongoing_matches: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.search_time_avg)
    pub search_time_avg: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.search_statistics)
    pub search_statistics: ::std::vec::Vec<DetailedSearchStatistic>,
    // @@protoc_insertion_point(field:GlobalStatistics.main_post_url)
    pub main_post_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:GlobalStatistics.required_appid_version)
    pub required_appid_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.pricesheet_version)
    pub pricesheet_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.twitch_streams_version)
    pub twitch_streams_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.active_tournament_eventid)
    pub active_tournament_eventid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GlobalStatistics.active_survey_id)
    pub active_survey_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:GlobalStatistics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GlobalStatistics {
    fn default() -> &'a GlobalStatistics {
        <GlobalStatistics as ::protobuf::Message>::default_instance()
    }
}

impl GlobalStatistics {
    pub fn new() -> GlobalStatistics {
        ::std::default::Default::default()
    }

    // optional uint32 players_online = 1;

    pub fn players_online(&self) -> u32 {
        self.players_online.unwrap_or(0)
    }

    pub fn clear_players_online(&mut self) {
        self.players_online = ::std::option::Option::None;
    }

    pub fn has_players_online(&self) -> bool {
        self.players_online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_online(&mut self, v: u32) {
        self.players_online = ::std::option::Option::Some(v);
    }

    // optional uint32 servers_online = 2;

    pub fn servers_online(&self) -> u32 {
        self.servers_online.unwrap_or(0)
    }

    pub fn clear_servers_online(&mut self) {
        self.servers_online = ::std::option::Option::None;
    }

    pub fn has_servers_online(&self) -> bool {
        self.servers_online.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servers_online(&mut self, v: u32) {
        self.servers_online = ::std::option::Option::Some(v);
    }

    // optional uint32 players_searching = 3;

    pub fn players_searching(&self) -> u32 {
        self.players_searching.unwrap_or(0)
    }

    pub fn clear_players_searching(&mut self) {
        self.players_searching = ::std::option::Option::None;
    }

    pub fn has_players_searching(&self) -> bool {
        self.players_searching.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_searching(&mut self, v: u32) {
        self.players_searching = ::std::option::Option::Some(v);
    }

    // optional uint32 servers_available = 4;

    pub fn servers_available(&self) -> u32 {
        self.servers_available.unwrap_or(0)
    }

    pub fn clear_servers_available(&mut self) {
        self.servers_available = ::std::option::Option::None;
    }

    pub fn has_servers_available(&self) -> bool {
        self.servers_available.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servers_available(&mut self, v: u32) {
        self.servers_available = ::std::option::Option::Some(v);
    }

    // optional uint32 ongoing_matches = 5;

    pub fn ongoing_matches(&self) -> u32 {
        self.ongoing_matches.unwrap_or(0)
    }

    pub fn clear_ongoing_matches(&mut self) {
        self.ongoing_matches = ::std::option::Option::None;
    }

    pub fn has_ongoing_matches(&self) -> bool {
        self.ongoing_matches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ongoing_matches(&mut self, v: u32) {
        self.ongoing_matches = ::std::option::Option::Some(v);
    }

    // optional uint32 search_time_avg = 6;

    pub fn search_time_avg(&self) -> u32 {
        self.search_time_avg.unwrap_or(0)
    }

    pub fn clear_search_time_avg(&mut self) {
        self.search_time_avg = ::std::option::Option::None;
    }

    pub fn has_search_time_avg(&self) -> bool {
        self.search_time_avg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_time_avg(&mut self, v: u32) {
        self.search_time_avg = ::std::option::Option::Some(v);
    }

    // optional string main_post_url = 8;

    pub fn main_post_url(&self) -> &str {
        match self.main_post_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_main_post_url(&mut self) {
        self.main_post_url = ::std::option::Option::None;
    }

    pub fn has_main_post_url(&self) -> bool {
        self.main_post_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_main_post_url(&mut self, v: ::std::string::String) {
        self.main_post_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_post_url(&mut self) -> &mut ::std::string::String {
        if self.main_post_url.is_none() {
            self.main_post_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.main_post_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_main_post_url(&mut self) -> ::std::string::String {
        self.main_post_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 required_appid_version = 9;

    pub fn required_appid_version(&self) -> u32 {
        self.required_appid_version.unwrap_or(0)
    }

    pub fn clear_required_appid_version(&mut self) {
        self.required_appid_version = ::std::option::Option::None;
    }

    pub fn has_required_appid_version(&self) -> bool {
        self.required_appid_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_appid_version(&mut self, v: u32) {
        self.required_appid_version = ::std::option::Option::Some(v);
    }

    // optional uint32 pricesheet_version = 10;

    pub fn pricesheet_version(&self) -> u32 {
        self.pricesheet_version.unwrap_or(0)
    }

    pub fn clear_pricesheet_version(&mut self) {
        self.pricesheet_version = ::std::option::Option::None;
    }

    pub fn has_pricesheet_version(&self) -> bool {
        self.pricesheet_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pricesheet_version(&mut self, v: u32) {
        self.pricesheet_version = ::std::option::Option::Some(v);
    }

    // optional uint32 twitch_streams_version = 11;

    pub fn twitch_streams_version(&self) -> u32 {
        self.twitch_streams_version.unwrap_or(0)
    }

    pub fn clear_twitch_streams_version(&mut self) {
        self.twitch_streams_version = ::std::option::Option::None;
    }

    pub fn has_twitch_streams_version(&self) -> bool {
        self.twitch_streams_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_twitch_streams_version(&mut self, v: u32) {
        self.twitch_streams_version = ::std::option::Option::Some(v);
    }

    // optional uint32 active_tournament_eventid = 12;

    pub fn active_tournament_eventid(&self) -> u32 {
        self.active_tournament_eventid.unwrap_or(0)
    }

    pub fn clear_active_tournament_eventid(&mut self) {
        self.active_tournament_eventid = ::std::option::Option::None;
    }

    pub fn has_active_tournament_eventid(&self) -> bool {
        self.active_tournament_eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_tournament_eventid(&mut self, v: u32) {
        self.active_tournament_eventid = ::std::option::Option::Some(v);
    }

    // optional uint32 active_survey_id = 13;

    pub fn active_survey_id(&self) -> u32 {
        self.active_survey_id.unwrap_or(0)
    }

    pub fn clear_active_survey_id(&mut self) {
        self.active_survey_id = ::std::option::Option::None;
    }

    pub fn has_active_survey_id(&self) -> bool {
        self.active_survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_survey_id(&mut self, v: u32) {
        self.active_survey_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "players_online",
            |m: &GlobalStatistics| { &m.players_online },
            |m: &mut GlobalStatistics| { &mut m.players_online },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "servers_online",
            |m: &GlobalStatistics| { &m.servers_online },
            |m: &mut GlobalStatistics| { &mut m.servers_online },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "players_searching",
            |m: &GlobalStatistics| { &m.players_searching },
            |m: &mut GlobalStatistics| { &mut m.players_searching },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "servers_available",
            |m: &GlobalStatistics| { &m.servers_available },
            |m: &mut GlobalStatistics| { &mut m.servers_available },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ongoing_matches",
            |m: &GlobalStatistics| { &m.ongoing_matches },
            |m: &mut GlobalStatistics| { &mut m.ongoing_matches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "search_time_avg",
            |m: &GlobalStatistics| { &m.search_time_avg },
            |m: &mut GlobalStatistics| { &mut m.search_time_avg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "search_statistics",
            |m: &GlobalStatistics| { &m.search_statistics },
            |m: &mut GlobalStatistics| { &mut m.search_statistics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "main_post_url",
            |m: &GlobalStatistics| { &m.main_post_url },
            |m: &mut GlobalStatistics| { &mut m.main_post_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "required_appid_version",
            |m: &GlobalStatistics| { &m.required_appid_version },
            |m: &mut GlobalStatistics| { &mut m.required_appid_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pricesheet_version",
            |m: &GlobalStatistics| { &m.pricesheet_version },
            |m: &mut GlobalStatistics| { &mut m.pricesheet_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "twitch_streams_version",
            |m: &GlobalStatistics| { &m.twitch_streams_version },
            |m: &mut GlobalStatistics| { &mut m.twitch_streams_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_tournament_eventid",
            |m: &GlobalStatistics| { &m.active_tournament_eventid },
            |m: &mut GlobalStatistics| { &mut m.active_tournament_eventid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "active_survey_id",
            |m: &GlobalStatistics| { &m.active_survey_id },
            |m: &mut GlobalStatistics| { &mut m.active_survey_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GlobalStatistics>(
            "GlobalStatistics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GlobalStatistics {
    const NAME: &'static str = "GlobalStatistics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.players_online = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.servers_online = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.players_searching = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.servers_available = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.ongoing_matches = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.search_time_avg = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.search_statistics.push(is.read_message()?);
                },
                66 => {
                    self.main_post_url = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.required_appid_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.pricesheet_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.twitch_streams_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.active_tournament_eventid = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.active_survey_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.players_online {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.servers_online {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.players_searching {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.servers_available {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.ongoing_matches {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.search_time_avg {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        for value in &self.search_statistics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.main_post_url.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.required_appid_version {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.pricesheet_version {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.twitch_streams_version {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.active_tournament_eventid {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.active_survey_id {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.players_online {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.servers_online {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.players_searching {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.servers_available {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.ongoing_matches {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.search_time_avg {
            os.write_uint32(6, v)?;
        }
        for v in &self.search_statistics {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.main_post_url.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.required_appid_version {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.pricesheet_version {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.twitch_streams_version {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.active_tournament_eventid {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.active_survey_id {
            os.write_uint32(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GlobalStatistics {
        GlobalStatistics::new()
    }

    fn clear(&mut self) {
        self.players_online = ::std::option::Option::None;
        self.servers_online = ::std::option::Option::None;
        self.players_searching = ::std::option::Option::None;
        self.servers_available = ::std::option::Option::None;
        self.ongoing_matches = ::std::option::Option::None;
        self.search_time_avg = ::std::option::Option::None;
        self.search_statistics.clear();
        self.main_post_url = ::std::option::Option::None;
        self.required_appid_version = ::std::option::Option::None;
        self.pricesheet_version = ::std::option::Option::None;
        self.twitch_streams_version = ::std::option::Option::None;
        self.active_tournament_eventid = ::std::option::Option::None;
        self.active_survey_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GlobalStatistics {
        static instance: GlobalStatistics = GlobalStatistics {
            players_online: ::std::option::Option::None,
            servers_online: ::std::option::Option::None,
            players_searching: ::std::option::Option::None,
            servers_available: ::std::option::Option::None,
            ongoing_matches: ::std::option::Option::None,
            search_time_avg: ::std::option::Option::None,
            search_statistics: ::std::vec::Vec::new(),
            main_post_url: ::std::option::Option::None,
            required_appid_version: ::std::option::Option::None,
            pricesheet_version: ::std::option::Option::None,
            twitch_streams_version: ::std::option::Option::None,
            active_tournament_eventid: ::std::option::Option::None,
            active_survey_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GlobalStatistics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GlobalStatistics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GlobalStatistics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalStatistics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OperationalStatisticDescription)
pub struct OperationalStatisticDescription {
    // message fields
    // @@protoc_insertion_point(field:OperationalStatisticDescription.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:OperationalStatisticDescription.idkey)
    pub idkey: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:OperationalStatisticDescription.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OperationalStatisticDescription {
    fn default() -> &'a OperationalStatisticDescription {
        <OperationalStatisticDescription as ::protobuf::Message>::default_instance()
    }
}

impl OperationalStatisticDescription {
    pub fn new() -> OperationalStatisticDescription {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 idkey = 2;

    pub fn idkey(&self) -> u32 {
        self.idkey.unwrap_or(0)
    }

    pub fn clear_idkey(&mut self) {
        self.idkey = ::std::option::Option::None;
    }

    pub fn has_idkey(&self) -> bool {
        self.idkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idkey(&mut self, v: u32) {
        self.idkey = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &OperationalStatisticDescription| { &m.name },
            |m: &mut OperationalStatisticDescription| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "idkey",
            |m: &OperationalStatisticDescription| { &m.idkey },
            |m: &mut OperationalStatisticDescription| { &mut m.idkey },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OperationalStatisticDescription>(
            "OperationalStatisticDescription",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OperationalStatisticDescription {
    const NAME: &'static str = "OperationalStatisticDescription";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.idkey = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.idkey {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.idkey {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OperationalStatisticDescription {
        OperationalStatisticDescription::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.idkey = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OperationalStatisticDescription {
        static instance: OperationalStatisticDescription = OperationalStatisticDescription {
            name: ::std::option::Option::None,
            idkey: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OperationalStatisticDescription {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OperationalStatisticDescription").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OperationalStatisticDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationalStatisticDescription {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OperationalStatisticElement)
pub struct OperationalStatisticElement {
    // message fields
    // @@protoc_insertion_point(field:OperationalStatisticElement.idkey)
    pub idkey: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:OperationalStatisticElement.values)
    pub values: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:OperationalStatisticElement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OperationalStatisticElement {
    fn default() -> &'a OperationalStatisticElement {
        <OperationalStatisticElement as ::protobuf::Message>::default_instance()
    }
}

impl OperationalStatisticElement {
    pub fn new() -> OperationalStatisticElement {
        ::std::default::Default::default()
    }

    // optional uint32 idkey = 1;

    pub fn idkey(&self) -> u32 {
        self.idkey.unwrap_or(0)
    }

    pub fn clear_idkey(&mut self) {
        self.idkey = ::std::option::Option::None;
    }

    pub fn has_idkey(&self) -> bool {
        self.idkey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idkey(&mut self, v: u32) {
        self.idkey = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "idkey",
            |m: &OperationalStatisticElement| { &m.idkey },
            |m: &mut OperationalStatisticElement| { &mut m.idkey },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &OperationalStatisticElement| { &m.values },
            |m: &mut OperationalStatisticElement| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OperationalStatisticElement>(
            "OperationalStatisticElement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OperationalStatisticElement {
    const NAME: &'static str = "OperationalStatisticElement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.idkey = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.values)?;
                },
                16 => {
                    self.values.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.idkey {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.values {
            my_size += ::protobuf::rt::int32_size(2, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.idkey {
            os.write_uint32(1, v)?;
        }
        for v in &self.values {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OperationalStatisticElement {
        OperationalStatisticElement::new()
    }

    fn clear(&mut self) {
        self.idkey = ::std::option::Option::None;
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OperationalStatisticElement {
        static instance: OperationalStatisticElement = OperationalStatisticElement {
            idkey: ::std::option::Option::None,
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OperationalStatisticElement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OperationalStatisticElement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OperationalStatisticElement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationalStatisticElement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:OperationalStatisticsPacket)
pub struct OperationalStatisticsPacket {
    // message fields
    // @@protoc_insertion_point(field:OperationalStatisticsPacket.packetid)
    pub packetid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:OperationalStatisticsPacket.mstimestamp)
    pub mstimestamp: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:OperationalStatisticsPacket.values)
    pub values: ::std::vec::Vec<OperationalStatisticElement>,
    // special fields
    // @@protoc_insertion_point(special_field:OperationalStatisticsPacket.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OperationalStatisticsPacket {
    fn default() -> &'a OperationalStatisticsPacket {
        <OperationalStatisticsPacket as ::protobuf::Message>::default_instance()
    }
}

impl OperationalStatisticsPacket {
    pub fn new() -> OperationalStatisticsPacket {
        ::std::default::Default::default()
    }

    // optional int32 packetid = 1;

    pub fn packetid(&self) -> i32 {
        self.packetid.unwrap_or(0)
    }

    pub fn clear_packetid(&mut self) {
        self.packetid = ::std::option::Option::None;
    }

    pub fn has_packetid(&self) -> bool {
        self.packetid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packetid(&mut self, v: i32) {
        self.packetid = ::std::option::Option::Some(v);
    }

    // optional int32 mstimestamp = 2;

    pub fn mstimestamp(&self) -> i32 {
        self.mstimestamp.unwrap_or(0)
    }

    pub fn clear_mstimestamp(&mut self) {
        self.mstimestamp = ::std::option::Option::None;
    }

    pub fn has_mstimestamp(&self) -> bool {
        self.mstimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mstimestamp(&mut self, v: i32) {
        self.mstimestamp = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packetid",
            |m: &OperationalStatisticsPacket| { &m.packetid },
            |m: &mut OperationalStatisticsPacket| { &mut m.packetid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mstimestamp",
            |m: &OperationalStatisticsPacket| { &m.mstimestamp },
            |m: &mut OperationalStatisticsPacket| { &mut m.mstimestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "values",
            |m: &OperationalStatisticsPacket| { &m.values },
            |m: &mut OperationalStatisticsPacket| { &mut m.values },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<OperationalStatisticsPacket>(
            "OperationalStatisticsPacket",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for OperationalStatisticsPacket {
    const NAME: &'static str = "OperationalStatisticsPacket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.packetid = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.mstimestamp = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.values.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.packetid {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.mstimestamp {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        for value in &self.values {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.packetid {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.mstimestamp {
            os.write_int32(2, v)?;
        }
        for v in &self.values {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OperationalStatisticsPacket {
        OperationalStatisticsPacket::new()
    }

    fn clear(&mut self) {
        self.packetid = ::std::option::Option::None;
        self.mstimestamp = ::std::option::Option::None;
        self.values.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OperationalStatisticsPacket {
        static instance: OperationalStatisticsPacket = OperationalStatisticsPacket {
            packetid: ::std::option::Option::None,
            mstimestamp: ::std::option::Option::None,
            values: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for OperationalStatisticsPacket {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OperationalStatisticsPacket").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OperationalStatisticsPacket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OperationalStatisticsPacket {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:PlayerRankingInfo)
pub struct PlayerRankingInfo {
    // message fields
    // @@protoc_insertion_point(field:PlayerRankingInfo.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerRankingInfo.rank_id)
    pub rank_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerRankingInfo.wins)
    pub wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerRankingInfo.rank_change)
    pub rank_change: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:PlayerRankingInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlayerRankingInfo {
    fn default() -> &'a PlayerRankingInfo {
        <PlayerRankingInfo as ::protobuf::Message>::default_instance()
    }
}

impl PlayerRankingInfo {
    pub fn new() -> PlayerRankingInfo {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rank_id = 2;

    pub fn rank_id(&self) -> u32 {
        self.rank_id.unwrap_or(0)
    }

    pub fn clear_rank_id(&mut self) {
        self.rank_id = ::std::option::Option::None;
    }

    pub fn has_rank_id(&self) -> bool {
        self.rank_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_id(&mut self, v: u32) {
        self.rank_id = ::std::option::Option::Some(v);
    }

    // optional uint32 wins = 3;

    pub fn wins(&self) -> u32 {
        self.wins.unwrap_or(0)
    }

    pub fn clear_wins(&mut self) {
        self.wins = ::std::option::Option::None;
    }

    pub fn has_wins(&self) -> bool {
        self.wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wins(&mut self, v: u32) {
        self.wins = ::std::option::Option::Some(v);
    }

    // optional float rank_change = 4;

    pub fn rank_change(&self) -> f32 {
        self.rank_change.unwrap_or(0.)
    }

    pub fn clear_rank_change(&mut self) {
        self.rank_change = ::std::option::Option::None;
    }

    pub fn has_rank_change(&self) -> bool {
        self.rank_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_change(&mut self, v: f32) {
        self.rank_change = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &PlayerRankingInfo| { &m.account_id },
            |m: &mut PlayerRankingInfo| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank_id",
            |m: &PlayerRankingInfo| { &m.rank_id },
            |m: &mut PlayerRankingInfo| { &mut m.rank_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "wins",
            |m: &PlayerRankingInfo| { &m.wins },
            |m: &mut PlayerRankingInfo| { &mut m.wins },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rank_change",
            |m: &PlayerRankingInfo| { &m.rank_change },
            |m: &mut PlayerRankingInfo| { &mut m.rank_change },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerRankingInfo>(
            "PlayerRankingInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlayerRankingInfo {
    const NAME: &'static str = "PlayerRankingInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rank_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.rank_change = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rank_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.wins {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.rank_change {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rank_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.wins {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rank_change {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlayerRankingInfo {
        PlayerRankingInfo::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.rank_id = ::std::option::Option::None;
        self.wins = ::std::option::Option::None;
        self.rank_change = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlayerRankingInfo {
        static instance: PlayerRankingInfo = PlayerRankingInfo {
            account_id: ::std::option::Option::None,
            rank_id: ::std::option::Option::None,
            wins: ::std::option::Option::None,
            rank_change: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlayerRankingInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlayerRankingInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlayerRankingInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerRankingInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:PlayerCommendationInfo)
pub struct PlayerCommendationInfo {
    // message fields
    // @@protoc_insertion_point(field:PlayerCommendationInfo.cmd_friendly)
    pub cmd_friendly: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerCommendationInfo.cmd_teaching)
    pub cmd_teaching: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerCommendationInfo.cmd_leader)
    pub cmd_leader: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:PlayerCommendationInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlayerCommendationInfo {
    fn default() -> &'a PlayerCommendationInfo {
        <PlayerCommendationInfo as ::protobuf::Message>::default_instance()
    }
}

impl PlayerCommendationInfo {
    pub fn new() -> PlayerCommendationInfo {
        ::std::default::Default::default()
    }

    // optional uint32 cmd_friendly = 1;

    pub fn cmd_friendly(&self) -> u32 {
        self.cmd_friendly.unwrap_or(0)
    }

    pub fn clear_cmd_friendly(&mut self) {
        self.cmd_friendly = ::std::option::Option::None;
    }

    pub fn has_cmd_friendly(&self) -> bool {
        self.cmd_friendly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd_friendly(&mut self, v: u32) {
        self.cmd_friendly = ::std::option::Option::Some(v);
    }

    // optional uint32 cmd_teaching = 2;

    pub fn cmd_teaching(&self) -> u32 {
        self.cmd_teaching.unwrap_or(0)
    }

    pub fn clear_cmd_teaching(&mut self) {
        self.cmd_teaching = ::std::option::Option::None;
    }

    pub fn has_cmd_teaching(&self) -> bool {
        self.cmd_teaching.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd_teaching(&mut self, v: u32) {
        self.cmd_teaching = ::std::option::Option::Some(v);
    }

    // optional uint32 cmd_leader = 4;

    pub fn cmd_leader(&self) -> u32 {
        self.cmd_leader.unwrap_or(0)
    }

    pub fn clear_cmd_leader(&mut self) {
        self.cmd_leader = ::std::option::Option::None;
    }

    pub fn has_cmd_leader(&self) -> bool {
        self.cmd_leader.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cmd_leader(&mut self, v: u32) {
        self.cmd_leader = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cmd_friendly",
            |m: &PlayerCommendationInfo| { &m.cmd_friendly },
            |m: &mut PlayerCommendationInfo| { &mut m.cmd_friendly },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cmd_teaching",
            |m: &PlayerCommendationInfo| { &m.cmd_teaching },
            |m: &mut PlayerCommendationInfo| { &mut m.cmd_teaching },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cmd_leader",
            |m: &PlayerCommendationInfo| { &m.cmd_leader },
            |m: &mut PlayerCommendationInfo| { &mut m.cmd_leader },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerCommendationInfo>(
            "PlayerCommendationInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlayerCommendationInfo {
    const NAME: &'static str = "PlayerCommendationInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cmd_friendly = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.cmd_teaching = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.cmd_leader = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cmd_friendly {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.cmd_teaching {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cmd_leader {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.cmd_friendly {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cmd_teaching {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cmd_leader {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlayerCommendationInfo {
        PlayerCommendationInfo::new()
    }

    fn clear(&mut self) {
        self.cmd_friendly = ::std::option::Option::None;
        self.cmd_teaching = ::std::option::Option::None;
        self.cmd_leader = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlayerCommendationInfo {
        static instance: PlayerCommendationInfo = PlayerCommendationInfo {
            cmd_friendly: ::std::option::Option::None,
            cmd_teaching: ::std::option::Option::None,
            cmd_leader: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlayerCommendationInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlayerCommendationInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlayerCommendationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerCommendationInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:PlayerMedalsInfo)
pub struct PlayerMedalsInfo {
    // message fields
    // @@protoc_insertion_point(field:PlayerMedalsInfo.medal_team)
    pub medal_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerMedalsInfo.medal_combat)
    pub medal_combat: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerMedalsInfo.medal_weapon)
    pub medal_weapon: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerMedalsInfo.medal_global)
    pub medal_global: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerMedalsInfo.medal_arms)
    pub medal_arms: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerMedalsInfo.display_items_defidx)
    pub display_items_defidx: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:PlayerMedalsInfo.featured_display_item_defidx)
    pub featured_display_item_defidx: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:PlayerMedalsInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlayerMedalsInfo {
    fn default() -> &'a PlayerMedalsInfo {
        <PlayerMedalsInfo as ::protobuf::Message>::default_instance()
    }
}

impl PlayerMedalsInfo {
    pub fn new() -> PlayerMedalsInfo {
        ::std::default::Default::default()
    }

    // optional uint32 medal_team = 1;

    pub fn medal_team(&self) -> u32 {
        self.medal_team.unwrap_or(0)
    }

    pub fn clear_medal_team(&mut self) {
        self.medal_team = ::std::option::Option::None;
    }

    pub fn has_medal_team(&self) -> bool {
        self.medal_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medal_team(&mut self, v: u32) {
        self.medal_team = ::std::option::Option::Some(v);
    }

    // optional uint32 medal_combat = 2;

    pub fn medal_combat(&self) -> u32 {
        self.medal_combat.unwrap_or(0)
    }

    pub fn clear_medal_combat(&mut self) {
        self.medal_combat = ::std::option::Option::None;
    }

    pub fn has_medal_combat(&self) -> bool {
        self.medal_combat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medal_combat(&mut self, v: u32) {
        self.medal_combat = ::std::option::Option::Some(v);
    }

    // optional uint32 medal_weapon = 3;

    pub fn medal_weapon(&self) -> u32 {
        self.medal_weapon.unwrap_or(0)
    }

    pub fn clear_medal_weapon(&mut self) {
        self.medal_weapon = ::std::option::Option::None;
    }

    pub fn has_medal_weapon(&self) -> bool {
        self.medal_weapon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medal_weapon(&mut self, v: u32) {
        self.medal_weapon = ::std::option::Option::Some(v);
    }

    // optional uint32 medal_global = 4;

    pub fn medal_global(&self) -> u32 {
        self.medal_global.unwrap_or(0)
    }

    pub fn clear_medal_global(&mut self) {
        self.medal_global = ::std::option::Option::None;
    }

    pub fn has_medal_global(&self) -> bool {
        self.medal_global.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medal_global(&mut self, v: u32) {
        self.medal_global = ::std::option::Option::Some(v);
    }

    // optional uint32 medal_arms = 5;

    pub fn medal_arms(&self) -> u32 {
        self.medal_arms.unwrap_or(0)
    }

    pub fn clear_medal_arms(&mut self) {
        self.medal_arms = ::std::option::Option::None;
    }

    pub fn has_medal_arms(&self) -> bool {
        self.medal_arms.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medal_arms(&mut self, v: u32) {
        self.medal_arms = ::std::option::Option::Some(v);
    }

    // optional uint32 featured_display_item_defidx = 8;

    pub fn featured_display_item_defidx(&self) -> u32 {
        self.featured_display_item_defidx.unwrap_or(0)
    }

    pub fn clear_featured_display_item_defidx(&mut self) {
        self.featured_display_item_defidx = ::std::option::Option::None;
    }

    pub fn has_featured_display_item_defidx(&self) -> bool {
        self.featured_display_item_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featured_display_item_defidx(&mut self, v: u32) {
        self.featured_display_item_defidx = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "medal_team",
            |m: &PlayerMedalsInfo| { &m.medal_team },
            |m: &mut PlayerMedalsInfo| { &mut m.medal_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "medal_combat",
            |m: &PlayerMedalsInfo| { &m.medal_combat },
            |m: &mut PlayerMedalsInfo| { &mut m.medal_combat },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "medal_weapon",
            |m: &PlayerMedalsInfo| { &m.medal_weapon },
            |m: &mut PlayerMedalsInfo| { &mut m.medal_weapon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "medal_global",
            |m: &PlayerMedalsInfo| { &m.medal_global },
            |m: &mut PlayerMedalsInfo| { &mut m.medal_global },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "medal_arms",
            |m: &PlayerMedalsInfo| { &m.medal_arms },
            |m: &mut PlayerMedalsInfo| { &mut m.medal_arms },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "display_items_defidx",
            |m: &PlayerMedalsInfo| { &m.display_items_defidx },
            |m: &mut PlayerMedalsInfo| { &mut m.display_items_defidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "featured_display_item_defidx",
            |m: &PlayerMedalsInfo| { &m.featured_display_item_defidx },
            |m: &mut PlayerMedalsInfo| { &mut m.featured_display_item_defidx },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerMedalsInfo>(
            "PlayerMedalsInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlayerMedalsInfo {
    const NAME: &'static str = "PlayerMedalsInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.medal_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.medal_combat = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.medal_weapon = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.medal_global = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.medal_arms = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.display_items_defidx)?;
                },
                56 => {
                    self.display_items_defidx.push(is.read_uint32()?);
                },
                64 => {
                    self.featured_display_item_defidx = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.medal_team {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.medal_combat {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.medal_weapon {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.medal_global {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.medal_arms {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        for value in &self.display_items_defidx {
            my_size += ::protobuf::rt::uint32_size(7, *value);
        };
        if let Some(v) = self.featured_display_item_defidx {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.medal_team {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.medal_combat {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.medal_weapon {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.medal_global {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.medal_arms {
            os.write_uint32(5, v)?;
        }
        for v in &self.display_items_defidx {
            os.write_uint32(7, *v)?;
        };
        if let Some(v) = self.featured_display_item_defidx {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlayerMedalsInfo {
        PlayerMedalsInfo::new()
    }

    fn clear(&mut self) {
        self.medal_team = ::std::option::Option::None;
        self.medal_combat = ::std::option::Option::None;
        self.medal_weapon = ::std::option::Option::None;
        self.medal_global = ::std::option::Option::None;
        self.medal_arms = ::std::option::Option::None;
        self.display_items_defidx.clear();
        self.featured_display_item_defidx = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlayerMedalsInfo {
        static instance: PlayerMedalsInfo = PlayerMedalsInfo {
            medal_team: ::std::option::Option::None,
            medal_combat: ::std::option::Option::None,
            medal_weapon: ::std::option::Option::None,
            medal_global: ::std::option::Option::None,
            medal_arms: ::std::option::Option::None,
            display_items_defidx: ::std::vec::Vec::new(),
            featured_display_item_defidx: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlayerMedalsInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlayerMedalsInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlayerMedalsInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerMedalsInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:AccountActivity)
pub struct AccountActivity {
    // message fields
    // @@protoc_insertion_point(field:AccountActivity.activity)
    pub activity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:AccountActivity.mode)
    pub mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:AccountActivity.map)
    pub map: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:AccountActivity.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AccountActivity {
    fn default() -> &'a AccountActivity {
        <AccountActivity as ::protobuf::Message>::default_instance()
    }
}

impl AccountActivity {
    pub fn new() -> AccountActivity {
        ::std::default::Default::default()
    }

    // optional uint32 activity = 1;

    pub fn activity(&self) -> u32 {
        self.activity.unwrap_or(0)
    }

    pub fn clear_activity(&mut self) {
        self.activity = ::std::option::Option::None;
    }

    pub fn has_activity(&self) -> bool {
        self.activity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activity(&mut self, v: u32) {
        self.activity = ::std::option::Option::Some(v);
    }

    // optional uint32 mode = 2;

    pub fn mode(&self) -> u32 {
        self.mode.unwrap_or(0)
    }

    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: u32) {
        self.mode = ::std::option::Option::Some(v);
    }

    // optional uint32 map = 3;

    pub fn map(&self) -> u32 {
        self.map.unwrap_or(0)
    }

    pub fn clear_map(&mut self) {
        self.map = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: u32) {
        self.map = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "activity",
            |m: &AccountActivity| { &m.activity },
            |m: &mut AccountActivity| { &mut m.activity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mode",
            |m: &AccountActivity| { &m.mode },
            |m: &mut AccountActivity| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map",
            |m: &AccountActivity| { &m.map },
            |m: &mut AccountActivity| { &mut m.map },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountActivity>(
            "AccountActivity",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AccountActivity {
    const NAME: &'static str = "AccountActivity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.activity = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.map = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.activity {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.map {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.activity {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.mode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.map {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AccountActivity {
        AccountActivity::new()
    }

    fn clear(&mut self) {
        self.activity = ::std::option::Option::None;
        self.mode = ::std::option::Option::None;
        self.map = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AccountActivity {
        static instance: AccountActivity = AccountActivity {
            activity: ::std::option::Option::None,
            mode: ::std::option::Option::None,
            map: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AccountActivity {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AccountActivity").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AccountActivity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountActivity {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:TournamentMatchSetup)
pub struct TournamentMatchSetup {
    // message fields
    // @@protoc_insertion_point(field:TournamentMatchSetup.event_id)
    pub event_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:TournamentMatchSetup.team_id_ct)
    pub team_id_ct: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:TournamentMatchSetup.team_id_t)
    pub team_id_t: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:TournamentMatchSetup.event_stage_id)
    pub event_stage_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:TournamentMatchSetup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TournamentMatchSetup {
    fn default() -> &'a TournamentMatchSetup {
        <TournamentMatchSetup as ::protobuf::Message>::default_instance()
    }
}

impl TournamentMatchSetup {
    pub fn new() -> TournamentMatchSetup {
        ::std::default::Default::default()
    }

    // optional int32 event_id = 1;

    pub fn event_id(&self) -> i32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: i32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_ct = 2;

    pub fn team_id_ct(&self) -> i32 {
        self.team_id_ct.unwrap_or(0)
    }

    pub fn clear_team_id_ct(&mut self) {
        self.team_id_ct = ::std::option::Option::None;
    }

    pub fn has_team_id_ct(&self) -> bool {
        self.team_id_ct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_ct(&mut self, v: i32) {
        self.team_id_ct = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_t = 3;

    pub fn team_id_t(&self) -> i32 {
        self.team_id_t.unwrap_or(0)
    }

    pub fn clear_team_id_t(&mut self) {
        self.team_id_t = ::std::option::Option::None;
    }

    pub fn has_team_id_t(&self) -> bool {
        self.team_id_t.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_t(&mut self, v: i32) {
        self.team_id_t = ::std::option::Option::Some(v);
    }

    // optional int32 event_stage_id = 4;

    pub fn event_stage_id(&self) -> i32 {
        self.event_stage_id.unwrap_or(0)
    }

    pub fn clear_event_stage_id(&mut self) {
        self.event_stage_id = ::std::option::Option::None;
    }

    pub fn has_event_stage_id(&self) -> bool {
        self.event_stage_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stage_id(&mut self, v: i32) {
        self.event_stage_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &TournamentMatchSetup| { &m.event_id },
            |m: &mut TournamentMatchSetup| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id_ct",
            |m: &TournamentMatchSetup| { &m.team_id_ct },
            |m: &mut TournamentMatchSetup| { &mut m.team_id_ct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id_t",
            |m: &TournamentMatchSetup| { &m.team_id_t },
            |m: &mut TournamentMatchSetup| { &mut m.team_id_t },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_stage_id",
            |m: &TournamentMatchSetup| { &m.event_stage_id },
            |m: &mut TournamentMatchSetup| { &mut m.event_stage_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TournamentMatchSetup>(
            "TournamentMatchSetup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TournamentMatchSetup {
    const NAME: &'static str = "TournamentMatchSetup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.team_id_ct = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.team_id_t = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.event_stage_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.team_id_ct {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.team_id_t {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.event_stage_id {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.team_id_ct {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.team_id_t {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.event_stage_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TournamentMatchSetup {
        TournamentMatchSetup::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.team_id_ct = ::std::option::Option::None;
        self.team_id_t = ::std::option::Option::None;
        self.event_stage_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TournamentMatchSetup {
        static instance: TournamentMatchSetup = TournamentMatchSetup {
            event_id: ::std::option::Option::None,
            team_id_ct: ::std::option::Option::None,
            team_id_t: ::std::option::Option::None,
            event_stage_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TournamentMatchSetup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TournamentMatchSetup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TournamentMatchSetup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TournamentMatchSetup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ServerHltvInfo)
pub struct ServerHltvInfo {
    // message fields
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_udp_port)
    pub tv_udp_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_watch_key)
    pub tv_watch_key: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_slots)
    pub tv_slots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_clients)
    pub tv_clients: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_proxies)
    pub tv_proxies: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_time)
    pub tv_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.game_type)
    pub game_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.game_mapgroup)
    pub game_mapgroup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServerHltvInfo.game_map)
    pub game_map: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_master_steamid)
    pub tv_master_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_local_slots)
    pub tv_local_slots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_local_clients)
    pub tv_local_clients: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_local_proxies)
    pub tv_local_proxies: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_relay_slots)
    pub tv_relay_slots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_relay_clients)
    pub tv_relay_clients: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_relay_proxies)
    pub tv_relay_proxies: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_relay_address)
    pub tv_relay_address: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_relay_port)
    pub tv_relay_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ServerHltvInfo.tv_relay_steamid)
    pub tv_relay_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:ServerHltvInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServerHltvInfo {
    fn default() -> &'a ServerHltvInfo {
        <ServerHltvInfo as ::protobuf::Message>::default_instance()
    }
}

impl ServerHltvInfo {
    pub fn new() -> ServerHltvInfo {
        ::std::default::Default::default()
    }

    // optional uint32 tv_udp_port = 1;

    pub fn tv_udp_port(&self) -> u32 {
        self.tv_udp_port.unwrap_or(0)
    }

    pub fn clear_tv_udp_port(&mut self) {
        self.tv_udp_port = ::std::option::Option::None;
    }

    pub fn has_tv_udp_port(&self) -> bool {
        self.tv_udp_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_udp_port(&mut self, v: u32) {
        self.tv_udp_port = ::std::option::Option::Some(v);
    }

    // optional uint64 tv_watch_key = 2;

    pub fn tv_watch_key(&self) -> u64 {
        self.tv_watch_key.unwrap_or(0)
    }

    pub fn clear_tv_watch_key(&mut self) {
        self.tv_watch_key = ::std::option::Option::None;
    }

    pub fn has_tv_watch_key(&self) -> bool {
        self.tv_watch_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_watch_key(&mut self, v: u64) {
        self.tv_watch_key = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_slots = 3;

    pub fn tv_slots(&self) -> u32 {
        self.tv_slots.unwrap_or(0)
    }

    pub fn clear_tv_slots(&mut self) {
        self.tv_slots = ::std::option::Option::None;
    }

    pub fn has_tv_slots(&self) -> bool {
        self.tv_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_slots(&mut self, v: u32) {
        self.tv_slots = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_clients = 4;

    pub fn tv_clients(&self) -> u32 {
        self.tv_clients.unwrap_or(0)
    }

    pub fn clear_tv_clients(&mut self) {
        self.tv_clients = ::std::option::Option::None;
    }

    pub fn has_tv_clients(&self) -> bool {
        self.tv_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_clients(&mut self, v: u32) {
        self.tv_clients = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_proxies = 5;

    pub fn tv_proxies(&self) -> u32 {
        self.tv_proxies.unwrap_or(0)
    }

    pub fn clear_tv_proxies(&mut self) {
        self.tv_proxies = ::std::option::Option::None;
    }

    pub fn has_tv_proxies(&self) -> bool {
        self.tv_proxies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_proxies(&mut self, v: u32) {
        self.tv_proxies = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_time = 6;

    pub fn tv_time(&self) -> u32 {
        self.tv_time.unwrap_or(0)
    }

    pub fn clear_tv_time(&mut self) {
        self.tv_time = ::std::option::Option::None;
    }

    pub fn has_tv_time(&self) -> bool {
        self.tv_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_time(&mut self, v: u32) {
        self.tv_time = ::std::option::Option::Some(v);
    }

    // optional uint32 game_type = 8;

    pub fn game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional string game_mapgroup = 9;

    pub fn game_mapgroup(&self) -> &str {
        match self.game_mapgroup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_mapgroup(&mut self) {
        self.game_mapgroup = ::std::option::Option::None;
    }

    pub fn has_game_mapgroup(&self) -> bool {
        self.game_mapgroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mapgroup(&mut self, v: ::std::string::String) {
        self.game_mapgroup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_mapgroup(&mut self) -> &mut ::std::string::String {
        if self.game_mapgroup.is_none() {
            self.game_mapgroup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_mapgroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_mapgroup(&mut self) -> ::std::string::String {
        self.game_mapgroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_map = 10;

    pub fn game_map(&self) -> &str {
        match self.game_map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_map(&mut self) {
        self.game_map = ::std::option::Option::None;
    }

    pub fn has_game_map(&self) -> bool {
        self.game_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_map(&mut self, v: ::std::string::String) {
        self.game_map = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_map(&mut self) -> &mut ::std::string::String {
        if self.game_map.is_none() {
            self.game_map = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_map.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_map(&mut self) -> ::std::string::String {
        self.game_map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 tv_master_steamid = 11;

    pub fn tv_master_steamid(&self) -> u64 {
        self.tv_master_steamid.unwrap_or(0)
    }

    pub fn clear_tv_master_steamid(&mut self) {
        self.tv_master_steamid = ::std::option::Option::None;
    }

    pub fn has_tv_master_steamid(&self) -> bool {
        self.tv_master_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_master_steamid(&mut self, v: u64) {
        self.tv_master_steamid = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_local_slots = 12;

    pub fn tv_local_slots(&self) -> u32 {
        self.tv_local_slots.unwrap_or(0)
    }

    pub fn clear_tv_local_slots(&mut self) {
        self.tv_local_slots = ::std::option::Option::None;
    }

    pub fn has_tv_local_slots(&self) -> bool {
        self.tv_local_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_local_slots(&mut self, v: u32) {
        self.tv_local_slots = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_local_clients = 13;

    pub fn tv_local_clients(&self) -> u32 {
        self.tv_local_clients.unwrap_or(0)
    }

    pub fn clear_tv_local_clients(&mut self) {
        self.tv_local_clients = ::std::option::Option::None;
    }

    pub fn has_tv_local_clients(&self) -> bool {
        self.tv_local_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_local_clients(&mut self, v: u32) {
        self.tv_local_clients = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_local_proxies = 14;

    pub fn tv_local_proxies(&self) -> u32 {
        self.tv_local_proxies.unwrap_or(0)
    }

    pub fn clear_tv_local_proxies(&mut self) {
        self.tv_local_proxies = ::std::option::Option::None;
    }

    pub fn has_tv_local_proxies(&self) -> bool {
        self.tv_local_proxies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_local_proxies(&mut self, v: u32) {
        self.tv_local_proxies = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_relay_slots = 15;

    pub fn tv_relay_slots(&self) -> u32 {
        self.tv_relay_slots.unwrap_or(0)
    }

    pub fn clear_tv_relay_slots(&mut self) {
        self.tv_relay_slots = ::std::option::Option::None;
    }

    pub fn has_tv_relay_slots(&self) -> bool {
        self.tv_relay_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_slots(&mut self, v: u32) {
        self.tv_relay_slots = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_relay_clients = 16;

    pub fn tv_relay_clients(&self) -> u32 {
        self.tv_relay_clients.unwrap_or(0)
    }

    pub fn clear_tv_relay_clients(&mut self) {
        self.tv_relay_clients = ::std::option::Option::None;
    }

    pub fn has_tv_relay_clients(&self) -> bool {
        self.tv_relay_clients.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_clients(&mut self, v: u32) {
        self.tv_relay_clients = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_relay_proxies = 17;

    pub fn tv_relay_proxies(&self) -> u32 {
        self.tv_relay_proxies.unwrap_or(0)
    }

    pub fn clear_tv_relay_proxies(&mut self) {
        self.tv_relay_proxies = ::std::option::Option::None;
    }

    pub fn has_tv_relay_proxies(&self) -> bool {
        self.tv_relay_proxies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_proxies(&mut self, v: u32) {
        self.tv_relay_proxies = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_relay_address = 18;

    pub fn tv_relay_address(&self) -> u32 {
        self.tv_relay_address.unwrap_or(0)
    }

    pub fn clear_tv_relay_address(&mut self) {
        self.tv_relay_address = ::std::option::Option::None;
    }

    pub fn has_tv_relay_address(&self) -> bool {
        self.tv_relay_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_address(&mut self, v: u32) {
        self.tv_relay_address = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_relay_port = 19;

    pub fn tv_relay_port(&self) -> u32 {
        self.tv_relay_port.unwrap_or(0)
    }

    pub fn clear_tv_relay_port(&mut self) {
        self.tv_relay_port = ::std::option::Option::None;
    }

    pub fn has_tv_relay_port(&self) -> bool {
        self.tv_relay_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_port(&mut self, v: u32) {
        self.tv_relay_port = ::std::option::Option::Some(v);
    }

    // optional uint64 tv_relay_steamid = 20;

    pub fn tv_relay_steamid(&self) -> u64 {
        self.tv_relay_steamid.unwrap_or(0)
    }

    pub fn clear_tv_relay_steamid(&mut self) {
        self.tv_relay_steamid = ::std::option::Option::None;
    }

    pub fn has_tv_relay_steamid(&self) -> bool {
        self.tv_relay_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_steamid(&mut self, v: u64) {
        self.tv_relay_steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(19);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_udp_port",
            |m: &ServerHltvInfo| { &m.tv_udp_port },
            |m: &mut ServerHltvInfo| { &mut m.tv_udp_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_watch_key",
            |m: &ServerHltvInfo| { &m.tv_watch_key },
            |m: &mut ServerHltvInfo| { &mut m.tv_watch_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_slots",
            |m: &ServerHltvInfo| { &m.tv_slots },
            |m: &mut ServerHltvInfo| { &mut m.tv_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_clients",
            |m: &ServerHltvInfo| { &m.tv_clients },
            |m: &mut ServerHltvInfo| { &mut m.tv_clients },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_proxies",
            |m: &ServerHltvInfo| { &m.tv_proxies },
            |m: &mut ServerHltvInfo| { &mut m.tv_proxies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_time",
            |m: &ServerHltvInfo| { &m.tv_time },
            |m: &mut ServerHltvInfo| { &mut m.tv_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_type",
            |m: &ServerHltvInfo| { &m.game_type },
            |m: &mut ServerHltvInfo| { &mut m.game_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mapgroup",
            |m: &ServerHltvInfo| { &m.game_mapgroup },
            |m: &mut ServerHltvInfo| { &mut m.game_mapgroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_map",
            |m: &ServerHltvInfo| { &m.game_map },
            |m: &mut ServerHltvInfo| { &mut m.game_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_master_steamid",
            |m: &ServerHltvInfo| { &m.tv_master_steamid },
            |m: &mut ServerHltvInfo| { &mut m.tv_master_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_local_slots",
            |m: &ServerHltvInfo| { &m.tv_local_slots },
            |m: &mut ServerHltvInfo| { &mut m.tv_local_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_local_clients",
            |m: &ServerHltvInfo| { &m.tv_local_clients },
            |m: &mut ServerHltvInfo| { &mut m.tv_local_clients },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_local_proxies",
            |m: &ServerHltvInfo| { &m.tv_local_proxies },
            |m: &mut ServerHltvInfo| { &mut m.tv_local_proxies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_relay_slots",
            |m: &ServerHltvInfo| { &m.tv_relay_slots },
            |m: &mut ServerHltvInfo| { &mut m.tv_relay_slots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_relay_clients",
            |m: &ServerHltvInfo| { &m.tv_relay_clients },
            |m: &mut ServerHltvInfo| { &mut m.tv_relay_clients },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_relay_proxies",
            |m: &ServerHltvInfo| { &m.tv_relay_proxies },
            |m: &mut ServerHltvInfo| { &mut m.tv_relay_proxies },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_relay_address",
            |m: &ServerHltvInfo| { &m.tv_relay_address },
            |m: &mut ServerHltvInfo| { &mut m.tv_relay_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_relay_port",
            |m: &ServerHltvInfo| { &m.tv_relay_port },
            |m: &mut ServerHltvInfo| { &mut m.tv_relay_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_relay_steamid",
            |m: &ServerHltvInfo| { &m.tv_relay_steamid },
            |m: &mut ServerHltvInfo| { &mut m.tv_relay_steamid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ServerHltvInfo>(
            "ServerHltvInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ServerHltvInfo {
    const NAME: &'static str = "ServerHltvInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tv_udp_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.tv_watch_key = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.tv_slots = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.tv_clients = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.tv_proxies = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.tv_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.game_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    self.game_mapgroup = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.game_map = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.tv_master_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                96 => {
                    self.tv_local_slots = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.tv_local_clients = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.tv_local_proxies = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.tv_relay_slots = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.tv_relay_clients = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.tv_relay_proxies = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.tv_relay_address = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.tv_relay_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.tv_relay_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tv_udp_port {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.tv_watch_key {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.tv_slots {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.tv_clients {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.tv_proxies {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.tv_time {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.game_mapgroup.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.game_map.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.tv_master_steamid {
            my_size += ::protobuf::rt::uint64_size(11, v);
        }
        if let Some(v) = self.tv_local_slots {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.tv_local_clients {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.tv_local_proxies {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.tv_relay_slots {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.tv_relay_clients {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.tv_relay_proxies {
            my_size += ::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.tv_relay_address {
            my_size += ::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.tv_relay_port {
            my_size += ::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.tv_relay_steamid {
            my_size += ::protobuf::rt::uint64_size(20, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.tv_udp_port {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tv_watch_key {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.tv_slots {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tv_clients {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tv_proxies {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.tv_time {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.game_mapgroup.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.game_map.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.tv_master_steamid {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.tv_local_slots {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.tv_local_clients {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.tv_local_proxies {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.tv_relay_slots {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.tv_relay_clients {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.tv_relay_proxies {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.tv_relay_address {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.tv_relay_port {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.tv_relay_steamid {
            os.write_uint64(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServerHltvInfo {
        ServerHltvInfo::new()
    }

    fn clear(&mut self) {
        self.tv_udp_port = ::std::option::Option::None;
        self.tv_watch_key = ::std::option::Option::None;
        self.tv_slots = ::std::option::Option::None;
        self.tv_clients = ::std::option::Option::None;
        self.tv_proxies = ::std::option::Option::None;
        self.tv_time = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.game_mapgroup = ::std::option::Option::None;
        self.game_map = ::std::option::Option::None;
        self.tv_master_steamid = ::std::option::Option::None;
        self.tv_local_slots = ::std::option::Option::None;
        self.tv_local_clients = ::std::option::Option::None;
        self.tv_local_proxies = ::std::option::Option::None;
        self.tv_relay_slots = ::std::option::Option::None;
        self.tv_relay_clients = ::std::option::Option::None;
        self.tv_relay_proxies = ::std::option::Option::None;
        self.tv_relay_address = ::std::option::Option::None;
        self.tv_relay_port = ::std::option::Option::None;
        self.tv_relay_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServerHltvInfo {
        static instance: ServerHltvInfo = ServerHltvInfo {
            tv_udp_port: ::std::option::Option::None,
            tv_watch_key: ::std::option::Option::None,
            tv_slots: ::std::option::Option::None,
            tv_clients: ::std::option::Option::None,
            tv_proxies: ::std::option::Option::None,
            tv_time: ::std::option::Option::None,
            game_type: ::std::option::Option::None,
            game_mapgroup: ::std::option::Option::None,
            game_map: ::std::option::Option::None,
            tv_master_steamid: ::std::option::Option::None,
            tv_local_slots: ::std::option::Option::None,
            tv_local_clients: ::std::option::Option::None,
            tv_local_proxies: ::std::option::Option::None,
            tv_relay_slots: ::std::option::Option::None,
            tv_relay_clients: ::std::option::Option::None,
            tv_relay_proxies: ::std::option::Option::None,
            tv_relay_address: ::std::option::Option::None,
            tv_relay_port: ::std::option::Option::None,
            tv_relay_steamid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ServerHltvInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServerHltvInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServerHltvInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerHltvInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:IpAddressMask)
pub struct IpAddressMask {
    // message fields
    // @@protoc_insertion_point(field:IpAddressMask.a)
    pub a: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:IpAddressMask.b)
    pub b: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:IpAddressMask.c)
    pub c: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:IpAddressMask.d)
    pub d: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:IpAddressMask.bits)
    pub bits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:IpAddressMask.token)
    pub token: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:IpAddressMask.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a IpAddressMask {
    fn default() -> &'a IpAddressMask {
        <IpAddressMask as ::protobuf::Message>::default_instance()
    }
}

impl IpAddressMask {
    pub fn new() -> IpAddressMask {
        ::std::default::Default::default()
    }

    // optional uint32 a = 1;

    pub fn a(&self) -> u32 {
        self.a.unwrap_or(0)
    }

    pub fn clear_a(&mut self) {
        self.a = ::std::option::Option::None;
    }

    pub fn has_a(&self) -> bool {
        self.a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_a(&mut self, v: u32) {
        self.a = ::std::option::Option::Some(v);
    }

    // optional uint32 b = 2;

    pub fn b(&self) -> u32 {
        self.b.unwrap_or(0)
    }

    pub fn clear_b(&mut self) {
        self.b = ::std::option::Option::None;
    }

    pub fn has_b(&self) -> bool {
        self.b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_b(&mut self, v: u32) {
        self.b = ::std::option::Option::Some(v);
    }

    // optional uint32 c = 3;

    pub fn c(&self) -> u32 {
        self.c.unwrap_or(0)
    }

    pub fn clear_c(&mut self) {
        self.c = ::std::option::Option::None;
    }

    pub fn has_c(&self) -> bool {
        self.c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_c(&mut self, v: u32) {
        self.c = ::std::option::Option::Some(v);
    }

    // optional uint32 d = 4;

    pub fn d(&self) -> u32 {
        self.d.unwrap_or(0)
    }

    pub fn clear_d(&mut self) {
        self.d = ::std::option::Option::None;
    }

    pub fn has_d(&self) -> bool {
        self.d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_d(&mut self, v: u32) {
        self.d = ::std::option::Option::Some(v);
    }

    // optional uint32 bits = 5;

    pub fn bits(&self) -> u32 {
        self.bits.unwrap_or(0)
    }

    pub fn clear_bits(&mut self) {
        self.bits = ::std::option::Option::None;
    }

    pub fn has_bits(&self) -> bool {
        self.bits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bits(&mut self, v: u32) {
        self.bits = ::std::option::Option::Some(v);
    }

    // optional uint32 token = 6;

    pub fn token(&self) -> u32 {
        self.token.unwrap_or(0)
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u32) {
        self.token = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "a",
            |m: &IpAddressMask| { &m.a },
            |m: &mut IpAddressMask| { &mut m.a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "b",
            |m: &IpAddressMask| { &m.b },
            |m: &mut IpAddressMask| { &mut m.b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "c",
            |m: &IpAddressMask| { &m.c },
            |m: &mut IpAddressMask| { &mut m.c },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "d",
            |m: &IpAddressMask| { &m.d },
            |m: &mut IpAddressMask| { &mut m.d },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bits",
            |m: &IpAddressMask| { &m.bits },
            |m: &mut IpAddressMask| { &mut m.bits },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &IpAddressMask| { &m.token },
            |m: &mut IpAddressMask| { &mut m.token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<IpAddressMask>(
            "IpAddressMask",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for IpAddressMask {
    const NAME: &'static str = "IpAddressMask";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.a = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.b = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.c = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.d = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.bits = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.token = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.a {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.b {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.c {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.d {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.bits {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.token {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.a {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.b {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.c {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.d {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.bits {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.token {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> IpAddressMask {
        IpAddressMask::new()
    }

    fn clear(&mut self) {
        self.a = ::std::option::Option::None;
        self.b = ::std::option::Option::None;
        self.c = ::std::option::Option::None;
        self.d = ::std::option::Option::None;
        self.bits = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static IpAddressMask {
        static instance: IpAddressMask = IpAddressMask {
            a: ::std::option::Option::None,
            b: ::std::option::Option::None,
            c: ::std::option::Option::None,
            d: ::std::option::Option::None,
            bits: ::std::option::Option::None,
            token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for IpAddressMask {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("IpAddressMask").unwrap()).clone()
    }
}

impl ::std::fmt::Display for IpAddressMask {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IpAddressMask {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:XpProgressData)
pub struct XpProgressData {
    // message fields
    // @@protoc_insertion_point(field:XpProgressData.xp_points)
    pub xp_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:XpProgressData.xp_category)
    pub xp_category: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:XpProgressData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a XpProgressData {
    fn default() -> &'a XpProgressData {
        <XpProgressData as ::protobuf::Message>::default_instance()
    }
}

impl XpProgressData {
    pub fn new() -> XpProgressData {
        ::std::default::Default::default()
    }

    // optional uint32 xp_points = 1;

    pub fn xp_points(&self) -> u32 {
        self.xp_points.unwrap_or(0)
    }

    pub fn clear_xp_points(&mut self) {
        self.xp_points = ::std::option::Option::None;
    }

    pub fn has_xp_points(&self) -> bool {
        self.xp_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_points(&mut self, v: u32) {
        self.xp_points = ::std::option::Option::Some(v);
    }

    // optional int32 xp_category = 2;

    pub fn xp_category(&self) -> i32 {
        self.xp_category.unwrap_or(0)
    }

    pub fn clear_xp_category(&mut self) {
        self.xp_category = ::std::option::Option::None;
    }

    pub fn has_xp_category(&self) -> bool {
        self.xp_category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xp_category(&mut self, v: i32) {
        self.xp_category = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xp_points",
            |m: &XpProgressData| { &m.xp_points },
            |m: &mut XpProgressData| { &mut m.xp_points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "xp_category",
            |m: &XpProgressData| { &m.xp_category },
            |m: &mut XpProgressData| { &mut m.xp_category },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<XpProgressData>(
            "XpProgressData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for XpProgressData {
    const NAME: &'static str = "XpProgressData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.xp_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.xp_category = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.xp_points {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.xp_category {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.xp_points {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.xp_category {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> XpProgressData {
        XpProgressData::new()
    }

    fn clear(&mut self) {
        self.xp_points = ::std::option::Option::None;
        self.xp_category = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static XpProgressData {
        static instance: XpProgressData = XpProgressData {
            xp_points: ::std::option::Option::None,
            xp_category: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for XpProgressData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("XpProgressData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for XpProgressData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for XpProgressData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:MatchEndItemUpdates)
pub struct MatchEndItemUpdates {
    // message fields
    // @@protoc_insertion_point(field:MatchEndItemUpdates.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:MatchEndItemUpdates.item_attr_defidx)
    pub item_attr_defidx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:MatchEndItemUpdates.item_attr_delta_value)
    pub item_attr_delta_value: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:MatchEndItemUpdates.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MatchEndItemUpdates {
    fn default() -> &'a MatchEndItemUpdates {
        <MatchEndItemUpdates as ::protobuf::Message>::default_instance()
    }
}

impl MatchEndItemUpdates {
    pub fn new() -> MatchEndItemUpdates {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_attr_defidx = 2;

    pub fn item_attr_defidx(&self) -> u32 {
        self.item_attr_defidx.unwrap_or(0)
    }

    pub fn clear_item_attr_defidx(&mut self) {
        self.item_attr_defidx = ::std::option::Option::None;
    }

    pub fn has_item_attr_defidx(&self) -> bool {
        self.item_attr_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_attr_defidx(&mut self, v: u32) {
        self.item_attr_defidx = ::std::option::Option::Some(v);
    }

    // optional uint32 item_attr_delta_value = 3;

    pub fn item_attr_delta_value(&self) -> u32 {
        self.item_attr_delta_value.unwrap_or(0)
    }

    pub fn clear_item_attr_delta_value(&mut self) {
        self.item_attr_delta_value = ::std::option::Option::None;
    }

    pub fn has_item_attr_delta_value(&self) -> bool {
        self.item_attr_delta_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_attr_delta_value(&mut self, v: u32) {
        self.item_attr_delta_value = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_id",
            |m: &MatchEndItemUpdates| { &m.item_id },
            |m: &mut MatchEndItemUpdates| { &mut m.item_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_attr_defidx",
            |m: &MatchEndItemUpdates| { &m.item_attr_defidx },
            |m: &mut MatchEndItemUpdates| { &mut m.item_attr_defidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "item_attr_delta_value",
            |m: &MatchEndItemUpdates| { &m.item_attr_delta_value },
            |m: &mut MatchEndItemUpdates| { &mut m.item_attr_delta_value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MatchEndItemUpdates>(
            "MatchEndItemUpdates",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MatchEndItemUpdates {
    const NAME: &'static str = "MatchEndItemUpdates";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_attr_defidx = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_attr_delta_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_attr_defidx {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_attr_delta_value {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_attr_defidx {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_attr_delta_value {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MatchEndItemUpdates {
        MatchEndItemUpdates::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.item_attr_defidx = ::std::option::Option::None;
        self.item_attr_delta_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MatchEndItemUpdates {
        static instance: MatchEndItemUpdates = MatchEndItemUpdates {
            item_id: ::std::option::Option::None,
            item_attr_defidx: ::std::option::Option::None,
            item_attr_delta_value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MatchEndItemUpdates {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MatchEndItemUpdates").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MatchEndItemUpdates {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MatchEndItemUpdates {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:ScoreLeaderboardData)
pub struct ScoreLeaderboardData {
    // message fields
    // @@protoc_insertion_point(field:ScoreLeaderboardData.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:ScoreLeaderboardData.score)
    pub score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:ScoreLeaderboardData.accountentries)
    pub accountentries: ::std::vec::Vec<score_leaderboard_data::AccountEntries>,
    // @@protoc_insertion_point(field:ScoreLeaderboardData.matchentries)
    pub matchentries: ::std::vec::Vec<score_leaderboard_data::Entry>,
    // special fields
    // @@protoc_insertion_point(special_field:ScoreLeaderboardData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ScoreLeaderboardData {
    fn default() -> &'a ScoreLeaderboardData {
        <ScoreLeaderboardData as ::protobuf::Message>::default_instance()
    }
}

impl ScoreLeaderboardData {
    pub fn new() -> ScoreLeaderboardData {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 2;

    pub fn score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quest_id",
            |m: &ScoreLeaderboardData| { &m.quest_id },
            |m: &mut ScoreLeaderboardData| { &mut m.quest_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score",
            |m: &ScoreLeaderboardData| { &m.score },
            |m: &mut ScoreLeaderboardData| { &mut m.score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accountentries",
            |m: &ScoreLeaderboardData| { &m.accountentries },
            |m: &mut ScoreLeaderboardData| { &mut m.accountentries },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matchentries",
            |m: &ScoreLeaderboardData| { &m.matchentries },
            |m: &mut ScoreLeaderboardData| { &mut m.matchentries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ScoreLeaderboardData>(
            "ScoreLeaderboardData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ScoreLeaderboardData {
    const NAME: &'static str = "ScoreLeaderboardData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.score = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.accountentries.push(is.read_message()?);
                },
                42 => {
                    self.matchentries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.accountentries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.matchentries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(2, v)?;
        }
        for v in &self.accountentries {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.matchentries {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ScoreLeaderboardData {
        ScoreLeaderboardData::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.accountentries.clear();
        self.matchentries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ScoreLeaderboardData {
        static instance: ScoreLeaderboardData = ScoreLeaderboardData {
            quest_id: ::std::option::Option::None,
            score: ::std::option::Option::None,
            accountentries: ::std::vec::Vec::new(),
            matchentries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ScoreLeaderboardData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ScoreLeaderboardData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ScoreLeaderboardData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScoreLeaderboardData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `ScoreLeaderboardData`
pub mod score_leaderboard_data {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:ScoreLeaderboardData.Entry)
    pub struct Entry {
        // message fields
        // @@protoc_insertion_point(field:ScoreLeaderboardData.Entry.tag)
        pub tag: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:ScoreLeaderboardData.Entry.val)
        pub val: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:ScoreLeaderboardData.Entry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Entry {
        fn default() -> &'a Entry {
            <Entry as ::protobuf::Message>::default_instance()
        }
    }

    impl Entry {
        pub fn new() -> Entry {
            ::std::default::Default::default()
        }

        // optional uint32 tag = 1;

        pub fn tag(&self) -> u32 {
            self.tag.unwrap_or(0)
        }

        pub fn clear_tag(&mut self) {
            self.tag = ::std::option::Option::None;
        }

        pub fn has_tag(&self) -> bool {
            self.tag.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tag(&mut self, v: u32) {
            self.tag = ::std::option::Option::Some(v);
        }

        // optional uint32 val = 2;

        pub fn val(&self) -> u32 {
            self.val.unwrap_or(0)
        }

        pub fn clear_val(&mut self) {
            self.val = ::std::option::Option::None;
        }

        pub fn has_val(&self) -> bool {
            self.val.is_some()
        }

        // Param is passed by value, moved
        pub fn set_val(&mut self, v: u32) {
            self.val = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "tag",
                |m: &Entry| { &m.tag },
                |m: &mut Entry| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "val",
                |m: &Entry| { &m.val },
                |m: &mut Entry| { &mut m.val },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entry>(
                "ScoreLeaderboardData.Entry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Entry {
        const NAME: &'static str = "Entry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.tag = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.val = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tag {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.val {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.tag {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.val {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Entry {
            Entry::new()
        }

        fn clear(&mut self) {
            self.tag = ::std::option::Option::None;
            self.val = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Entry {
            static instance: Entry = Entry {
                tag: ::std::option::Option::None,
                val: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Entry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ScoreLeaderboardData.Entry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Entry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Entry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:ScoreLeaderboardData.AccountEntries)
    pub struct AccountEntries {
        // message fields
        // @@protoc_insertion_point(field:ScoreLeaderboardData.AccountEntries.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:ScoreLeaderboardData.AccountEntries.entries)
        pub entries: ::std::vec::Vec<Entry>,
        // special fields
        // @@protoc_insertion_point(special_field:ScoreLeaderboardData.AccountEntries.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AccountEntries {
        fn default() -> &'a AccountEntries {
            <AccountEntries as ::protobuf::Message>::default_instance()
        }
    }

    impl AccountEntries {
        pub fn new() -> AccountEntries {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &AccountEntries| { &m.accountid },
                |m: &mut AccountEntries| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "entries",
                |m: &AccountEntries| { &m.entries },
                |m: &mut AccountEntries| { &mut m.entries },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AccountEntries>(
                "ScoreLeaderboardData.AccountEntries",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for AccountEntries {
        const NAME: &'static str = "AccountEntries";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.entries.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.entries {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            for v in &self.entries {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AccountEntries {
            AccountEntries::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.entries.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AccountEntries {
            static instance: AccountEntries = AccountEntries {
                accountid: ::std::option::Option::None,
                entries: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for AccountEntries {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("ScoreLeaderboardData.AccountEntries").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for AccountEntries {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for AccountEntries {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:PlayerQuestData)
pub struct PlayerQuestData {
    // message fields
    // @@protoc_insertion_point(field:PlayerQuestData.quester_account_id)
    pub quester_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerQuestData.quest_item_data)
    pub quest_item_data: ::std::vec::Vec<player_quest_data::QuestItemData>,
    // @@protoc_insertion_point(field:PlayerQuestData.xp_progress_data)
    pub xp_progress_data: ::std::vec::Vec<XpProgressData>,
    // @@protoc_insertion_point(field:PlayerQuestData.time_played)
    pub time_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerQuestData.mm_game_mode)
    pub mm_game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:PlayerQuestData.item_updates)
    pub item_updates: ::std::vec::Vec<MatchEndItemUpdates>,
    // special fields
    // @@protoc_insertion_point(special_field:PlayerQuestData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PlayerQuestData {
    fn default() -> &'a PlayerQuestData {
        <PlayerQuestData as ::protobuf::Message>::default_instance()
    }
}

impl PlayerQuestData {
    pub fn new() -> PlayerQuestData {
        ::std::default::Default::default()
    }

    // optional uint32 quester_account_id = 1;

    pub fn quester_account_id(&self) -> u32 {
        self.quester_account_id.unwrap_or(0)
    }

    pub fn clear_quester_account_id(&mut self) {
        self.quester_account_id = ::std::option::Option::None;
    }

    pub fn has_quester_account_id(&self) -> bool {
        self.quester_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quester_account_id(&mut self, v: u32) {
        self.quester_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 time_played = 4;

    pub fn time_played(&self) -> u32 {
        self.time_played.unwrap_or(0)
    }

    pub fn clear_time_played(&mut self) {
        self.time_played = ::std::option::Option::None;
    }

    pub fn has_time_played(&self) -> bool {
        self.time_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_played(&mut self, v: u32) {
        self.time_played = ::std::option::Option::Some(v);
    }

    // optional uint32 mm_game_mode = 5;

    pub fn mm_game_mode(&self) -> u32 {
        self.mm_game_mode.unwrap_or(0)
    }

    pub fn clear_mm_game_mode(&mut self) {
        self.mm_game_mode = ::std::option::Option::None;
    }

    pub fn has_mm_game_mode(&self) -> bool {
        self.mm_game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mm_game_mode(&mut self, v: u32) {
        self.mm_game_mode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quester_account_id",
            |m: &PlayerQuestData| { &m.quester_account_id },
            |m: &mut PlayerQuestData| { &mut m.quester_account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "quest_item_data",
            |m: &PlayerQuestData| { &m.quest_item_data },
            |m: &mut PlayerQuestData| { &mut m.quest_item_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "xp_progress_data",
            |m: &PlayerQuestData| { &m.xp_progress_data },
            |m: &mut PlayerQuestData| { &mut m.xp_progress_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_played",
            |m: &PlayerQuestData| { &m.time_played },
            |m: &mut PlayerQuestData| { &mut m.time_played },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mm_game_mode",
            |m: &PlayerQuestData| { &m.mm_game_mode },
            |m: &mut PlayerQuestData| { &mut m.mm_game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "item_updates",
            |m: &PlayerQuestData| { &m.item_updates },
            |m: &mut PlayerQuestData| { &mut m.item_updates },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PlayerQuestData>(
            "PlayerQuestData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PlayerQuestData {
    const NAME: &'static str = "PlayerQuestData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quester_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.quest_item_data.push(is.read_message()?);
                },
                26 => {
                    self.xp_progress_data.push(is.read_message()?);
                },
                32 => {
                    self.time_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.mm_game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.item_updates.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quester_account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.quest_item_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.xp_progress_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.time_played {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.mm_game_mode {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        for value in &self.item_updates {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.quester_account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.quest_item_data {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.xp_progress_data {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.time_played {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.mm_game_mode {
            os.write_uint32(5, v)?;
        }
        for v in &self.item_updates {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PlayerQuestData {
        PlayerQuestData::new()
    }

    fn clear(&mut self) {
        self.quester_account_id = ::std::option::Option::None;
        self.quest_item_data.clear();
        self.xp_progress_data.clear();
        self.time_played = ::std::option::Option::None;
        self.mm_game_mode = ::std::option::Option::None;
        self.item_updates.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PlayerQuestData {
        static instance: PlayerQuestData = PlayerQuestData {
            quester_account_id: ::std::option::Option::None,
            quest_item_data: ::std::vec::Vec::new(),
            xp_progress_data: ::std::vec::Vec::new(),
            time_played: ::std::option::Option::None,
            mm_game_mode: ::std::option::Option::None,
            item_updates: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PlayerQuestData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PlayerQuestData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PlayerQuestData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PlayerQuestData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `PlayerQuestData`
pub mod player_quest_data {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:PlayerQuestData.QuestItemData)
    pub struct QuestItemData {
        // message fields
        // @@protoc_insertion_point(field:PlayerQuestData.QuestItemData.quest_id)
        pub quest_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:PlayerQuestData.QuestItemData.quest_normal_points_earned)
        pub quest_normal_points_earned: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:PlayerQuestData.QuestItemData.quest_bonus_points_earned)
        pub quest_bonus_points_earned: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:PlayerQuestData.QuestItemData.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a QuestItemData {
        fn default() -> &'a QuestItemData {
            <QuestItemData as ::protobuf::Message>::default_instance()
        }
    }

    impl QuestItemData {
        pub fn new() -> QuestItemData {
            ::std::default::Default::default()
        }

        // optional uint64 quest_id = 1;

        pub fn quest_id(&self) -> u64 {
            self.quest_id.unwrap_or(0)
        }

        pub fn clear_quest_id(&mut self) {
            self.quest_id = ::std::option::Option::None;
        }

        pub fn has_quest_id(&self) -> bool {
            self.quest_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quest_id(&mut self, v: u64) {
            self.quest_id = ::std::option::Option::Some(v);
        }

        // optional int32 quest_normal_points_earned = 2;

        pub fn quest_normal_points_earned(&self) -> i32 {
            self.quest_normal_points_earned.unwrap_or(0)
        }

        pub fn clear_quest_normal_points_earned(&mut self) {
            self.quest_normal_points_earned = ::std::option::Option::None;
        }

        pub fn has_quest_normal_points_earned(&self) -> bool {
            self.quest_normal_points_earned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quest_normal_points_earned(&mut self, v: i32) {
            self.quest_normal_points_earned = ::std::option::Option::Some(v);
        }

        // optional int32 quest_bonus_points_earned = 3;

        pub fn quest_bonus_points_earned(&self) -> i32 {
            self.quest_bonus_points_earned.unwrap_or(0)
        }

        pub fn clear_quest_bonus_points_earned(&mut self) {
            self.quest_bonus_points_earned = ::std::option::Option::None;
        }

        pub fn has_quest_bonus_points_earned(&self) -> bool {
            self.quest_bonus_points_earned.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quest_bonus_points_earned(&mut self, v: i32) {
            self.quest_bonus_points_earned = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "quest_id",
                |m: &QuestItemData| { &m.quest_id },
                |m: &mut QuestItemData| { &mut m.quest_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "quest_normal_points_earned",
                |m: &QuestItemData| { &m.quest_normal_points_earned },
                |m: &mut QuestItemData| { &mut m.quest_normal_points_earned },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "quest_bonus_points_earned",
                |m: &QuestItemData| { &m.quest_bonus_points_earned },
                |m: &mut QuestItemData| { &mut m.quest_bonus_points_earned },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<QuestItemData>(
                "PlayerQuestData.QuestItemData",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for QuestItemData {
        const NAME: &'static str = "QuestItemData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.quest_normal_points_earned = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.quest_bonus_points_earned = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.quest_id {
                my_size += ::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.quest_normal_points_earned {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.quest_bonus_points_earned {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.quest_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.quest_normal_points_earned {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.quest_bonus_points_earned {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> QuestItemData {
            QuestItemData::new()
        }

        fn clear(&mut self) {
            self.quest_id = ::std::option::Option::None;
            self.quest_normal_points_earned = ::std::option::Option::None;
            self.quest_bonus_points_earned = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static QuestItemData {
            static instance: QuestItemData = QuestItemData {
                quest_id: ::std::option::Option::None,
                quest_normal_points_earned: ::std::option::Option::None,
                quest_bonus_points_earned: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for QuestItemData {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("PlayerQuestData.QuestItemData").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for QuestItemData {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for QuestItemData {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGC_ServerQuestUpdateData)
pub struct CMsgGC_ServerQuestUpdateData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_ServerQuestUpdateData.player_quest_data)
    pub player_quest_data: ::std::vec::Vec<PlayerQuestData>,
    // @@protoc_insertion_point(field:CMsgGC_ServerQuestUpdateData.binary_data)
    pub binary_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGC_ServerQuestUpdateData.mm_game_mode)
    pub mm_game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_ServerQuestUpdateData.missionlbsdata)
    pub missionlbsdata: ::protobuf::MessageField<ScoreLeaderboardData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_ServerQuestUpdateData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_ServerQuestUpdateData {
    fn default() -> &'a CMsgGC_ServerQuestUpdateData {
        <CMsgGC_ServerQuestUpdateData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_ServerQuestUpdateData {
    pub fn new() -> CMsgGC_ServerQuestUpdateData {
        ::std::default::Default::default()
    }

    // optional bytes binary_data = 2;

    pub fn binary_data(&self) -> &[u8] {
        match self.binary_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_binary_data(&mut self) {
        self.binary_data = ::std::option::Option::None;
    }

    pub fn has_binary_data(&self) -> bool {
        self.binary_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_binary_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.binary_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_binary_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.binary_data.is_none() {
            self.binary_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.binary_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_binary_data(&mut self) -> ::std::vec::Vec<u8> {
        self.binary_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 mm_game_mode = 3;

    pub fn mm_game_mode(&self) -> u32 {
        self.mm_game_mode.unwrap_or(0)
    }

    pub fn clear_mm_game_mode(&mut self) {
        self.mm_game_mode = ::std::option::Option::None;
    }

    pub fn has_mm_game_mode(&self) -> bool {
        self.mm_game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mm_game_mode(&mut self, v: u32) {
        self.mm_game_mode = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "player_quest_data",
            |m: &CMsgGC_ServerQuestUpdateData| { &m.player_quest_data },
            |m: &mut CMsgGC_ServerQuestUpdateData| { &mut m.player_quest_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "binary_data",
            |m: &CMsgGC_ServerQuestUpdateData| { &m.binary_data },
            |m: &mut CMsgGC_ServerQuestUpdateData| { &mut m.binary_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mm_game_mode",
            |m: &CMsgGC_ServerQuestUpdateData| { &m.mm_game_mode },
            |m: &mut CMsgGC_ServerQuestUpdateData| { &mut m.mm_game_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ScoreLeaderboardData>(
            "missionlbsdata",
            |m: &CMsgGC_ServerQuestUpdateData| { &m.missionlbsdata },
            |m: &mut CMsgGC_ServerQuestUpdateData| { &mut m.missionlbsdata },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_ServerQuestUpdateData>(
            "CMsgGC_ServerQuestUpdateData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_ServerQuestUpdateData {
    const NAME: &'static str = "CMsgGC_ServerQuestUpdateData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_quest_data.push(is.read_message()?);
                },
                18 => {
                    self.binary_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.mm_game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.missionlbsdata)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_quest_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.binary_data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.mm_game_mode {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.missionlbsdata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.player_quest_data {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.binary_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.mm_game_mode {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.missionlbsdata.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_ServerQuestUpdateData {
        CMsgGC_ServerQuestUpdateData::new()
    }

    fn clear(&mut self) {
        self.player_quest_data.clear();
        self.binary_data = ::std::option::Option::None;
        self.mm_game_mode = ::std::option::Option::None;
        self.missionlbsdata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_ServerQuestUpdateData {
        static instance: CMsgGC_ServerQuestUpdateData = CMsgGC_ServerQuestUpdateData {
            player_quest_data: ::std::vec::Vec::new(),
            binary_data: ::std::option::Option::None,
            mm_game_mode: ::std::option::Option::None,
            missionlbsdata: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_ServerQuestUpdateData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_ServerQuestUpdateData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_ServerQuestUpdateData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_ServerQuestUpdateData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingGCOperationalStats)
pub struct CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.packetid)
    pub packetid: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.namekeys)
    pub namekeys: ::std::vec::Vec<OperationalStatisticDescription>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.packets)
    pub packets: ::std::vec::Vec<OperationalStatisticsPacket>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
        <CMsgGCCStrike15_v2_MatchmakingGCOperationalStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
        ::std::default::Default::default()
    }

    // optional int32 packetid = 1;

    pub fn packetid(&self) -> i32 {
        self.packetid.unwrap_or(0)
    }

    pub fn clear_packetid(&mut self) {
        self.packetid = ::std::option::Option::None;
    }

    pub fn has_packetid(&self) -> bool {
        self.packetid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packetid(&mut self, v: i32) {
        self.packetid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "packetid",
            |m: &CMsgGCCStrike15_v2_MatchmakingGCOperationalStats| { &m.packetid },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGCOperationalStats| { &mut m.packetid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "namekeys",
            |m: &CMsgGCCStrike15_v2_MatchmakingGCOperationalStats| { &m.namekeys },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGCOperationalStats| { &mut m.namekeys },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "packets",
            |m: &CMsgGCCStrike15_v2_MatchmakingGCOperationalStats| { &m.packets },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGCOperationalStats| { &mut m.packets },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingGCOperationalStats>(
            "CMsgGCCStrike15_v2_MatchmakingGCOperationalStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingGCOperationalStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.packetid = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.namekeys.push(is.read_message()?);
                },
                26 => {
                    self.packets.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.packetid {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.namekeys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.packets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.packetid {
            os.write_int32(1, v)?;
        }
        for v in &self.namekeys {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.packets {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
        CMsgGCCStrike15_v2_MatchmakingGCOperationalStats::new()
    }

    fn clear(&mut self) {
        self.packetid = ::std::option::Option::None;
        self.namekeys.clear();
        self.packets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
        static instance: CMsgGCCStrike15_v2_MatchmakingGCOperationalStats = CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
            packetid: ::std::option::Option::None,
            namekeys: ::std::vec::Vec::new(),
            packets: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingGCOperationalStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGCOperationalStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm)
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.token)
    pub token: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.stamp)
    pub stamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.exchange)
    pub exchange: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        <CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        ::std::default::Default::default()
    }

    // optional uint32 token = 1;

    pub fn token(&self) -> u32 {
        self.token.unwrap_or(0)
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u32) {
        self.token = ::std::option::Option::Some(v);
    }

    // optional uint32 stamp = 2;

    pub fn stamp(&self) -> u32 {
        self.stamp.unwrap_or(0)
    }

    pub fn clear_stamp(&mut self) {
        self.stamp = ::std::option::Option::None;
    }

    pub fn has_stamp(&self) -> bool {
        self.stamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stamp(&mut self, v: u32) {
        self.stamp = ::std::option::Option::Some(v);
    }

    // optional uint64 exchange = 3;

    pub fn exchange(&self) -> u64 {
        self.exchange.unwrap_or(0)
    }

    pub fn clear_exchange(&mut self) {
        self.exchange = ::std::option::Option::None;
    }

    pub fn has_exchange(&self) -> bool {
        self.exchange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exchange(&mut self, v: u64) {
        self.exchange = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &m.token },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stamp",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &m.stamp },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &mut m.stamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "exchange",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &m.exchange },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm| { &mut m.exchange },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>(
            "CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.token = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.stamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.exchange = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.stamp {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.exchange {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.exchange {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::new()
    }

    fn clear(&mut self) {
        self.token = ::std::option::Option::None;
        self.stamp = ::std::option::Option::None;
        self.exchange = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
        static instance: CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm = CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
            token: ::std::option::Option::None,
            stamp: ::std::option::Option::None,
            exchange: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GC2ServerReservationUpdate)
pub struct CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ServerReservationUpdate.viewers_external_total)
    pub viewers_external_total: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ServerReservationUpdate.viewers_external_steam)
    pub viewers_external_steam: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GC2ServerReservationUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    fn default() -> &'a CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
        <CMsgGCCStrike15_v2_GC2ServerReservationUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
        ::std::default::Default::default()
    }

    // optional uint32 viewers_external_total = 1;

    pub fn viewers_external_total(&self) -> u32 {
        self.viewers_external_total.unwrap_or(0)
    }

    pub fn clear_viewers_external_total(&mut self) {
        self.viewers_external_total = ::std::option::Option::None;
    }

    pub fn has_viewers_external_total(&self) -> bool {
        self.viewers_external_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewers_external_total(&mut self, v: u32) {
        self.viewers_external_total = ::std::option::Option::Some(v);
    }

    // optional uint32 viewers_external_steam = 2;

    pub fn viewers_external_steam(&self) -> u32 {
        self.viewers_external_steam.unwrap_or(0)
    }

    pub fn clear_viewers_external_steam(&mut self) {
        self.viewers_external_steam = ::std::option::Option::None;
    }

    pub fn has_viewers_external_steam(&self) -> bool {
        self.viewers_external_steam.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewers_external_steam(&mut self, v: u32) {
        self.viewers_external_steam = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "viewers_external_total",
            |m: &CMsgGCCStrike15_v2_GC2ServerReservationUpdate| { &m.viewers_external_total },
            |m: &mut CMsgGCCStrike15_v2_GC2ServerReservationUpdate| { &mut m.viewers_external_total },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "viewers_external_steam",
            |m: &CMsgGCCStrike15_v2_GC2ServerReservationUpdate| { &m.viewers_external_steam },
            |m: &mut CMsgGCCStrike15_v2_GC2ServerReservationUpdate| { &mut m.viewers_external_steam },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GC2ServerReservationUpdate>(
            "CMsgGCCStrike15_v2_GC2ServerReservationUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GC2ServerReservationUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.viewers_external_total = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.viewers_external_steam = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.viewers_external_total {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.viewers_external_steam {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.viewers_external_total {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.viewers_external_steam {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
        CMsgGCCStrike15_v2_GC2ServerReservationUpdate::new()
    }

    fn clear(&mut self) {
        self.viewers_external_total = ::std::option::Option::None;
        self.viewers_external_steam = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
        static instance: CMsgGCCStrike15_v2_GC2ServerReservationUpdate = CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
            viewers_external_total: ::std::option::Option::None,
            viewers_external_steam: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GC2ServerReservationUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GC2ServerReservationUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingStart)
pub struct CMsgGCCStrike15_v2_MatchmakingStart {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingStart.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingStart.game_type)
    pub game_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingStart.ticket_data)
    pub ticket_data: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingStart.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingStart.tournament_match)
    pub tournament_match: ::protobuf::MessageField<TournamentMatchSetup>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingStart.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingStart {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingStart {
        <CMsgGCCStrike15_v2_MatchmakingStart as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingStart {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingStart {
        ::std::default::Default::default()
    }

    // optional uint32 game_type = 2;

    pub fn game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional string ticket_data = 3;

    pub fn ticket_data(&self) -> &str {
        match self.ticket_data.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ticket_data(&mut self) {
        self.ticket_data = ::std::option::Option::None;
    }

    pub fn has_ticket_data(&self) -> bool {
        self.ticket_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_data(&mut self, v: ::std::string::String) {
        self.ticket_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket_data(&mut self) -> &mut ::std::string::String {
        if self.ticket_data.is_none() {
            self.ticket_data = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ticket_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket_data(&mut self) -> ::std::string::String {
        self.ticket_data.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 client_version = 4;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids",
            |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.account_ids },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.account_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_type",
            |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.game_type },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.game_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket_data",
            |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.ticket_data },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.ticket_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_version",
            |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.client_version },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.client_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TournamentMatchSetup>(
            "tournament_match",
            |m: &CMsgGCCStrike15_v2_MatchmakingStart| { &m.tournament_match },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingStart| { &mut m.tournament_match },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingStart>(
            "CMsgGCCStrike15_v2_MatchmakingStart",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingStart {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingStart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                16 => {
                    self.game_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.ticket_data = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tournament_match)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.ticket_data.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.client_version {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.tournament_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.game_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ticket_data.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tournament_match.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingStart {
        CMsgGCCStrike15_v2_MatchmakingStart::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.game_type = ::std::option::Option::None;
        self.ticket_data = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.tournament_match.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingStart {
        static instance: CMsgGCCStrike15_v2_MatchmakingStart = CMsgGCCStrike15_v2_MatchmakingStart {
            account_ids: ::std::vec::Vec::new(),
            game_type: ::std::option::Option::None,
            ticket_data: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            tournament_match: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingStart {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingStart").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingStart {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingStart {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingStop)
pub struct CMsgGCCStrike15_v2_MatchmakingStop {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingStop.abandon)
    pub abandon: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingStop.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingStop {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingStop {
        <CMsgGCCStrike15_v2_MatchmakingStop as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingStop {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingStop {
        ::std::default::Default::default()
    }

    // optional int32 abandon = 1;

    pub fn abandon(&self) -> i32 {
        self.abandon.unwrap_or(0)
    }

    pub fn clear_abandon(&mut self) {
        self.abandon = ::std::option::Option::None;
    }

    pub fn has_abandon(&self) -> bool {
        self.abandon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abandon(&mut self, v: i32) {
        self.abandon = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "abandon",
            |m: &CMsgGCCStrike15_v2_MatchmakingStop| { &m.abandon },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingStop| { &mut m.abandon },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingStop>(
            "CMsgGCCStrike15_v2_MatchmakingStop",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingStop {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingStop";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.abandon = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.abandon {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.abandon {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingStop {
        CMsgGCCStrike15_v2_MatchmakingStop::new()
    }

    fn clear(&mut self) {
        self.abandon = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingStop {
        static instance: CMsgGCCStrike15_v2_MatchmakingStop = CMsgGCCStrike15_v2_MatchmakingStop {
            abandon: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingStop {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingStop").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingStop {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingStop {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingClient2ServerPing)
pub struct CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.gameserverpings)
    pub gameserverpings: ::std::vec::Vec<GameServerPing>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.offset_index)
    pub offset_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.final_batch)
    pub final_batch: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
        <CMsgGCCStrike15_v2_MatchmakingClient2ServerPing as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
        ::std::default::Default::default()
    }

    // optional int32 offset_index = 2;

    pub fn offset_index(&self) -> i32 {
        self.offset_index.unwrap_or(0)
    }

    pub fn clear_offset_index(&mut self) {
        self.offset_index = ::std::option::Option::None;
    }

    pub fn has_offset_index(&self) -> bool {
        self.offset_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset_index(&mut self, v: i32) {
        self.offset_index = ::std::option::Option::Some(v);
    }

    // optional int32 final_batch = 3;

    pub fn final_batch(&self) -> i32 {
        self.final_batch.unwrap_or(0)
    }

    pub fn clear_final_batch(&mut self) {
        self.final_batch = ::std::option::Option::None;
    }

    pub fn has_final_batch(&self) -> bool {
        self.final_batch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_final_batch(&mut self, v: i32) {
        self.final_batch = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "gameserverpings",
            |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.gameserverpings },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.gameserverpings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "offset_index",
            |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.offset_index },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.offset_index },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "final_batch",
            |m: &CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &m.final_batch },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingClient2ServerPing| { &mut m.final_batch },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingClient2ServerPing>(
            "CMsgGCCStrike15_v2_MatchmakingClient2ServerPing",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingClient2ServerPing";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.gameserverpings.push(is.read_message()?);
                },
                16 => {
                    self.offset_index = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.final_batch = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.gameserverpings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.offset_index {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.final_batch {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.gameserverpings {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.offset_index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.final_batch {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
        CMsgGCCStrike15_v2_MatchmakingClient2ServerPing::new()
    }

    fn clear(&mut self) {
        self.gameserverpings.clear();
        self.offset_index = ::std::option::Option::None;
        self.final_batch = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
        static instance: CMsgGCCStrike15_v2_MatchmakingClient2ServerPing = CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
            gameserverpings: ::std::vec::Vec::new(),
            offset_index: ::std::option::Option::None,
            final_batch: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingClient2ServerPing").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingClient2ServerPing {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate)
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.matchmaking)
    pub matchmaking: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.waiting_account_id_sessions)
    pub waiting_account_id_sessions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.error)
    pub error: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.ongoingmatch_account_id_sessions)
    pub ongoingmatch_account_id_sessions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.global_stats)
    pub global_stats: ::protobuf::MessageField<GlobalStatistics>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.failping_account_id_sessions)
    pub failping_account_id_sessions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.penalty_account_id_sessions)
    pub penalty_account_id_sessions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.failready_account_id_sessions)
    pub failready_account_id_sessions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.vacbanned_account_id_sessions)
    pub vacbanned_account_id_sessions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.server_ipaddress_mask)
    pub server_ipaddress_mask: ::protobuf::MessageField<IpAddressMask>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.notes)
    pub notes: ::std::vec::Vec<cmsg_gccstrike15_v2_matchmaking_gc2client_update::Note>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.penalty_account_id_sessions_green)
    pub penalty_account_id_sessions_green: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.insufficientlevel_sessions)
    pub insufficientlevel_sessions: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
        <CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
        ::std::default::Default::default()
    }

    // optional int32 matchmaking = 1;

    pub fn matchmaking(&self) -> i32 {
        self.matchmaking.unwrap_or(0)
    }

    pub fn clear_matchmaking(&mut self) {
        self.matchmaking = ::std::option::Option::None;
    }

    pub fn has_matchmaking(&self) -> bool {
        self.matchmaking.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking(&mut self, v: i32) {
        self.matchmaking = ::std::option::Option::Some(v);
    }

    // optional string error = 3;

    pub fn error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchmaking",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.matchmaking },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.matchmaking },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "waiting_account_id_sessions",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.waiting_account_id_sessions },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.waiting_account_id_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.error },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "ongoingmatch_account_id_sessions",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.ongoingmatch_account_id_sessions },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.ongoingmatch_account_id_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GlobalStatistics>(
            "global_stats",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.global_stats },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.global_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "failping_account_id_sessions",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.failping_account_id_sessions },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.failping_account_id_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "penalty_account_id_sessions",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.penalty_account_id_sessions },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.penalty_account_id_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "failready_account_id_sessions",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.failready_account_id_sessions },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.failready_account_id_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "vacbanned_account_id_sessions",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.vacbanned_account_id_sessions },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.vacbanned_account_id_sessions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, IpAddressMask>(
            "server_ipaddress_mask",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.server_ipaddress_mask },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.server_ipaddress_mask },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "notes",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.notes },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.notes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "penalty_account_id_sessions_green",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.penalty_account_id_sessions_green },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.penalty_account_id_sessions_green },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "insufficientlevel_sessions",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &m.insufficientlevel_sessions },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate| { &mut m.insufficientlevel_sessions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate>(
            "CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.matchmaking = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.waiting_account_id_sessions)?;
                },
                16 => {
                    self.waiting_account_id_sessions.push(is.read_uint32()?);
                },
                26 => {
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.ongoingmatch_account_id_sessions)?;
                },
                48 => {
                    self.ongoingmatch_account_id_sessions.push(is.read_uint32()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.global_stats)?;
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.failping_account_id_sessions)?;
                },
                64 => {
                    self.failping_account_id_sessions.push(is.read_uint32()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.penalty_account_id_sessions)?;
                },
                72 => {
                    self.penalty_account_id_sessions.push(is.read_uint32()?);
                },
                82 => {
                    is.read_repeated_packed_uint32_into(&mut self.failready_account_id_sessions)?;
                },
                80 => {
                    self.failready_account_id_sessions.push(is.read_uint32()?);
                },
                90 => {
                    is.read_repeated_packed_uint32_into(&mut self.vacbanned_account_id_sessions)?;
                },
                88 => {
                    self.vacbanned_account_id_sessions.push(is.read_uint32()?);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.server_ipaddress_mask)?;
                },
                106 => {
                    self.notes.push(is.read_message()?);
                },
                114 => {
                    is.read_repeated_packed_uint32_into(&mut self.penalty_account_id_sessions_green)?;
                },
                112 => {
                    self.penalty_account_id_sessions_green.push(is.read_uint32()?);
                },
                122 => {
                    is.read_repeated_packed_uint32_into(&mut self.insufficientlevel_sessions)?;
                },
                120 => {
                    self.insufficientlevel_sessions.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.matchmaking {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        for value in &self.waiting_account_id_sessions {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.ongoingmatch_account_id_sessions {
            my_size += ::protobuf::rt::uint32_size(6, *value);
        };
        if let Some(v) = self.global_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.failping_account_id_sessions {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        for value in &self.penalty_account_id_sessions {
            my_size += ::protobuf::rt::uint32_size(9, *value);
        };
        for value in &self.failready_account_id_sessions {
            my_size += ::protobuf::rt::uint32_size(10, *value);
        };
        for value in &self.vacbanned_account_id_sessions {
            my_size += ::protobuf::rt::uint32_size(11, *value);
        };
        if let Some(v) = self.server_ipaddress_mask.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.notes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.penalty_account_id_sessions_green {
            my_size += ::protobuf::rt::uint32_size(14, *value);
        };
        for value in &self.insufficientlevel_sessions {
            my_size += ::protobuf::rt::uint32_size(15, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.matchmaking {
            os.write_int32(1, v)?;
        }
        for v in &self.waiting_account_id_sessions {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.error.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.ongoingmatch_account_id_sessions {
            os.write_uint32(6, *v)?;
        };
        if let Some(v) = self.global_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.failping_account_id_sessions {
            os.write_uint32(8, *v)?;
        };
        for v in &self.penalty_account_id_sessions {
            os.write_uint32(9, *v)?;
        };
        for v in &self.failready_account_id_sessions {
            os.write_uint32(10, *v)?;
        };
        for v in &self.vacbanned_account_id_sessions {
            os.write_uint32(11, *v)?;
        };
        if let Some(v) = self.server_ipaddress_mask.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        for v in &self.notes {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        for v in &self.penalty_account_id_sessions_green {
            os.write_uint32(14, *v)?;
        };
        for v in &self.insufficientlevel_sessions {
            os.write_uint32(15, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::new()
    }

    fn clear(&mut self) {
        self.matchmaking = ::std::option::Option::None;
        self.waiting_account_id_sessions.clear();
        self.error = ::std::option::Option::None;
        self.ongoingmatch_account_id_sessions.clear();
        self.global_stats.clear();
        self.failping_account_id_sessions.clear();
        self.penalty_account_id_sessions.clear();
        self.failready_account_id_sessions.clear();
        self.vacbanned_account_id_sessions.clear();
        self.server_ipaddress_mask.clear();
        self.notes.clear();
        self.penalty_account_id_sessions_green.clear();
        self.insufficientlevel_sessions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
        static instance: CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
            matchmaking: ::std::option::Option::None,
            waiting_account_id_sessions: ::std::vec::Vec::new(),
            error: ::std::option::Option::None,
            ongoingmatch_account_id_sessions: ::std::vec::Vec::new(),
            global_stats: ::protobuf::MessageField::none(),
            failping_account_id_sessions: ::std::vec::Vec::new(),
            penalty_account_id_sessions: ::std::vec::Vec::new(),
            failready_account_id_sessions: ::std::vec::Vec::new(),
            vacbanned_account_id_sessions: ::std::vec::Vec::new(),
            server_ipaddress_mask: ::protobuf::MessageField::none(),
            notes: ::std::vec::Vec::new(),
            penalty_account_id_sessions_green: ::std::vec::Vec::new(),
            insufficientlevel_sessions: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate`
pub mod cmsg_gccstrike15_v2_matchmaking_gc2client_update {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note)
    pub struct Note {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note.region_id)
        pub region_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note.region_r)
        pub region_r: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note.distance)
        pub distance: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Note {
        fn default() -> &'a Note {
            <Note as ::protobuf::Message>::default_instance()
        }
    }

    impl Note {
        pub fn new() -> Note {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional int32 region_id = 2;

        pub fn region_id(&self) -> i32 {
            self.region_id.unwrap_or(0)
        }

        pub fn clear_region_id(&mut self) {
            self.region_id = ::std::option::Option::None;
        }

        pub fn has_region_id(&self) -> bool {
            self.region_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_region_id(&mut self, v: i32) {
            self.region_id = ::std::option::Option::Some(v);
        }

        // optional float region_r = 3;

        pub fn region_r(&self) -> f32 {
            self.region_r.unwrap_or(0.)
        }

        pub fn clear_region_r(&mut self) {
            self.region_r = ::std::option::Option::None;
        }

        pub fn has_region_r(&self) -> bool {
            self.region_r.is_some()
        }

        // Param is passed by value, moved
        pub fn set_region_r(&mut self, v: f32) {
            self.region_r = ::std::option::Option::Some(v);
        }

        // optional float distance = 4;

        pub fn distance(&self) -> f32 {
            self.distance.unwrap_or(0.)
        }

        pub fn clear_distance(&mut self) {
            self.distance = ::std::option::Option::None;
        }

        pub fn has_distance(&self) -> bool {
            self.distance.is_some()
        }

        // Param is passed by value, moved
        pub fn set_distance(&mut self, v: f32) {
            self.distance = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &Note| { &m.type_ },
                |m: &mut Note| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "region_id",
                |m: &Note| { &m.region_id },
                |m: &mut Note| { &mut m.region_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "region_r",
                |m: &Note| { &m.region_r },
                |m: &mut Note| { &mut m.region_r },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "distance",
                |m: &Note| { &m.distance },
                |m: &mut Note| { &mut m.distance },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Note>(
                "CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Note {
        const NAME: &'static str = "Note";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.region_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    29 => {
                        self.region_r = ::std::option::Option::Some(is.read_float()?);
                    },
                    37 => {
                        self.distance = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.region_id {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.region_r {
                my_size += 1 + 4;
            }
            if let Some(v) = self.distance {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.region_id {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.region_r {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.distance {
                os.write_float(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Note {
            Note::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.region_id = ::std::option::Option::None;
            self.region_r = ::std::option::Option::None;
            self.distance = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Note {
            static instance: Note = Note {
                type_: ::std::option::Option::None,
                region_id: ::std::option::Option::None,
                region_r: ::std::option::Option::None,
                distance: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Note {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Note {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Note {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CDataGCCStrike15_v2_TournamentMatchDraft)
pub struct CDataGCCStrike15_v2_TournamentMatchDraft {
    // message fields
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.event_id)
    pub event_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.event_stage_id)
    pub event_stage_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.team_id_0)
    pub team_id_0: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.team_id_1)
    pub team_id_1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.maps_count)
    pub maps_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.maps_current)
    pub maps_current: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.team_id_start)
    pub team_id_start: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.team_id_veto1)
    pub team_id_veto1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.team_id_pickn)
    pub team_id_pickn: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.drafts)
    pub drafts: ::std::vec::Vec<cdata_gccstrike15_v2_tournament_match_draft::Entry>,
    // special fields
    // @@protoc_insertion_point(special_field:CDataGCCStrike15_v2_TournamentMatchDraft.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_TournamentMatchDraft {
    fn default() -> &'a CDataGCCStrike15_v2_TournamentMatchDraft {
        <CDataGCCStrike15_v2_TournamentMatchDraft as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_TournamentMatchDraft {
    pub fn new() -> CDataGCCStrike15_v2_TournamentMatchDraft {
        ::std::default::Default::default()
    }

    // optional int32 event_id = 1;

    pub fn event_id(&self) -> i32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: i32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional int32 event_stage_id = 2;

    pub fn event_stage_id(&self) -> i32 {
        self.event_stage_id.unwrap_or(0)
    }

    pub fn clear_event_stage_id(&mut self) {
        self.event_stage_id = ::std::option::Option::None;
    }

    pub fn has_event_stage_id(&self) -> bool {
        self.event_stage_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_stage_id(&mut self, v: i32) {
        self.event_stage_id = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_0 = 3;

    pub fn team_id_0(&self) -> i32 {
        self.team_id_0.unwrap_or(0)
    }

    pub fn clear_team_id_0(&mut self) {
        self.team_id_0 = ::std::option::Option::None;
    }

    pub fn has_team_id_0(&self) -> bool {
        self.team_id_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_0(&mut self, v: i32) {
        self.team_id_0 = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_1 = 4;

    pub fn team_id_1(&self) -> i32 {
        self.team_id_1.unwrap_or(0)
    }

    pub fn clear_team_id_1(&mut self) {
        self.team_id_1 = ::std::option::Option::None;
    }

    pub fn has_team_id_1(&self) -> bool {
        self.team_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_1(&mut self, v: i32) {
        self.team_id_1 = ::std::option::Option::Some(v);
    }

    // optional int32 maps_count = 5;

    pub fn maps_count(&self) -> i32 {
        self.maps_count.unwrap_or(0)
    }

    pub fn clear_maps_count(&mut self) {
        self.maps_count = ::std::option::Option::None;
    }

    pub fn has_maps_count(&self) -> bool {
        self.maps_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maps_count(&mut self, v: i32) {
        self.maps_count = ::std::option::Option::Some(v);
    }

    // optional int32 maps_current = 6;

    pub fn maps_current(&self) -> i32 {
        self.maps_current.unwrap_or(0)
    }

    pub fn clear_maps_current(&mut self) {
        self.maps_current = ::std::option::Option::None;
    }

    pub fn has_maps_current(&self) -> bool {
        self.maps_current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maps_current(&mut self, v: i32) {
        self.maps_current = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_start = 7;

    pub fn team_id_start(&self) -> i32 {
        self.team_id_start.unwrap_or(0)
    }

    pub fn clear_team_id_start(&mut self) {
        self.team_id_start = ::std::option::Option::None;
    }

    pub fn has_team_id_start(&self) -> bool {
        self.team_id_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_start(&mut self, v: i32) {
        self.team_id_start = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_veto1 = 8;

    pub fn team_id_veto1(&self) -> i32 {
        self.team_id_veto1.unwrap_or(0)
    }

    pub fn clear_team_id_veto1(&mut self) {
        self.team_id_veto1 = ::std::option::Option::None;
    }

    pub fn has_team_id_veto1(&self) -> bool {
        self.team_id_veto1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_veto1(&mut self, v: i32) {
        self.team_id_veto1 = ::std::option::Option::Some(v);
    }

    // optional int32 team_id_pickn = 9;

    pub fn team_id_pickn(&self) -> i32 {
        self.team_id_pickn.unwrap_or(0)
    }

    pub fn clear_team_id_pickn(&mut self) {
        self.team_id_pickn = ::std::option::Option::None;
    }

    pub fn has_team_id_pickn(&self) -> bool {
        self.team_id_pickn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id_pickn(&mut self, v: i32) {
        self.team_id_pickn = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.event_id },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_stage_id",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.event_stage_id },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.event_stage_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id_0",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.team_id_0 },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.team_id_0 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id_1",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.team_id_1 },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.team_id_1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maps_count",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.maps_count },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.maps_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "maps_current",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.maps_current },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.maps_current },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id_start",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.team_id_start },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.team_id_start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id_veto1",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.team_id_veto1 },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.team_id_veto1 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id_pickn",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.team_id_pickn },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.team_id_pickn },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "drafts",
            |m: &CDataGCCStrike15_v2_TournamentMatchDraft| { &m.drafts },
            |m: &mut CDataGCCStrike15_v2_TournamentMatchDraft| { &mut m.drafts },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDataGCCStrike15_v2_TournamentMatchDraft>(
            "CDataGCCStrike15_v2_TournamentMatchDraft",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentMatchDraft {
    const NAME: &'static str = "CDataGCCStrike15_v2_TournamentMatchDraft";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.event_stage_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.team_id_0 = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.team_id_1 = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.maps_count = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.maps_current = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.team_id_start = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.team_id_veto1 = ::std::option::Option::Some(is.read_int32()?);
                },
                72 => {
                    self.team_id_pickn = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    self.drafts.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.event_stage_id {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.team_id_0 {
            my_size += ::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.team_id_1 {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.maps_count {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.maps_current {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.team_id_start {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.team_id_veto1 {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        if let Some(v) = self.team_id_pickn {
            my_size += ::protobuf::rt::int32_size(9, v);
        }
        for value in &self.drafts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.event_stage_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.team_id_0 {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.team_id_1 {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.maps_count {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.maps_current {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.team_id_start {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.team_id_veto1 {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.team_id_pickn {
            os.write_int32(9, v)?;
        }
        for v in &self.drafts {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDataGCCStrike15_v2_TournamentMatchDraft {
        CDataGCCStrike15_v2_TournamentMatchDraft::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.event_stage_id = ::std::option::Option::None;
        self.team_id_0 = ::std::option::Option::None;
        self.team_id_1 = ::std::option::Option::None;
        self.maps_count = ::std::option::Option::None;
        self.maps_current = ::std::option::Option::None;
        self.team_id_start = ::std::option::Option::None;
        self.team_id_veto1 = ::std::option::Option::None;
        self.team_id_pickn = ::std::option::Option::None;
        self.drafts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentMatchDraft {
        static instance: CDataGCCStrike15_v2_TournamentMatchDraft = CDataGCCStrike15_v2_TournamentMatchDraft {
            event_id: ::std::option::Option::None,
            event_stage_id: ::std::option::Option::None,
            team_id_0: ::std::option::Option::None,
            team_id_1: ::std::option::Option::None,
            maps_count: ::std::option::Option::None,
            maps_current: ::std::option::Option::None,
            team_id_start: ::std::option::Option::None,
            team_id_veto1: ::std::option::Option::None,
            team_id_pickn: ::std::option::Option::None,
            drafts: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDataGCCStrike15_v2_TournamentMatchDraft {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDataGCCStrike15_v2_TournamentMatchDraft").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDataGCCStrike15_v2_TournamentMatchDraft {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentMatchDraft {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDataGCCStrike15_v2_TournamentMatchDraft`
pub mod cdata_gccstrike15_v2_tournament_match_draft {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CDataGCCStrike15_v2_TournamentMatchDraft.Entry)
    pub struct Entry {
        // message fields
        // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.Entry.mapid)
        pub mapid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentMatchDraft.Entry.team_id_ct)
        pub team_id_ct: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDataGCCStrike15_v2_TournamentMatchDraft.Entry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Entry {
        fn default() -> &'a Entry {
            <Entry as ::protobuf::Message>::default_instance()
        }
    }

    impl Entry {
        pub fn new() -> Entry {
            ::std::default::Default::default()
        }

        // optional int32 mapid = 1;

        pub fn mapid(&self) -> i32 {
            self.mapid.unwrap_or(0)
        }

        pub fn clear_mapid(&mut self) {
            self.mapid = ::std::option::Option::None;
        }

        pub fn has_mapid(&self) -> bool {
            self.mapid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_mapid(&mut self, v: i32) {
            self.mapid = ::std::option::Option::Some(v);
        }

        // optional int32 team_id_ct = 2;

        pub fn team_id_ct(&self) -> i32 {
            self.team_id_ct.unwrap_or(0)
        }

        pub fn clear_team_id_ct(&mut self) {
            self.team_id_ct = ::std::option::Option::None;
        }

        pub fn has_team_id_ct(&self) -> bool {
            self.team_id_ct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id_ct(&mut self, v: i32) {
            self.team_id_ct = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "mapid",
                |m: &Entry| { &m.mapid },
                |m: &mut Entry| { &mut m.mapid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "team_id_ct",
                |m: &Entry| { &m.team_id_ct },
                |m: &mut Entry| { &mut m.team_id_ct },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entry>(
                "CDataGCCStrike15_v2_TournamentMatchDraft.Entry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Entry {
        const NAME: &'static str = "Entry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.mapid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.team_id_ct = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.mapid {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.team_id_ct {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.mapid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.team_id_ct {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Entry {
            Entry::new()
        }

        fn clear(&mut self) {
            self.mapid = ::std::option::Option::None;
            self.team_id_ct = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Entry {
            static instance: Entry = Entry {
                mapid: ::std::option::Option::None,
                team_id_ct: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Entry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDataGCCStrike15_v2_TournamentMatchDraft.Entry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Entry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Entry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CPreMatchInfoData)
pub struct CPreMatchInfoData {
    // message fields
    // @@protoc_insertion_point(field:CPreMatchInfoData.predictions_pct)
    pub predictions_pct: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CPreMatchInfoData.draft)
    pub draft: ::protobuf::MessageField<CDataGCCStrike15_v2_TournamentMatchDraft>,
    // @@protoc_insertion_point(field:CPreMatchInfoData.stats)
    pub stats: ::std::vec::Vec<cpre_match_info_data::TeamStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CPreMatchInfoData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CPreMatchInfoData {
    fn default() -> &'a CPreMatchInfoData {
        <CPreMatchInfoData as ::protobuf::Message>::default_instance()
    }
}

impl CPreMatchInfoData {
    pub fn new() -> CPreMatchInfoData {
        ::std::default::Default::default()
    }

    // optional int32 predictions_pct = 1;

    pub fn predictions_pct(&self) -> i32 {
        self.predictions_pct.unwrap_or(0)
    }

    pub fn clear_predictions_pct(&mut self) {
        self.predictions_pct = ::std::option::Option::None;
    }

    pub fn has_predictions_pct(&self) -> bool {
        self.predictions_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_predictions_pct(&mut self, v: i32) {
        self.predictions_pct = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "predictions_pct",
            |m: &CPreMatchInfoData| { &m.predictions_pct },
            |m: &mut CPreMatchInfoData| { &mut m.predictions_pct },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CDataGCCStrike15_v2_TournamentMatchDraft>(
            "draft",
            |m: &CPreMatchInfoData| { &m.draft },
            |m: &mut CPreMatchInfoData| { &mut m.draft },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stats",
            |m: &CPreMatchInfoData| { &m.stats },
            |m: &mut CPreMatchInfoData| { &mut m.stats },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CPreMatchInfoData>(
            "CPreMatchInfoData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CPreMatchInfoData {
    const NAME: &'static str = "CPreMatchInfoData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.predictions_pct = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.draft)?;
                },
                42 => {
                    self.stats.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.predictions_pct {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.draft.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.predictions_pct {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.draft.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.stats {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CPreMatchInfoData {
        CPreMatchInfoData::new()
    }

    fn clear(&mut self) {
        self.predictions_pct = ::std::option::Option::None;
        self.draft.clear();
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CPreMatchInfoData {
        static instance: CPreMatchInfoData = CPreMatchInfoData {
            predictions_pct: ::std::option::Option::None,
            draft: ::protobuf::MessageField::none(),
            stats: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CPreMatchInfoData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CPreMatchInfoData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CPreMatchInfoData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPreMatchInfoData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CPreMatchInfoData`
pub mod cpre_match_info_data {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CPreMatchInfoData.TeamStats)
    pub struct TeamStats {
        // message fields
        // @@protoc_insertion_point(field:CPreMatchInfoData.TeamStats.match_info_idxtxt)
        pub match_info_idxtxt: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CPreMatchInfoData.TeamStats.match_info_txt)
        pub match_info_txt: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CPreMatchInfoData.TeamStats.match_info_teams)
        pub match_info_teams: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CPreMatchInfoData.TeamStats.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamStats {
        fn default() -> &'a TeamStats {
            <TeamStats as ::protobuf::Message>::default_instance()
        }
    }

    impl TeamStats {
        pub fn new() -> TeamStats {
            ::std::default::Default::default()
        }

        // optional int32 match_info_idxtxt = 1;

        pub fn match_info_idxtxt(&self) -> i32 {
            self.match_info_idxtxt.unwrap_or(0)
        }

        pub fn clear_match_info_idxtxt(&mut self) {
            self.match_info_idxtxt = ::std::option::Option::None;
        }

        pub fn has_match_info_idxtxt(&self) -> bool {
            self.match_info_idxtxt.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_info_idxtxt(&mut self, v: i32) {
            self.match_info_idxtxt = ::std::option::Option::Some(v);
        }

        // optional string match_info_txt = 2;

        pub fn match_info_txt(&self) -> &str {
            match self.match_info_txt.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_match_info_txt(&mut self) {
            self.match_info_txt = ::std::option::Option::None;
        }

        pub fn has_match_info_txt(&self) -> bool {
            self.match_info_txt.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_info_txt(&mut self, v: ::std::string::String) {
            self.match_info_txt = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_match_info_txt(&mut self) -> &mut ::std::string::String {
            if self.match_info_txt.is_none() {
                self.match_info_txt = ::std::option::Option::Some(::std::string::String::new());
            }
            self.match_info_txt.as_mut().unwrap()
        }

        // Take field
        pub fn take_match_info_txt(&mut self) -> ::std::string::String {
            self.match_info_txt.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "match_info_idxtxt",
                |m: &TeamStats| { &m.match_info_idxtxt },
                |m: &mut TeamStats| { &mut m.match_info_idxtxt },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "match_info_txt",
                |m: &TeamStats| { &m.match_info_txt },
                |m: &mut TeamStats| { &mut m.match_info_txt },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "match_info_teams",
                |m: &TeamStats| { &m.match_info_teams },
                |m: &mut TeamStats| { &mut m.match_info_teams },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TeamStats>(
                "CPreMatchInfoData.TeamStats",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for TeamStats {
        const NAME: &'static str = "TeamStats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.match_info_idxtxt = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.match_info_txt = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.match_info_teams.push(is.read_string()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.match_info_idxtxt {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.match_info_txt.as_ref() {
                my_size += ::protobuf::rt::string_size(2, &v);
            }
            for value in &self.match_info_teams {
                my_size += ::protobuf::rt::string_size(3, &value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.match_info_idxtxt {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.match_info_txt.as_ref() {
                os.write_string(2, v)?;
            }
            for v in &self.match_info_teams {
                os.write_string(3, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamStats {
            TeamStats::new()
        }

        fn clear(&mut self) {
            self.match_info_idxtxt = ::std::option::Option::None;
            self.match_info_txt = ::std::option::Option::None;
            self.match_info_teams.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamStats {
            static instance: TeamStats = TeamStats {
                match_info_idxtxt: ::std::option::Option::None,
                match_info_txt: ::std::option::Option::None,
                match_info_teams: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for TeamStats {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CPreMatchInfoData.TeamStats").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for TeamStats {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for TeamStats {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve)
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.game_type)
    pub game_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.server_version)
    pub server_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.rankings)
    pub rankings: ::std::vec::Vec<PlayerRankingInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.encryption_key)
    pub encryption_key: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.encryption_key_pub)
    pub encryption_key_pub: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.party_ids)
    pub party_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.whitelist)
    pub whitelist: ::std::vec::Vec<IpAddressMask>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.tv_master_steamid)
    pub tv_master_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.tournament_event)
    pub tournament_event: ::protobuf::MessageField<TournamentEvent>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.tournament_teams)
    pub tournament_teams: ::std::vec::Vec<TournamentTeam>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.tournament_casters_account_ids)
    pub tournament_casters_account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.tv_relay_steamid)
    pub tv_relay_steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.pre_match_data)
    pub pre_match_data: ::protobuf::MessageField<CPreMatchInfoData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        <CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        ::std::default::Default::default()
    }

    // optional uint32 game_type = 2;

    pub fn game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 3;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_version = 4;

    pub fn server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    // optional uint64 encryption_key = 6;

    pub fn encryption_key(&self) -> u64 {
        self.encryption_key.unwrap_or(0)
    }

    pub fn clear_encryption_key(&mut self) {
        self.encryption_key = ::std::option::Option::None;
    }

    pub fn has_encryption_key(&self) -> bool {
        self.encryption_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_key(&mut self, v: u64) {
        self.encryption_key = ::std::option::Option::Some(v);
    }

    // optional uint64 encryption_key_pub = 7;

    pub fn encryption_key_pub(&self) -> u64 {
        self.encryption_key_pub.unwrap_or(0)
    }

    pub fn clear_encryption_key_pub(&mut self) {
        self.encryption_key_pub = ::std::option::Option::None;
    }

    pub fn has_encryption_key_pub(&self) -> bool {
        self.encryption_key_pub.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encryption_key_pub(&mut self, v: u64) {
        self.encryption_key_pub = ::std::option::Option::Some(v);
    }

    // optional uint64 tv_master_steamid = 10;

    pub fn tv_master_steamid(&self) -> u64 {
        self.tv_master_steamid.unwrap_or(0)
    }

    pub fn clear_tv_master_steamid(&mut self) {
        self.tv_master_steamid = ::std::option::Option::None;
    }

    pub fn has_tv_master_steamid(&self) -> bool {
        self.tv_master_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_master_steamid(&mut self, v: u64) {
        self.tv_master_steamid = ::std::option::Option::Some(v);
    }

    // optional uint64 tv_relay_steamid = 14;

    pub fn tv_relay_steamid(&self) -> u64 {
        self.tv_relay_steamid.unwrap_or(0)
    }

    pub fn clear_tv_relay_steamid(&mut self) {
        self.tv_relay_steamid = ::std::option::Option::None;
    }

    pub fn has_tv_relay_steamid(&self) -> bool {
        self.tv_relay_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_relay_steamid(&mut self, v: u64) {
        self.tv_relay_steamid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(15);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.account_ids },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.account_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_type",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.game_type },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.game_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.match_id },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_version",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.server_version },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.server_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rankings",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.rankings },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.rankings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encryption_key",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.encryption_key },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.encryption_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "encryption_key_pub",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.encryption_key_pub },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.encryption_key_pub },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "party_ids",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.party_ids },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.party_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "whitelist",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.whitelist },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.whitelist },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_master_steamid",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.tv_master_steamid },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.tv_master_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TournamentEvent>(
            "tournament_event",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.tournament_event },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.tournament_event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tournament_teams",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.tournament_teams },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.tournament_teams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tournament_casters_account_ids",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.tournament_casters_account_ids },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.tournament_casters_account_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_relay_steamid",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.tv_relay_steamid },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.tv_relay_steamid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CPreMatchInfoData>(
            "pre_match_data",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &m.pre_match_data },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve| { &mut m.pre_match_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>(
            "CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                16 => {
                    self.game_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.server_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.rankings.push(is.read_message()?);
                },
                48 => {
                    self.encryption_key = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.encryption_key_pub = ::std::option::Option::Some(is.read_uint64()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.party_ids)?;
                },
                64 => {
                    self.party_ids.push(is.read_uint32()?);
                },
                74 => {
                    self.whitelist.push(is.read_message()?);
                },
                80 => {
                    self.tv_master_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tournament_event)?;
                },
                98 => {
                    self.tournament_teams.push(is.read_message()?);
                },
                106 => {
                    is.read_repeated_packed_uint32_into(&mut self.tournament_casters_account_ids)?;
                },
                104 => {
                    self.tournament_casters_account_ids.push(is.read_uint32()?);
                },
                112 => {
                    self.tv_relay_steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pre_match_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.rankings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.encryption_key {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.encryption_key_pub {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        for value in &self.party_ids {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        for value in &self.whitelist {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tv_master_steamid {
            my_size += ::protobuf::rt::uint64_size(10, v);
        }
        if let Some(v) = self.tournament_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tournament_teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.tournament_casters_account_ids {
            my_size += ::protobuf::rt::uint32_size(13, *value);
        };
        if let Some(v) = self.tv_relay_steamid {
            my_size += ::protobuf::rt::uint64_size(14, v);
        }
        if let Some(v) = self.pre_match_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.game_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(4, v)?;
        }
        for v in &self.rankings {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.encryption_key {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.encryption_key_pub {
            os.write_uint64(7, v)?;
        }
        for v in &self.party_ids {
            os.write_uint32(8, *v)?;
        };
        for v in &self.whitelist {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.tv_master_steamid {
            os.write_uint64(10, v)?;
        }
        if let Some(v) = self.tournament_event.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        for v in &self.tournament_teams {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        for v in &self.tournament_casters_account_ids {
            os.write_uint32(13, *v)?;
        };
        if let Some(v) = self.tv_relay_steamid {
            os.write_uint64(14, v)?;
        }
        if let Some(v) = self.pre_match_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.game_type = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.server_version = ::std::option::Option::None;
        self.rankings.clear();
        self.encryption_key = ::std::option::Option::None;
        self.encryption_key_pub = ::std::option::Option::None;
        self.party_ids.clear();
        self.whitelist.clear();
        self.tv_master_steamid = ::std::option::Option::None;
        self.tournament_event.clear();
        self.tournament_teams.clear();
        self.tournament_casters_account_ids.clear();
        self.tv_relay_steamid = ::std::option::Option::None;
        self.pre_match_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
        static instance: CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve = CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
            account_ids: ::std::vec::Vec::new(),
            game_type: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            server_version: ::std::option::Option::None,
            rankings: ::std::vec::Vec::new(),
            encryption_key: ::std::option::Option::None,
            encryption_key_pub: ::std::option::Option::None,
            party_ids: ::std::vec::Vec::new(),
            whitelist: ::std::vec::Vec::new(),
            tv_master_steamid: ::std::option::Option::None,
            tournament_event: ::protobuf::MessageField::none(),
            tournament_teams: ::std::vec::Vec::new(),
            tournament_casters_account_ids: ::std::vec::Vec::new(),
            tv_relay_steamid: ::std::option::Option::None,
            pre_match_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse)
pub struct CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.reservationid)
    pub reservationid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.reservation)
    pub reservation: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.map)
    pub map: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.gc_reservation_sent)
    pub gc_reservation_sent: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.server_version)
    pub server_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.tv_info)
    pub tv_info: ::protobuf::MessageField<ServerHltvInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.reward_player_accounts)
    pub reward_player_accounts: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.idle_player_accounts)
    pub idle_player_accounts: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.reward_item_attr_def_idx)
    pub reward_item_attr_def_idx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.reward_item_attr_value)
    pub reward_item_attr_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.reward_item_attr_reward_idx)
    pub reward_item_attr_reward_idx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.reward_drop_list)
    pub reward_drop_list: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.tournament_tag)
    pub tournament_tag: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        <CMsgGCCStrike15_v2_MatchmakingServerReservationResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        ::std::default::Default::default()
    }

    // optional uint64 reservationid = 1;

    pub fn reservationid(&self) -> u64 {
        self.reservationid.unwrap_or(0)
    }

    pub fn clear_reservationid(&mut self) {
        self.reservationid = ::std::option::Option::None;
    }

    pub fn has_reservationid(&self) -> bool {
        self.reservationid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservationid(&mut self, v: u64) {
        self.reservationid = ::std::option::Option::Some(v);
    }

    // optional string map = 3;

    pub fn map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map(&mut self) {
        self.map = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 gc_reservation_sent = 4;

    pub fn gc_reservation_sent(&self) -> u64 {
        self.gc_reservation_sent.unwrap_or(0)
    }

    pub fn clear_gc_reservation_sent(&mut self) {
        self.gc_reservation_sent = ::std::option::Option::None;
    }

    pub fn has_gc_reservation_sent(&self) -> bool {
        self.gc_reservation_sent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gc_reservation_sent(&mut self, v: u64) {
        self.gc_reservation_sent = ::std::option::Option::Some(v);
    }

    // optional uint32 server_version = 5;

    pub fn server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_item_attr_def_idx = 9;

    pub fn reward_item_attr_def_idx(&self) -> u32 {
        self.reward_item_attr_def_idx.unwrap_or(0)
    }

    pub fn clear_reward_item_attr_def_idx(&mut self) {
        self.reward_item_attr_def_idx = ::std::option::Option::None;
    }

    pub fn has_reward_item_attr_def_idx(&self) -> bool {
        self.reward_item_attr_def_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_item_attr_def_idx(&mut self, v: u32) {
        self.reward_item_attr_def_idx = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_item_attr_value = 10;

    pub fn reward_item_attr_value(&self) -> u32 {
        self.reward_item_attr_value.unwrap_or(0)
    }

    pub fn clear_reward_item_attr_value(&mut self) {
        self.reward_item_attr_value = ::std::option::Option::None;
    }

    pub fn has_reward_item_attr_value(&self) -> bool {
        self.reward_item_attr_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_item_attr_value(&mut self, v: u32) {
        self.reward_item_attr_value = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_item_attr_reward_idx = 11;

    pub fn reward_item_attr_reward_idx(&self) -> u32 {
        self.reward_item_attr_reward_idx.unwrap_or(0)
    }

    pub fn clear_reward_item_attr_reward_idx(&mut self) {
        self.reward_item_attr_reward_idx = ::std::option::Option::None;
    }

    pub fn has_reward_item_attr_reward_idx(&self) -> bool {
        self.reward_item_attr_reward_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_item_attr_reward_idx(&mut self, v: u32) {
        self.reward_item_attr_reward_idx = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_drop_list = 12;

    pub fn reward_drop_list(&self) -> u32 {
        self.reward_drop_list.unwrap_or(0)
    }

    pub fn clear_reward_drop_list(&mut self) {
        self.reward_drop_list = ::std::option::Option::None;
    }

    pub fn has_reward_drop_list(&self) -> bool {
        self.reward_drop_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_drop_list(&mut self, v: u32) {
        self.reward_drop_list = ::std::option::Option::Some(v);
    }

    // optional string tournament_tag = 13;

    pub fn tournament_tag(&self) -> &str {
        match self.tournament_tag.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tournament_tag(&mut self) {
        self.tournament_tag = ::std::option::Option::None;
    }

    pub fn has_tournament_tag(&self) -> bool {
        self.tournament_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_tag(&mut self, v: ::std::string::String) {
        self.tournament_tag = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tournament_tag(&mut self) -> &mut ::std::string::String {
        if self.tournament_tag.is_none() {
            self.tournament_tag = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tournament_tag.as_mut().unwrap()
    }

    // Take field
    pub fn take_tournament_tag(&mut self) -> ::std::string::String {
        self.tournament_tag.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reservationid",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reservationid },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reservationid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>(
            "reservation",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reservation },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reservation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.map },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gc_reservation_sent",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.gc_reservation_sent },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.gc_reservation_sent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_version",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.server_version },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.server_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ServerHltvInfo>(
            "tv_info",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.tv_info },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.tv_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reward_player_accounts",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reward_player_accounts },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reward_player_accounts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "idle_player_accounts",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.idle_player_accounts },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.idle_player_accounts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_item_attr_def_idx",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reward_item_attr_def_idx },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reward_item_attr_def_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_item_attr_value",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reward_item_attr_value },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reward_item_attr_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_item_attr_reward_idx",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reward_item_attr_reward_idx },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reward_item_attr_reward_idx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reward_drop_list",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.reward_drop_list },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.reward_drop_list },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tournament_tag",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &m.tournament_tag },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerReservationResponse| { &mut m.tournament_tag },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingServerReservationResponse>(
            "CMsgGCCStrike15_v2_MatchmakingServerReservationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingServerReservationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reservationid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reservation)?;
                },
                26 => {
                    self.map = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.gc_reservation_sent = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.server_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tv_info)?;
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.reward_player_accounts)?;
                },
                56 => {
                    self.reward_player_accounts.push(is.read_uint32()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.idle_player_accounts)?;
                },
                64 => {
                    self.idle_player_accounts.push(is.read_uint32()?);
                },
                72 => {
                    self.reward_item_attr_def_idx = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.reward_item_attr_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.reward_item_attr_reward_idx = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.reward_drop_list = ::std::option::Option::Some(is.read_uint32()?);
                },
                106 => {
                    self.tournament_tag = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reservationid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.gc_reservation_sent {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.tv_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.reward_player_accounts {
            my_size += ::protobuf::rt::uint32_size(7, *value);
        };
        for value in &self.idle_player_accounts {
            my_size += ::protobuf::rt::uint32_size(8, *value);
        };
        if let Some(v) = self.reward_item_attr_def_idx {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.reward_item_attr_value {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.reward_item_attr_reward_idx {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.reward_drop_list {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.tournament_tag.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reservationid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.reservation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.map.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.gc_reservation_sent {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.tv_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        for v in &self.reward_player_accounts {
            os.write_uint32(7, *v)?;
        };
        for v in &self.idle_player_accounts {
            os.write_uint32(8, *v)?;
        };
        if let Some(v) = self.reward_item_attr_def_idx {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.reward_item_attr_value {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.reward_item_attr_reward_idx {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.reward_drop_list {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.tournament_tag.as_ref() {
            os.write_string(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::new()
    }

    fn clear(&mut self) {
        self.reservationid = ::std::option::Option::None;
        self.reservation.clear();
        self.map = ::std::option::Option::None;
        self.gc_reservation_sent = ::std::option::Option::None;
        self.server_version = ::std::option::Option::None;
        self.tv_info.clear();
        self.reward_player_accounts.clear();
        self.idle_player_accounts.clear();
        self.reward_item_attr_def_idx = ::std::option::Option::None;
        self.reward_item_attr_value = ::std::option::Option::None;
        self.reward_item_attr_reward_idx = ::std::option::Option::None;
        self.reward_drop_list = ::std::option::Option::None;
        self.tournament_tag = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
        static instance: CMsgGCCStrike15_v2_MatchmakingServerReservationResponse = CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
            reservationid: ::std::option::Option::None,
            reservation: ::protobuf::MessageField::none(),
            map: ::std::option::Option::None,
            gc_reservation_sent: ::std::option::Option::None,
            server_version: ::std::option::Option::None,
            tv_info: ::protobuf::MessageField::none(),
            reward_player_accounts: ::std::vec::Vec::new(),
            idle_player_accounts: ::std::vec::Vec::new(),
            reward_item_attr_def_idx: ::std::option::Option::None,
            reward_item_attr_value: ::std::option::Option::None,
            reward_item_attr_reward_idx: ::std::option::Option::None,
            reward_drop_list: ::std::option::Option::None,
            tournament_tag: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingServerReservationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingServerReservationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve)
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.serverid)
    pub serverid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.reservationid)
    pub reservationid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.reservation)
    pub reservation: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.map)
    pub map: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.server_address)
    pub server_address: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        <CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        ::std::default::Default::default()
    }

    // optional uint64 serverid = 1;

    pub fn serverid(&self) -> u64 {
        self.serverid.unwrap_or(0)
    }

    pub fn clear_serverid(&mut self) {
        self.serverid = ::std::option::Option::None;
    }

    pub fn has_serverid(&self) -> bool {
        self.serverid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverid(&mut self, v: u64) {
        self.serverid = ::std::option::Option::Some(v);
    }

    // optional uint64 reservationid = 4;

    pub fn reservationid(&self) -> u64 {
        self.reservationid.unwrap_or(0)
    }

    pub fn clear_reservationid(&mut self) {
        self.reservationid = ::std::option::Option::None;
    }

    pub fn has_reservationid(&self) -> bool {
        self.reservationid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservationid(&mut self, v: u64) {
        self.reservationid = ::std::option::Option::Some(v);
    }

    // optional string map = 6;

    pub fn map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map(&mut self) {
        self.map = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string server_address = 7;

    pub fn server_address(&self) -> &str {
        match self.server_address.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_address(&mut self) {
        self.server_address = ::std::option::Option::None;
    }

    pub fn has_server_address(&self) -> bool {
        self.server_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_address(&mut self, v: ::std::string::String) {
        self.server_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_address(&mut self) -> &mut ::std::string::String {
        if self.server_address.is_none() {
            self.server_address = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_address(&mut self) -> ::std::string::String {
        self.server_address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serverid",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.serverid },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.serverid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reservationid",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.reservationid },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.reservationid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>(
            "reservation",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.reservation },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.reservation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.map },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_address",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &m.server_address },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve| { &mut m.server_address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>(
            "CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.serverid = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.reservationid = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reservation)?;
                },
                50 => {
                    self.map = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.server_address = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serverid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.reservationid {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.server_address.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.serverid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.reservationid {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.reservation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.map.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.server_address.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::new()
    }

    fn clear(&mut self) {
        self.serverid = ::std::option::Option::None;
        self.reservationid = ::std::option::Option::None;
        self.reservation.clear();
        self.map = ::std::option::Option::None;
        self.server_address = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
        static instance: CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
            serverid: ::std::option::Option::None,
            reservationid: ::std::option::Option::None,
            reservation: ::protobuf::MessageField::none(),
            map: ::std::option::Option::None,
            server_address: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingServerRoundStats)
pub struct CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.reservationid)
    pub reservationid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.reservation)
    pub reservation: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.map)
    pub map: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.round)
    pub round: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.kills)
    pub kills: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.assists)
    pub assists: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.deaths)
    pub deaths: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.scores)
    pub scores: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.pings)
    pub pings: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.round_result)
    pub round_result: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.match_result)
    pub match_result: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.team_scores)
    pub team_scores: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.confirm)
    pub confirm: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.reservation_stage)
    pub reservation_stage: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.match_duration)
    pub match_duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.enemy_kills)
    pub enemy_kills: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.enemy_headshots)
    pub enemy_headshots: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.enemy_3ks)
    pub enemy_3ks: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.enemy_4ks)
    pub enemy_4ks: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.enemy_5ks)
    pub enemy_5ks: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.mvps)
    pub mvps: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.spectators_count)
    pub spectators_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.spectators_count_tv)
    pub spectators_count_tv: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.spectators_count_lnk)
    pub spectators_count_lnk: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.enemy_kills_agg)
    pub enemy_kills_agg: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.drop_info)
    pub drop_info: ::protobuf::MessageField<cmsg_gccstrike15_v2_matchmaking_server_round_stats::DropInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        <CMsgGCCStrike15_v2_MatchmakingServerRoundStats as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        ::std::default::Default::default()
    }

    // optional uint64 reservationid = 1;

    pub fn reservationid(&self) -> u64 {
        self.reservationid.unwrap_or(0)
    }

    pub fn clear_reservationid(&mut self) {
        self.reservationid = ::std::option::Option::None;
    }

    pub fn has_reservationid(&self) -> bool {
        self.reservationid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservationid(&mut self, v: u64) {
        self.reservationid = ::std::option::Option::Some(v);
    }

    // optional string map = 3;

    pub fn map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map(&mut self) {
        self.map = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 round = 4;

    pub fn round(&self) -> i32 {
        self.round.unwrap_or(0)
    }

    pub fn clear_round(&mut self) {
        self.round = ::std::option::Option::None;
    }

    pub fn has_round(&self) -> bool {
        self.round.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round(&mut self, v: i32) {
        self.round = ::std::option::Option::Some(v);
    }

    // optional int32 round_result = 10;

    pub fn round_result(&self) -> i32 {
        self.round_result.unwrap_or(0)
    }

    pub fn clear_round_result(&mut self) {
        self.round_result = ::std::option::Option::None;
    }

    pub fn has_round_result(&self) -> bool {
        self.round_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_round_result(&mut self, v: i32) {
        self.round_result = ::std::option::Option::Some(v);
    }

    // optional int32 match_result = 11;

    pub fn match_result(&self) -> i32 {
        self.match_result.unwrap_or(0)
    }

    pub fn clear_match_result(&mut self) {
        self.match_result = ::std::option::Option::None;
    }

    pub fn has_match_result(&self) -> bool {
        self.match_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_result(&mut self, v: i32) {
        self.match_result = ::std::option::Option::Some(v);
    }

    // optional int32 reservation_stage = 14;

    pub fn reservation_stage(&self) -> i32 {
        self.reservation_stage.unwrap_or(0)
    }

    pub fn clear_reservation_stage(&mut self) {
        self.reservation_stage = ::std::option::Option::None;
    }

    pub fn has_reservation_stage(&self) -> bool {
        self.reservation_stage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation_stage(&mut self, v: i32) {
        self.reservation_stage = ::std::option::Option::Some(v);
    }

    // optional int32 match_duration = 15;

    pub fn match_duration(&self) -> i32 {
        self.match_duration.unwrap_or(0)
    }

    pub fn clear_match_duration(&mut self) {
        self.match_duration = ::std::option::Option::None;
    }

    pub fn has_match_duration(&self) -> bool {
        self.match_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_duration(&mut self, v: i32) {
        self.match_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 spectators_count = 22;

    pub fn spectators_count(&self) -> u32 {
        self.spectators_count.unwrap_or(0)
    }

    pub fn clear_spectators_count(&mut self) {
        self.spectators_count = ::std::option::Option::None;
    }

    pub fn has_spectators_count(&self) -> bool {
        self.spectators_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectators_count(&mut self, v: u32) {
        self.spectators_count = ::std::option::Option::Some(v);
    }

    // optional uint32 spectators_count_tv = 23;

    pub fn spectators_count_tv(&self) -> u32 {
        self.spectators_count_tv.unwrap_or(0)
    }

    pub fn clear_spectators_count_tv(&mut self) {
        self.spectators_count_tv = ::std::option::Option::None;
    }

    pub fn has_spectators_count_tv(&self) -> bool {
        self.spectators_count_tv.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectators_count_tv(&mut self, v: u32) {
        self.spectators_count_tv = ::std::option::Option::Some(v);
    }

    // optional uint32 spectators_count_lnk = 24;

    pub fn spectators_count_lnk(&self) -> u32 {
        self.spectators_count_lnk.unwrap_or(0)
    }

    pub fn clear_spectators_count_lnk(&mut self) {
        self.spectators_count_lnk = ::std::option::Option::None;
    }

    pub fn has_spectators_count_lnk(&self) -> bool {
        self.spectators_count_lnk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectators_count_lnk(&mut self, v: u32) {
        self.spectators_count_lnk = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(26);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reservationid",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.reservationid },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.reservationid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>(
            "reservation",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.reservation },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.reservation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "map",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.map },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "round",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.round },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.round },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "kills",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.kills },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "assists",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.assists },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.assists },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "deaths",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.deaths },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.deaths },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "scores",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.scores },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.scores },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pings",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.pings },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.pings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "round_result",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.round_result },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.round_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_result",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.match_result },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.match_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "team_scores",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.team_scores },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.team_scores },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>(
            "confirm",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.confirm },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.confirm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reservation_stage",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.reservation_stage },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.reservation_stage },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_duration",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.match_duration },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.match_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_kills",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_kills },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_kills },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_headshots",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_headshots },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_headshots },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_3ks",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_3ks },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_3ks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_4ks",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_4ks },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_4ks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_5ks",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_5ks },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_5ks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "mvps",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.mvps },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.mvps },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spectators_count",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.spectators_count },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.spectators_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spectators_count_tv",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.spectators_count_tv },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.spectators_count_tv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "spectators_count_lnk",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.spectators_count_lnk },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.spectators_count_lnk },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enemy_kills_agg",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.enemy_kills_agg },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.enemy_kills_agg },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, cmsg_gccstrike15_v2_matchmaking_server_round_stats::DropInfo>(
            "drop_info",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &m.drop_info },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerRoundStats| { &mut m.drop_info },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>(
            "CMsgGCCStrike15_v2_MatchmakingServerRoundStats",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingServerRoundStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reservationid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reservation)?;
                },
                26 => {
                    self.map = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.round = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.kills)?;
                },
                40 => {
                    self.kills.push(is.read_int32()?);
                },
                50 => {
                    is.read_repeated_packed_int32_into(&mut self.assists)?;
                },
                48 => {
                    self.assists.push(is.read_int32()?);
                },
                58 => {
                    is.read_repeated_packed_int32_into(&mut self.deaths)?;
                },
                56 => {
                    self.deaths.push(is.read_int32()?);
                },
                66 => {
                    is.read_repeated_packed_int32_into(&mut self.scores)?;
                },
                64 => {
                    self.scores.push(is.read_int32()?);
                },
                74 => {
                    is.read_repeated_packed_int32_into(&mut self.pings)?;
                },
                72 => {
                    self.pings.push(is.read_int32()?);
                },
                80 => {
                    self.round_result = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.match_result = ::std::option::Option::Some(is.read_int32()?);
                },
                98 => {
                    is.read_repeated_packed_int32_into(&mut self.team_scores)?;
                },
                96 => {
                    self.team_scores.push(is.read_int32()?);
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.confirm)?;
                },
                112 => {
                    self.reservation_stage = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.match_duration = ::std::option::Option::Some(is.read_int32()?);
                },
                130 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_kills)?;
                },
                128 => {
                    self.enemy_kills.push(is.read_int32()?);
                },
                138 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_headshots)?;
                },
                136 => {
                    self.enemy_headshots.push(is.read_int32()?);
                },
                146 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_3ks)?;
                },
                144 => {
                    self.enemy_3ks.push(is.read_int32()?);
                },
                154 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_4ks)?;
                },
                152 => {
                    self.enemy_4ks.push(is.read_int32()?);
                },
                162 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_5ks)?;
                },
                160 => {
                    self.enemy_5ks.push(is.read_int32()?);
                },
                170 => {
                    is.read_repeated_packed_int32_into(&mut self.mvps)?;
                },
                168 => {
                    self.mvps.push(is.read_int32()?);
                },
                176 => {
                    self.spectators_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.spectators_count_tv = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.spectators_count_lnk = ::std::option::Option::Some(is.read_uint32()?);
                },
                202 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_kills_agg)?;
                },
                200 => {
                    self.enemy_kills_agg.push(is.read_int32()?);
                },
                210 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.drop_info)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reservationid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.map.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.round {
            my_size += ::protobuf::rt::int32_size(4, v);
        }
        for value in &self.kills {
            my_size += ::protobuf::rt::int32_size(5, *value);
        };
        for value in &self.assists {
            my_size += ::protobuf::rt::int32_size(6, *value);
        };
        for value in &self.deaths {
            my_size += ::protobuf::rt::int32_size(7, *value);
        };
        for value in &self.scores {
            my_size += ::protobuf::rt::int32_size(8, *value);
        };
        for value in &self.pings {
            my_size += ::protobuf::rt::int32_size(9, *value);
        };
        if let Some(v) = self.round_result {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.match_result {
            my_size += ::protobuf::rt::int32_size(11, v);
        }
        for value in &self.team_scores {
            my_size += ::protobuf::rt::int32_size(12, *value);
        };
        if let Some(v) = self.confirm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reservation_stage {
            my_size += ::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.match_duration {
            my_size += ::protobuf::rt::int32_size(15, v);
        }
        for value in &self.enemy_kills {
            my_size += ::protobuf::rt::int32_size(16, *value);
        };
        for value in &self.enemy_headshots {
            my_size += ::protobuf::rt::int32_size(17, *value);
        };
        for value in &self.enemy_3ks {
            my_size += ::protobuf::rt::int32_size(18, *value);
        };
        for value in &self.enemy_4ks {
            my_size += ::protobuf::rt::int32_size(19, *value);
        };
        for value in &self.enemy_5ks {
            my_size += ::protobuf::rt::int32_size(20, *value);
        };
        for value in &self.mvps {
            my_size += ::protobuf::rt::int32_size(21, *value);
        };
        if let Some(v) = self.spectators_count {
            my_size += ::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.spectators_count_tv {
            my_size += ::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.spectators_count_lnk {
            my_size += ::protobuf::rt::uint32_size(24, v);
        }
        for value in &self.enemy_kills_agg {
            my_size += ::protobuf::rt::int32_size(25, *value);
        };
        if let Some(v) = self.drop_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.reservationid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.reservation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.map.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.round {
            os.write_int32(4, v)?;
        }
        for v in &self.kills {
            os.write_int32(5, *v)?;
        };
        for v in &self.assists {
            os.write_int32(6, *v)?;
        };
        for v in &self.deaths {
            os.write_int32(7, *v)?;
        };
        for v in &self.scores {
            os.write_int32(8, *v)?;
        };
        for v in &self.pings {
            os.write_int32(9, *v)?;
        };
        if let Some(v) = self.round_result {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.match_result {
            os.write_int32(11, v)?;
        }
        for v in &self.team_scores {
            os.write_int32(12, *v)?;
        };
        if let Some(v) = self.confirm.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.reservation_stage {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.match_duration {
            os.write_int32(15, v)?;
        }
        for v in &self.enemy_kills {
            os.write_int32(16, *v)?;
        };
        for v in &self.enemy_headshots {
            os.write_int32(17, *v)?;
        };
        for v in &self.enemy_3ks {
            os.write_int32(18, *v)?;
        };
        for v in &self.enemy_4ks {
            os.write_int32(19, *v)?;
        };
        for v in &self.enemy_5ks {
            os.write_int32(20, *v)?;
        };
        for v in &self.mvps {
            os.write_int32(21, *v)?;
        };
        if let Some(v) = self.spectators_count {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.spectators_count_tv {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.spectators_count_lnk {
            os.write_uint32(24, v)?;
        }
        for v in &self.enemy_kills_agg {
            os.write_int32(25, *v)?;
        };
        if let Some(v) = self.drop_info.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        CMsgGCCStrike15_v2_MatchmakingServerRoundStats::new()
    }

    fn clear(&mut self) {
        self.reservationid = ::std::option::Option::None;
        self.reservation.clear();
        self.map = ::std::option::Option::None;
        self.round = ::std::option::Option::None;
        self.kills.clear();
        self.assists.clear();
        self.deaths.clear();
        self.scores.clear();
        self.pings.clear();
        self.round_result = ::std::option::Option::None;
        self.match_result = ::std::option::Option::None;
        self.team_scores.clear();
        self.confirm.clear();
        self.reservation_stage = ::std::option::Option::None;
        self.match_duration = ::std::option::Option::None;
        self.enemy_kills.clear();
        self.enemy_headshots.clear();
        self.enemy_3ks.clear();
        self.enemy_4ks.clear();
        self.enemy_5ks.clear();
        self.mvps.clear();
        self.spectators_count = ::std::option::Option::None;
        self.spectators_count_tv = ::std::option::Option::None;
        self.spectators_count_lnk = ::std::option::Option::None;
        self.enemy_kills_agg.clear();
        self.drop_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
        static instance: CMsgGCCStrike15_v2_MatchmakingServerRoundStats = CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
            reservationid: ::std::option::Option::None,
            reservation: ::protobuf::MessageField::none(),
            map: ::std::option::Option::None,
            round: ::std::option::Option::None,
            kills: ::std::vec::Vec::new(),
            assists: ::std::vec::Vec::new(),
            deaths: ::std::vec::Vec::new(),
            scores: ::std::vec::Vec::new(),
            pings: ::std::vec::Vec::new(),
            round_result: ::std::option::Option::None,
            match_result: ::std::option::Option::None,
            team_scores: ::std::vec::Vec::new(),
            confirm: ::protobuf::MessageField::none(),
            reservation_stage: ::std::option::Option::None,
            match_duration: ::std::option::Option::None,
            enemy_kills: ::std::vec::Vec::new(),
            enemy_headshots: ::std::vec::Vec::new(),
            enemy_3ks: ::std::vec::Vec::new(),
            enemy_4ks: ::std::vec::Vec::new(),
            enemy_5ks: ::std::vec::Vec::new(),
            mvps: ::std::vec::Vec::new(),
            spectators_count: ::std::option::Option::None,
            spectators_count_tv: ::std::option::Option::None,
            spectators_count_lnk: ::std::option::Option::None,
            enemy_kills_agg: ::std::vec::Vec::new(),
            drop_info: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingServerRoundStats").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingServerRoundStats {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCCStrike15_v2_MatchmakingServerRoundStats`
pub mod cmsg_gccstrike15_v2_matchmaking_server_round_stats {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo)
    pub struct DropInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo.account_mvp)
        pub account_mvp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DropInfo {
        fn default() -> &'a DropInfo {
            <DropInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl DropInfo {
        pub fn new() -> DropInfo {
            ::std::default::Default::default()
        }

        // optional uint32 account_mvp = 1;

        pub fn account_mvp(&self) -> u32 {
            self.account_mvp.unwrap_or(0)
        }

        pub fn clear_account_mvp(&mut self) {
            self.account_mvp = ::std::option::Option::None;
        }

        pub fn has_account_mvp(&self) -> bool {
            self.account_mvp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_mvp(&mut self, v: u32) {
            self.account_mvp = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "account_mvp",
                |m: &DropInfo| { &m.account_mvp },
                |m: &mut DropInfo| { &mut m.account_mvp },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DropInfo>(
                "CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for DropInfo {
        const NAME: &'static str = "DropInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_mvp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_mvp {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.account_mvp {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DropInfo {
            DropInfo::new()
        }

        fn clear(&mut self) {
            self.account_mvp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DropInfo {
            static instance: DropInfo = DropInfo {
                account_mvp: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for DropInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for DropInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for DropInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingServerMatchEnd)
pub struct CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.stats)
    pub stats: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.confirm)
    pub confirm: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.rematch)
    pub rematch: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.replay_token)
    pub replay_token: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.replay_cluster_id)
    pub replay_cluster_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.aborted_match)
    pub aborted_match: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.match_end_quest_data)
    pub match_end_quest_data: ::protobuf::MessageField<CMsgGC_ServerQuestUpdateData>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.server_version)
    pub server_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
        <CMsgGCCStrike15_v2_MatchmakingServerMatchEnd as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
        ::std::default::Default::default()
    }

    // optional uint64 rematch = 4;

    pub fn rematch(&self) -> u64 {
        self.rematch.unwrap_or(0)
    }

    pub fn clear_rematch(&mut self) {
        self.rematch = ::std::option::Option::None;
    }

    pub fn has_rematch(&self) -> bool {
        self.rematch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rematch(&mut self, v: u64) {
        self.rematch = ::std::option::Option::Some(v);
    }

    // optional uint32 replay_token = 5;

    pub fn replay_token(&self) -> u32 {
        self.replay_token.unwrap_or(0)
    }

    pub fn clear_replay_token(&mut self) {
        self.replay_token = ::std::option::Option::None;
    }

    pub fn has_replay_token(&self) -> bool {
        self.replay_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_token(&mut self, v: u32) {
        self.replay_token = ::std::option::Option::Some(v);
    }

    // optional uint32 replay_cluster_id = 6;

    pub fn replay_cluster_id(&self) -> u32 {
        self.replay_cluster_id.unwrap_or(0)
    }

    pub fn clear_replay_cluster_id(&mut self) {
        self.replay_cluster_id = ::std::option::Option::None;
    }

    pub fn has_replay_cluster_id(&self) -> bool {
        self.replay_cluster_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_cluster_id(&mut self, v: u32) {
        self.replay_cluster_id = ::std::option::Option::Some(v);
    }

    // optional bool aborted_match = 7;

    pub fn aborted_match(&self) -> bool {
        self.aborted_match.unwrap_or(false)
    }

    pub fn clear_aborted_match(&mut self) {
        self.aborted_match = ::std::option::Option::None;
    }

    pub fn has_aborted_match(&self) -> bool {
        self.aborted_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aborted_match(&mut self, v: bool) {
        self.aborted_match = ::std::option::Option::Some(v);
    }

    // optional uint32 server_version = 9;

    pub fn server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingServerRoundStats>(
            "stats",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &m.stats },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &mut m.stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm>(
            "confirm",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &m.confirm },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &mut m.confirm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rematch",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &m.rematch },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &mut m.rematch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_token",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &m.replay_token },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &mut m.replay_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "replay_cluster_id",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &m.replay_cluster_id },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &mut m.replay_cluster_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "aborted_match",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &m.aborted_match },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &mut m.aborted_match },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGC_ServerQuestUpdateData>(
            "match_end_quest_data",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &m.match_end_quest_data },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &mut m.match_end_quest_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_version",
            |m: &CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &m.server_version },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServerMatchEnd| { &mut m.server_version },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingServerMatchEnd>(
            "CMsgGCCStrike15_v2_MatchmakingServerMatchEnd",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingServerMatchEnd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.stats)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.confirm)?;
                },
                32 => {
                    self.rematch = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.replay_token = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.replay_cluster_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.aborted_match = ::std::option::Option::Some(is.read_bool()?);
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.match_end_quest_data)?;
                },
                72 => {
                    self.server_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.confirm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.rematch {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.replay_token {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.replay_cluster_id {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.aborted_match {
            my_size += 1 + 1;
        }
        if let Some(v) = self.match_end_quest_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.server_version {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.confirm.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.rematch {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.replay_token {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.replay_cluster_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.aborted_match {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.match_end_quest_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
        CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.confirm.clear();
        self.rematch = ::std::option::Option::None;
        self.replay_token = ::std::option::Option::None;
        self.replay_cluster_id = ::std::option::Option::None;
        self.aborted_match = ::std::option::Option::None;
        self.match_end_quest_data.clear();
        self.server_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
        static instance: CMsgGCCStrike15_v2_MatchmakingServerMatchEnd = CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
            stats: ::protobuf::MessageField::none(),
            confirm: ::protobuf::MessageField::none(),
            rematch: ::std::option::Option::None,
            replay_token: ::std::option::Option::None,
            replay_cluster_id: ::std::option::Option::None,
            aborted_match: ::std::option::Option::None,
            match_end_quest_data: ::protobuf::MessageField::none(),
            server_version: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingServerMatchEnd").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingServerMatchEnd {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingClient2GCHello)
pub struct CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingClient2GCHello.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
        <CMsgGCCStrike15_v2_MatchmakingClient2GCHello as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingClient2GCHello>(
            "CMsgGCCStrike15_v2_MatchmakingClient2GCHello",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingClient2GCHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
        CMsgGCCStrike15_v2_MatchmakingClient2GCHello::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
        static instance: CMsgGCCStrike15_v2_MatchmakingClient2GCHello = CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingClient2GCHello").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingClient2GCHello {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello)
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.ongoingmatch)
    pub ongoingmatch: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.global_stats)
    pub global_stats: ::protobuf::MessageField<GlobalStatistics>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.penalty_seconds)
    pub penalty_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.penalty_reason)
    pub penalty_reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.vac_banned)
    pub vac_banned: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.ranking)
    pub ranking: ::protobuf::MessageField<PlayerRankingInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.commendation)
    pub commendation: ::protobuf::MessageField<PlayerCommendationInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.medals)
    pub medals: ::protobuf::MessageField<PlayerMedalsInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.my_current_event)
    pub my_current_event: ::protobuf::MessageField<TournamentEvent>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.my_current_event_teams)
    pub my_current_event_teams: ::std::vec::Vec<TournamentTeam>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.my_current_team)
    pub my_current_team: ::protobuf::MessageField<TournamentTeam>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.my_current_event_stages)
    pub my_current_event_stages: ::std::vec::Vec<TournamentEvent>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.survey_vote)
    pub survey_vote: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.activity)
    pub activity: ::protobuf::MessageField<AccountActivity>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.player_level)
    pub player_level: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.player_cur_xp)
    pub player_cur_xp: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.player_xp_bonus_flags)
    pub player_xp_bonus_flags: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
        <CMsgGCCStrike15_v2_MatchmakingGC2ClientHello as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_seconds = 4;

    pub fn penalty_seconds(&self) -> u32 {
        self.penalty_seconds.unwrap_or(0)
    }

    pub fn clear_penalty_seconds(&mut self) {
        self.penalty_seconds = ::std::option::Option::None;
    }

    pub fn has_penalty_seconds(&self) -> bool {
        self.penalty_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_seconds(&mut self, v: u32) {
        self.penalty_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_reason = 5;

    pub fn penalty_reason(&self) -> u32 {
        self.penalty_reason.unwrap_or(0)
    }

    pub fn clear_penalty_reason(&mut self) {
        self.penalty_reason = ::std::option::Option::None;
    }

    pub fn has_penalty_reason(&self) -> bool {
        self.penalty_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_reason(&mut self, v: u32) {
        self.penalty_reason = ::std::option::Option::Some(v);
    }

    // optional int32 vac_banned = 6;

    pub fn vac_banned(&self) -> i32 {
        self.vac_banned.unwrap_or(0)
    }

    pub fn clear_vac_banned(&mut self) {
        self.vac_banned = ::std::option::Option::None;
    }

    pub fn has_vac_banned(&self) -> bool {
        self.vac_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vac_banned(&mut self, v: i32) {
        self.vac_banned = ::std::option::Option::Some(v);
    }

    // optional uint32 survey_vote = 14;

    pub fn survey_vote(&self) -> u32 {
        self.survey_vote.unwrap_or(0)
    }

    pub fn clear_survey_vote(&mut self) {
        self.survey_vote = ::std::option::Option::None;
    }

    pub fn has_survey_vote(&self) -> bool {
        self.survey_vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_vote(&mut self, v: u32) {
        self.survey_vote = ::std::option::Option::Some(v);
    }

    // optional int32 player_level = 17;

    pub fn player_level(&self) -> i32 {
        self.player_level.unwrap_or(0)
    }

    pub fn clear_player_level(&mut self) {
        self.player_level = ::std::option::Option::None;
    }

    pub fn has_player_level(&self) -> bool {
        self.player_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_level(&mut self, v: i32) {
        self.player_level = ::std::option::Option::Some(v);
    }

    // optional int32 player_cur_xp = 18;

    pub fn player_cur_xp(&self) -> i32 {
        self.player_cur_xp.unwrap_or(0)
    }

    pub fn clear_player_cur_xp(&mut self) {
        self.player_cur_xp = ::std::option::Option::None;
    }

    pub fn has_player_cur_xp(&self) -> bool {
        self.player_cur_xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_cur_xp(&mut self, v: i32) {
        self.player_cur_xp = ::std::option::Option::Some(v);
    }

    // optional int32 player_xp_bonus_flags = 19;

    pub fn player_xp_bonus_flags(&self) -> i32 {
        self.player_xp_bonus_flags.unwrap_or(0)
    }

    pub fn clear_player_xp_bonus_flags(&mut self) {
        self.player_xp_bonus_flags = ::std::option::Option::None;
    }

    pub fn has_player_xp_bonus_flags(&self) -> bool {
        self.player_xp_bonus_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_xp_bonus_flags(&mut self, v: i32) {
        self.player_xp_bonus_flags = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(18);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>(
            "ongoingmatch",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.ongoingmatch },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.ongoingmatch },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, GlobalStatistics>(
            "global_stats",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.global_stats },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.global_stats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "penalty_seconds",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.penalty_seconds },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.penalty_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "penalty_reason",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.penalty_reason },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.penalty_reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vac_banned",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.vac_banned },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.vac_banned },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PlayerRankingInfo>(
            "ranking",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.ranking },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.ranking },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PlayerCommendationInfo>(
            "commendation",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.commendation },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.commendation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PlayerMedalsInfo>(
            "medals",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.medals },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.medals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TournamentEvent>(
            "my_current_event",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.my_current_event },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.my_current_event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "my_current_event_teams",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.my_current_event_teams },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.my_current_event_teams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TournamentTeam>(
            "my_current_team",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.my_current_team },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.my_current_team },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "my_current_event_stages",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.my_current_event_stages },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.my_current_event_stages },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "survey_vote",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.survey_vote },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.survey_vote },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AccountActivity>(
            "activity",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.activity },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.activity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_level",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.player_level },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.player_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_cur_xp",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.player_cur_xp },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.player_cur_xp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_xp_bonus_flags",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &m.player_xp_bonus_flags },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientHello| { &mut m.player_xp_bonus_flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello>(
            "CMsgGCCStrike15_v2_MatchmakingGC2ClientHello",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingGC2ClientHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ongoingmatch)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.global_stats)?;
                },
                32 => {
                    self.penalty_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.penalty_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.vac_banned = ::std::option::Option::Some(is.read_int32()?);
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.ranking)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.commendation)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.medals)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.my_current_event)?;
                },
                90 => {
                    self.my_current_event_teams.push(is.read_message()?);
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.my_current_team)?;
                },
                106 => {
                    self.my_current_event_stages.push(is.read_message()?);
                },
                112 => {
                    self.survey_vote = ::std::option::Option::Some(is.read_uint32()?);
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.activity)?;
                },
                136 => {
                    self.player_level = ::std::option::Option::Some(is.read_int32()?);
                },
                144 => {
                    self.player_cur_xp = ::std::option::Option::Some(is.read_int32()?);
                },
                152 => {
                    self.player_xp_bonus_flags = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.ongoingmatch.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.global_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.penalty_seconds {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.penalty_reason {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.vac_banned {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.ranking.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.commendation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.medals.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.my_current_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.my_current_event_teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.my_current_team.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.my_current_event_stages {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.survey_vote {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.activity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.player_level {
            my_size += ::protobuf::rt::int32_size(17, v);
        }
        if let Some(v) = self.player_cur_xp {
            my_size += ::protobuf::rt::int32_size(18, v);
        }
        if let Some(v) = self.player_xp_bonus_flags {
            my_size += ::protobuf::rt::int32_size(19, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ongoingmatch.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.global_stats.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.penalty_seconds {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.penalty_reason {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.vac_banned {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.ranking.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.commendation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.medals.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.my_current_event.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        for v in &self.my_current_event_teams {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        };
        if let Some(v) = self.my_current_team.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        for v in &self.my_current_event_stages {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        if let Some(v) = self.survey_vote {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.activity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.player_level {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.player_cur_xp {
            os.write_int32(18, v)?;
        }
        if let Some(v) = self.player_xp_bonus_flags {
            os.write_int32(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.ongoingmatch.clear();
        self.global_stats.clear();
        self.penalty_seconds = ::std::option::Option::None;
        self.penalty_reason = ::std::option::Option::None;
        self.vac_banned = ::std::option::Option::None;
        self.ranking.clear();
        self.commendation.clear();
        self.medals.clear();
        self.my_current_event.clear();
        self.my_current_event_teams.clear();
        self.my_current_team.clear();
        self.my_current_event_stages.clear();
        self.survey_vote = ::std::option::Option::None;
        self.activity.clear();
        self.player_level = ::std::option::Option::None;
        self.player_cur_xp = ::std::option::Option::None;
        self.player_xp_bonus_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
        static instance: CMsgGCCStrike15_v2_MatchmakingGC2ClientHello = CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
            account_id: ::std::option::Option::None,
            ongoingmatch: ::protobuf::MessageField::none(),
            global_stats: ::protobuf::MessageField::none(),
            penalty_seconds: ::std::option::Option::None,
            penalty_reason: ::std::option::Option::None,
            vac_banned: ::std::option::Option::None,
            ranking: ::protobuf::MessageField::none(),
            commendation: ::protobuf::MessageField::none(),
            medals: ::protobuf::MessageField::none(),
            my_current_event: ::protobuf::MessageField::none(),
            my_current_event_teams: ::std::vec::Vec::new(),
            my_current_team: ::protobuf::MessageField::none(),
            my_current_event_stages: ::std::vec::Vec::new(),
            survey_vote: ::std::option::Option::None,
            activity: ::protobuf::MessageField::none(),
            player_level: ::std::option::Option::None,
            player_cur_xp: ::std::option::Option::None,
            player_xp_bonus_flags: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingGC2ClientHello").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientHello {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_AccountPrivacySettings)
pub struct CMsgGCCStrike15_v2_AccountPrivacySettings {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_AccountPrivacySettings.settings)
    pub settings: ::std::vec::Vec<cmsg_gccstrike15_v2_account_privacy_settings::Setting>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_AccountPrivacySettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_AccountPrivacySettings {
    fn default() -> &'a CMsgGCCStrike15_v2_AccountPrivacySettings {
        <CMsgGCCStrike15_v2_AccountPrivacySettings as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_AccountPrivacySettings {
    pub fn new() -> CMsgGCCStrike15_v2_AccountPrivacySettings {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "settings",
            |m: &CMsgGCCStrike15_v2_AccountPrivacySettings| { &m.settings },
            |m: &mut CMsgGCCStrike15_v2_AccountPrivacySettings| { &mut m.settings },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_AccountPrivacySettings>(
            "CMsgGCCStrike15_v2_AccountPrivacySettings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_AccountPrivacySettings {
    const NAME: &'static str = "CMsgGCCStrike15_v2_AccountPrivacySettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.settings.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.settings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.settings {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_AccountPrivacySettings {
        CMsgGCCStrike15_v2_AccountPrivacySettings::new()
    }

    fn clear(&mut self) {
        self.settings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_AccountPrivacySettings {
        static instance: CMsgGCCStrike15_v2_AccountPrivacySettings = CMsgGCCStrike15_v2_AccountPrivacySettings {
            settings: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_AccountPrivacySettings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_AccountPrivacySettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_AccountPrivacySettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_AccountPrivacySettings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCCStrike15_v2_AccountPrivacySettings`
pub mod cmsg_gccstrike15_v2_account_privacy_settings {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgGCCStrike15_v2_AccountPrivacySettings.Setting)
    pub struct Setting {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_AccountPrivacySettings.Setting.setting_type)
        pub setting_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_AccountPrivacySettings.Setting.setting_value)
        pub setting_value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_AccountPrivacySettings.Setting.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Setting {
        fn default() -> &'a Setting {
            <Setting as ::protobuf::Message>::default_instance()
        }
    }

    impl Setting {
        pub fn new() -> Setting {
            ::std::default::Default::default()
        }

        // optional uint32 setting_type = 1;

        pub fn setting_type(&self) -> u32 {
            self.setting_type.unwrap_or(0)
        }

        pub fn clear_setting_type(&mut self) {
            self.setting_type = ::std::option::Option::None;
        }

        pub fn has_setting_type(&self) -> bool {
            self.setting_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_setting_type(&mut self, v: u32) {
            self.setting_type = ::std::option::Option::Some(v);
        }

        // optional uint32 setting_value = 2;

        pub fn setting_value(&self) -> u32 {
            self.setting_value.unwrap_or(0)
        }

        pub fn clear_setting_value(&mut self) {
            self.setting_value = ::std::option::Option::None;
        }

        pub fn has_setting_value(&self) -> bool {
            self.setting_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_setting_value(&mut self, v: u32) {
            self.setting_value = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "setting_type",
                |m: &Setting| { &m.setting_type },
                |m: &mut Setting| { &mut m.setting_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "setting_value",
                |m: &Setting| { &m.setting_value },
                |m: &mut Setting| { &mut m.setting_value },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Setting>(
                "CMsgGCCStrike15_v2_AccountPrivacySettings.Setting",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Setting {
        const NAME: &'static str = "Setting";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.setting_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.setting_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.setting_type {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.setting_value {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.setting_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.setting_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Setting {
            Setting::new()
        }

        fn clear(&mut self) {
            self.setting_type = ::std::option::Option::None;
            self.setting_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Setting {
            static instance: Setting = Setting {
                setting_type: ::std::option::Option::None,
                setting_value: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Setting {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_AccountPrivacySettings.Setting").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Setting {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Setting {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon)
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.abandoned_match)
    pub abandoned_match: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.penalty_seconds)
    pub penalty_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.penalty_reason)
    pub penalty_reason: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
        <CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_seconds = 3;

    pub fn penalty_seconds(&self) -> u32 {
        self.penalty_seconds.unwrap_or(0)
    }

    pub fn clear_penalty_seconds(&mut self) {
        self.penalty_seconds = ::std::option::Option::None;
    }

    pub fn has_penalty_seconds(&self) -> bool {
        self.penalty_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_seconds(&mut self, v: u32) {
        self.penalty_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_reason = 4;

    pub fn penalty_reason(&self) -> u32 {
        self.penalty_reason.unwrap_or(0)
    }

    pub fn clear_penalty_reason(&mut self) {
        self.penalty_reason = ::std::option::Option::None;
    }

    pub fn has_penalty_reason(&self) -> bool {
        self.penalty_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_reason(&mut self, v: u32) {
        self.penalty_reason = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>(
            "abandoned_match",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &m.abandoned_match },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &mut m.abandoned_match },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "penalty_seconds",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &m.penalty_seconds },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &mut m.penalty_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "penalty_reason",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &m.penalty_reason },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon| { &mut m.penalty_reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon>(
            "CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.abandoned_match)?;
                },
                24 => {
                    self.penalty_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.penalty_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.abandoned_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.penalty_seconds {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.penalty_reason {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.abandoned_match.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.penalty_seconds {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.penalty_reason {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
        CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.abandoned_match.clear();
        self.penalty_seconds = ::std::option::Option::None;
        self.penalty_reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
        static instance: CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
            account_id: ::std::option::Option::None,
            abandoned_match: ::protobuf::MessageField::none(),
            penalty_seconds: ::std::option::Option::None,
            penalty_reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingServer2GCKick)
pub struct CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServer2GCKick.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServer2GCKick.reservation)
    pub reservation: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingServer2GCKick.reason)
    pub reason: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingServer2GCKick.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
        <CMsgGCCStrike15_v2_MatchmakingServer2GCKick as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 reason = 3;

    pub fn reason(&self) -> u32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: u32) {
        self.reason = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_MatchmakingServer2GCKick| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServer2GCKick| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>(
            "reservation",
            |m: &CMsgGCCStrike15_v2_MatchmakingServer2GCKick| { &m.reservation },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServer2GCKick| { &mut m.reservation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CMsgGCCStrike15_v2_MatchmakingServer2GCKick| { &m.reason },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingServer2GCKick| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingServer2GCKick>(
            "CMsgGCCStrike15_v2_MatchmakingServer2GCKick",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingServer2GCKick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reservation)?;
                },
                24 => {
                    self.reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reservation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.reason {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
        CMsgGCCStrike15_v2_MatchmakingServer2GCKick::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.reservation.clear();
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
        static instance: CMsgGCCStrike15_v2_MatchmakingServer2GCKick = CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
            account_id: ::std::option::Option::None,
            reservation: ::protobuf::MessageField::none(),
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingServer2GCKick").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingServer2GCKick {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate)
pub struct CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.rankings)
    pub rankings: ::std::vec::Vec<PlayerRankingInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
        <CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "rankings",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate| { &m.rankings },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate| { &mut m.rankings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate| { &m.match_id },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate| { &mut m.match_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate>(
            "CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rankings.push(is.read_message()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rankings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.rankings {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
        CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate::new()
    }

    fn clear(&mut self) {
        self.rankings.clear();
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
        static instance: CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate = CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
            rankings: ::std::vec::Vec::new(),
            match_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate)
pub struct CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.main_post_url)
    pub main_post_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
        <CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
        ::std::default::Default::default()
    }

    // optional string main_post_url = 1;

    pub fn main_post_url(&self) -> &str {
        match self.main_post_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_main_post_url(&mut self) {
        self.main_post_url = ::std::option::Option::None;
    }

    pub fn has_main_post_url(&self) -> bool {
        self.main_post_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_main_post_url(&mut self, v: ::std::string::String) {
        self.main_post_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_post_url(&mut self) -> &mut ::std::string::String {
        if self.main_post_url.is_none() {
            self.main_post_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.main_post_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_main_post_url(&mut self) -> ::std::string::String {
        self.main_post_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "main_post_url",
            |m: &CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate| { &m.main_post_url },
            |m: &mut CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate| { &mut m.main_post_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate>(
            "CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.main_post_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.main_post_url.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.main_post_url.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
        CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate::new()
    }

    fn clear(&mut self) {
        self.main_post_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
        static instance: CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
            main_post_url: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ServerNotificationForUserPenalty)
pub struct CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.reason)
    pub reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.seconds)
    pub seconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    fn default() -> &'a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
        <CMsgGCCStrike15_v2_ServerNotificationForUserPenalty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    pub fn new() -> CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 reason = 2;

    pub fn reason(&self) -> u32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: u32) {
        self.reason = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds = 3;

    pub fn seconds(&self) -> u32 {
        self.seconds.unwrap_or(0)
    }

    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: u32) {
        self.seconds = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &m.reason },
            |m: &mut CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &mut m.reason },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "seconds",
            |m: &CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &m.seconds },
            |m: &mut CMsgGCCStrike15_v2_ServerNotificationForUserPenalty| { &mut m.seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ServerNotificationForUserPenalty>(
            "CMsgGCCStrike15_v2_ServerNotificationForUserPenalty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ServerNotificationForUserPenalty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reason {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.seconds {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
        CMsgGCCStrike15_v2_ServerNotificationForUserPenalty::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
        static instance: CMsgGCCStrike15_v2_ServerNotificationForUserPenalty = CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
            account_id: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            seconds: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ServerNotificationForUserPenalty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ServerNotificationForUserPenalty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientReportPlayer)
pub struct CMsgGCCStrike15_v2_ClientReportPlayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportPlayer.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportPlayer.rpt_aimbot)
    pub rpt_aimbot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportPlayer.rpt_wallhack)
    pub rpt_wallhack: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportPlayer.rpt_speedhack)
    pub rpt_speedhack: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportPlayer.rpt_teamharm)
    pub rpt_teamharm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportPlayer.rpt_textabuse)
    pub rpt_textabuse: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportPlayer.rpt_voiceabuse)
    pub rpt_voiceabuse: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportPlayer.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientReportPlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientReportPlayer {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientReportPlayer {
        <CMsgGCCStrike15_v2_ClientReportPlayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientReportPlayer {
    pub fn new() -> CMsgGCCStrike15_v2_ClientReportPlayer {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_aimbot = 2;

    pub fn rpt_aimbot(&self) -> u32 {
        self.rpt_aimbot.unwrap_or(0)
    }

    pub fn clear_rpt_aimbot(&mut self) {
        self.rpt_aimbot = ::std::option::Option::None;
    }

    pub fn has_rpt_aimbot(&self) -> bool {
        self.rpt_aimbot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_aimbot(&mut self, v: u32) {
        self.rpt_aimbot = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_wallhack = 3;

    pub fn rpt_wallhack(&self) -> u32 {
        self.rpt_wallhack.unwrap_or(0)
    }

    pub fn clear_rpt_wallhack(&mut self) {
        self.rpt_wallhack = ::std::option::Option::None;
    }

    pub fn has_rpt_wallhack(&self) -> bool {
        self.rpt_wallhack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_wallhack(&mut self, v: u32) {
        self.rpt_wallhack = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_speedhack = 4;

    pub fn rpt_speedhack(&self) -> u32 {
        self.rpt_speedhack.unwrap_or(0)
    }

    pub fn clear_rpt_speedhack(&mut self) {
        self.rpt_speedhack = ::std::option::Option::None;
    }

    pub fn has_rpt_speedhack(&self) -> bool {
        self.rpt_speedhack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_speedhack(&mut self, v: u32) {
        self.rpt_speedhack = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_teamharm = 5;

    pub fn rpt_teamharm(&self) -> u32 {
        self.rpt_teamharm.unwrap_or(0)
    }

    pub fn clear_rpt_teamharm(&mut self) {
        self.rpt_teamharm = ::std::option::Option::None;
    }

    pub fn has_rpt_teamharm(&self) -> bool {
        self.rpt_teamharm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_teamharm(&mut self, v: u32) {
        self.rpt_teamharm = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_textabuse = 6;

    pub fn rpt_textabuse(&self) -> u32 {
        self.rpt_textabuse.unwrap_or(0)
    }

    pub fn clear_rpt_textabuse(&mut self) {
        self.rpt_textabuse = ::std::option::Option::None;
    }

    pub fn has_rpt_textabuse(&self) -> bool {
        self.rpt_textabuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_textabuse(&mut self, v: u32) {
        self.rpt_textabuse = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_voiceabuse = 7;

    pub fn rpt_voiceabuse(&self) -> u32 {
        self.rpt_voiceabuse.unwrap_or(0)
    }

    pub fn clear_rpt_voiceabuse(&mut self) {
        self.rpt_voiceabuse = ::std::option::Option::None;
    }

    pub fn has_rpt_voiceabuse(&self) -> bool {
        self.rpt_voiceabuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_voiceabuse(&mut self, v: u32) {
        self.rpt_voiceabuse = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 8;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_aimbot",
            |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_aimbot },
            |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_aimbot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_wallhack",
            |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_wallhack },
            |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_wallhack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_speedhack",
            |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_speedhack },
            |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_speedhack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_teamharm",
            |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_teamharm },
            |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_teamharm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_textabuse",
            |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_textabuse },
            |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_textabuse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_voiceabuse",
            |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.rpt_voiceabuse },
            |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.rpt_voiceabuse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGCCStrike15_v2_ClientReportPlayer| { &m.match_id },
            |m: &mut CMsgGCCStrike15_v2_ClientReportPlayer| { &mut m.match_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientReportPlayer>(
            "CMsgGCCStrike15_v2_ClientReportPlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientReportPlayer {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientReportPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rpt_aimbot = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.rpt_wallhack = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.rpt_speedhack = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rpt_teamharm = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.rpt_textabuse = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.rpt_voiceabuse = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rpt_aimbot {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.rpt_wallhack {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.rpt_speedhack {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rpt_teamharm {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.rpt_textabuse {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.rpt_voiceabuse {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rpt_aimbot {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rpt_wallhack {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rpt_speedhack {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rpt_teamharm {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.rpt_textabuse {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.rpt_voiceabuse {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientReportPlayer {
        CMsgGCCStrike15_v2_ClientReportPlayer::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.rpt_aimbot = ::std::option::Option::None;
        self.rpt_wallhack = ::std::option::Option::None;
        self.rpt_speedhack = ::std::option::Option::None;
        self.rpt_teamharm = ::std::option::Option::None;
        self.rpt_textabuse = ::std::option::Option::None;
        self.rpt_voiceabuse = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientReportPlayer {
        static instance: CMsgGCCStrike15_v2_ClientReportPlayer = CMsgGCCStrike15_v2_ClientReportPlayer {
            account_id: ::std::option::Option::None,
            rpt_aimbot: ::std::option::Option::None,
            rpt_wallhack: ::std::option::Option::None,
            rpt_speedhack: ::std::option::Option::None,
            rpt_teamharm: ::std::option::Option::None,
            rpt_textabuse: ::std::option::Option::None,
            rpt_voiceabuse: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientReportPlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientReportPlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientReportPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientReportPlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientCommendPlayer)
pub struct CMsgGCCStrike15_v2_ClientCommendPlayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientCommendPlayer.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientCommendPlayer.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientCommendPlayer.commendation)
    pub commendation: ::protobuf::MessageField<PlayerCommendationInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientCommendPlayer.tokens)
    pub tokens: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientCommendPlayer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientCommendPlayer {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientCommendPlayer {
        <CMsgGCCStrike15_v2_ClientCommendPlayer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientCommendPlayer {
    pub fn new() -> CMsgGCCStrike15_v2_ClientCommendPlayer {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 8;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 tokens = 10;

    pub fn tokens(&self) -> u32 {
        self.tokens.unwrap_or(0)
    }

    pub fn clear_tokens(&mut self) {
        self.tokens = ::std::option::Option::None;
    }

    pub fn has_tokens(&self) -> bool {
        self.tokens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: u32) {
        self.tokens = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_ClientCommendPlayer| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_ClientCommendPlayer| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGCCStrike15_v2_ClientCommendPlayer| { &m.match_id },
            |m: &mut CMsgGCCStrike15_v2_ClientCommendPlayer| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PlayerCommendationInfo>(
            "commendation",
            |m: &CMsgGCCStrike15_v2_ClientCommendPlayer| { &m.commendation },
            |m: &mut CMsgGCCStrike15_v2_ClientCommendPlayer| { &mut m.commendation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tokens",
            |m: &CMsgGCCStrike15_v2_ClientCommendPlayer| { &m.tokens },
            |m: &mut CMsgGCCStrike15_v2_ClientCommendPlayer| { &mut m.tokens },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientCommendPlayer>(
            "CMsgGCCStrike15_v2_ClientCommendPlayer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientCommendPlayer {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientCommendPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.commendation)?;
                },
                80 => {
                    self.tokens = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        if let Some(v) = self.commendation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tokens {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(8, v)?;
        }
        if let Some(v) = self.commendation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.tokens {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientCommendPlayer {
        CMsgGCCStrike15_v2_ClientCommendPlayer::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.commendation.clear();
        self.tokens = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientCommendPlayer {
        static instance: CMsgGCCStrike15_v2_ClientCommendPlayer = CMsgGCCStrike15_v2_ClientCommendPlayer {
            account_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            commendation: ::protobuf::MessageField::none(),
            tokens: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientCommendPlayer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientCommendPlayer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientCommendPlayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientCommendPlayer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientReportServer)
pub struct CMsgGCCStrike15_v2_ClientReportServer {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportServer.rpt_poorperf)
    pub rpt_poorperf: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportServer.rpt_abusivemodels)
    pub rpt_abusivemodels: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportServer.rpt_badmotd)
    pub rpt_badmotd: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportServer.rpt_listingabuse)
    pub rpt_listingabuse: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportServer.rpt_inventoryabuse)
    pub rpt_inventoryabuse: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportServer.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientReportServer.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientReportServer {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientReportServer {
        <CMsgGCCStrike15_v2_ClientReportServer as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientReportServer {
    pub fn new() -> CMsgGCCStrike15_v2_ClientReportServer {
        ::std::default::Default::default()
    }

    // optional uint32 rpt_poorperf = 1;

    pub fn rpt_poorperf(&self) -> u32 {
        self.rpt_poorperf.unwrap_or(0)
    }

    pub fn clear_rpt_poorperf(&mut self) {
        self.rpt_poorperf = ::std::option::Option::None;
    }

    pub fn has_rpt_poorperf(&self) -> bool {
        self.rpt_poorperf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_poorperf(&mut self, v: u32) {
        self.rpt_poorperf = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_abusivemodels = 2;

    pub fn rpt_abusivemodels(&self) -> u32 {
        self.rpt_abusivemodels.unwrap_or(0)
    }

    pub fn clear_rpt_abusivemodels(&mut self) {
        self.rpt_abusivemodels = ::std::option::Option::None;
    }

    pub fn has_rpt_abusivemodels(&self) -> bool {
        self.rpt_abusivemodels.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_abusivemodels(&mut self, v: u32) {
        self.rpt_abusivemodels = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_badmotd = 3;

    pub fn rpt_badmotd(&self) -> u32 {
        self.rpt_badmotd.unwrap_or(0)
    }

    pub fn clear_rpt_badmotd(&mut self) {
        self.rpt_badmotd = ::std::option::Option::None;
    }

    pub fn has_rpt_badmotd(&self) -> bool {
        self.rpt_badmotd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_badmotd(&mut self, v: u32) {
        self.rpt_badmotd = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_listingabuse = 4;

    pub fn rpt_listingabuse(&self) -> u32 {
        self.rpt_listingabuse.unwrap_or(0)
    }

    pub fn clear_rpt_listingabuse(&mut self) {
        self.rpt_listingabuse = ::std::option::Option::None;
    }

    pub fn has_rpt_listingabuse(&self) -> bool {
        self.rpt_listingabuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_listingabuse(&mut self, v: u32) {
        self.rpt_listingabuse = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_inventoryabuse = 5;

    pub fn rpt_inventoryabuse(&self) -> u32 {
        self.rpt_inventoryabuse.unwrap_or(0)
    }

    pub fn clear_rpt_inventoryabuse(&mut self) {
        self.rpt_inventoryabuse = ::std::option::Option::None;
    }

    pub fn has_rpt_inventoryabuse(&self) -> bool {
        self.rpt_inventoryabuse.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_inventoryabuse(&mut self, v: u32) {
        self.rpt_inventoryabuse = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 8;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_poorperf",
            |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.rpt_poorperf },
            |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.rpt_poorperf },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_abusivemodels",
            |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.rpt_abusivemodels },
            |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.rpt_abusivemodels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_badmotd",
            |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.rpt_badmotd },
            |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.rpt_badmotd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_listingabuse",
            |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.rpt_listingabuse },
            |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.rpt_listingabuse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_inventoryabuse",
            |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.rpt_inventoryabuse },
            |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.rpt_inventoryabuse },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGCCStrike15_v2_ClientReportServer| { &m.match_id },
            |m: &mut CMsgGCCStrike15_v2_ClientReportServer| { &mut m.match_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientReportServer>(
            "CMsgGCCStrike15_v2_ClientReportServer",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientReportServer {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientReportServer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rpt_poorperf = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rpt_abusivemodels = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.rpt_badmotd = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.rpt_listingabuse = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rpt_inventoryabuse = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rpt_poorperf {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rpt_abusivemodels {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.rpt_badmotd {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.rpt_listingabuse {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rpt_inventoryabuse {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.rpt_poorperf {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rpt_abusivemodels {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rpt_badmotd {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rpt_listingabuse {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rpt_inventoryabuse {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientReportServer {
        CMsgGCCStrike15_v2_ClientReportServer::new()
    }

    fn clear(&mut self) {
        self.rpt_poorperf = ::std::option::Option::None;
        self.rpt_abusivemodels = ::std::option::Option::None;
        self.rpt_badmotd = ::std::option::Option::None;
        self.rpt_listingabuse = ::std::option::Option::None;
        self.rpt_inventoryabuse = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientReportServer {
        static instance: CMsgGCCStrike15_v2_ClientReportServer = CMsgGCCStrike15_v2_ClientReportServer {
            rpt_poorperf: ::std::option::Option::None,
            rpt_abusivemodels: ::std::option::Option::None,
            rpt_badmotd: ::std::option::Option::None,
            rpt_listingabuse: ::std::option::Option::None,
            rpt_inventoryabuse: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientReportServer {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientReportServer").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientReportServer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientReportServer {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientReportResponse)
pub struct CMsgGCCStrike15_v2_ClientReportResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportResponse.confirmation_id)
    pub confirmation_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportResponse.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportResponse.server_ip)
    pub server_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportResponse.response_type)
    pub response_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportResponse.response_result)
    pub response_result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientReportResponse.tokens)
    pub tokens: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientReportResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientReportResponse {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientReportResponse {
        <CMsgGCCStrike15_v2_ClientReportResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientReportResponse {
    pub fn new() -> CMsgGCCStrike15_v2_ClientReportResponse {
        ::std::default::Default::default()
    }

    // optional uint64 confirmation_id = 1;

    pub fn confirmation_id(&self) -> u64 {
        self.confirmation_id.unwrap_or(0)
    }

    pub fn clear_confirmation_id(&mut self) {
        self.confirmation_id = ::std::option::Option::None;
    }

    pub fn has_confirmation_id(&self) -> bool {
        self.confirmation_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_confirmation_id(&mut self, v: u64) {
        self.confirmation_id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 server_ip = 3;

    pub fn server_ip(&self) -> u32 {
        self.server_ip.unwrap_or(0)
    }

    pub fn clear_server_ip(&mut self) {
        self.server_ip = ::std::option::Option::None;
    }

    pub fn has_server_ip(&self) -> bool {
        self.server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip(&mut self, v: u32) {
        self.server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 response_type = 4;

    pub fn response_type(&self) -> u32 {
        self.response_type.unwrap_or(0)
    }

    pub fn clear_response_type(&mut self) {
        self.response_type = ::std::option::Option::None;
    }

    pub fn has_response_type(&self) -> bool {
        self.response_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_type(&mut self, v: u32) {
        self.response_type = ::std::option::Option::Some(v);
    }

    // optional uint32 response_result = 5;

    pub fn response_result(&self) -> u32 {
        self.response_result.unwrap_or(0)
    }

    pub fn clear_response_result(&mut self) {
        self.response_result = ::std::option::Option::None;
    }

    pub fn has_response_result(&self) -> bool {
        self.response_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_result(&mut self, v: u32) {
        self.response_result = ::std::option::Option::Some(v);
    }

    // optional uint32 tokens = 6;

    pub fn tokens(&self) -> u32 {
        self.tokens.unwrap_or(0)
    }

    pub fn clear_tokens(&mut self) {
        self.tokens = ::std::option::Option::None;
    }

    pub fn has_tokens(&self) -> bool {
        self.tokens.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tokens(&mut self, v: u32) {
        self.tokens = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "confirmation_id",
            |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.confirmation_id },
            |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.confirmation_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_ip",
            |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.server_ip },
            |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.server_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response_type",
            |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.response_type },
            |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.response_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "response_result",
            |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.response_result },
            |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.response_result },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tokens",
            |m: &CMsgGCCStrike15_v2_ClientReportResponse| { &m.tokens },
            |m: &mut CMsgGCCStrike15_v2_ClientReportResponse| { &mut m.tokens },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientReportResponse>(
            "CMsgGCCStrike15_v2_ClientReportResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientReportResponse {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientReportResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.confirmation_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.server_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.response_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.response_result = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.tokens = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.confirmation_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.server_ip {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.response_type {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.response_result {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.tokens {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.confirmation_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.server_ip {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.response_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.response_result {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.tokens {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientReportResponse {
        CMsgGCCStrike15_v2_ClientReportResponse::new()
    }

    fn clear(&mut self) {
        self.confirmation_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.server_ip = ::std::option::Option::None;
        self.response_type = ::std::option::Option::None;
        self.response_result = ::std::option::Option::None;
        self.tokens = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientReportResponse {
        static instance: CMsgGCCStrike15_v2_ClientReportResponse = CMsgGCCStrike15_v2_ClientReportResponse {
            confirmation_id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            server_ip: ::std::option::Option::None,
            response_type: ::std::option::Option::None,
            response_result: ::std::option::Option::None,
            tokens: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientReportResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientReportResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientReportResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientReportResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends)
pub struct CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.serverid)
    pub serverid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.matchid)
    pub matchid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
        <CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
        ::std::default::Default::default()
    }

    // optional uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 serverid = 3;

    pub fn serverid(&self) -> u64 {
        self.serverid.unwrap_or(0)
    }

    pub fn clear_serverid(&mut self) {
        self.serverid = ::std::option::Option::None;
    }

    pub fn has_serverid(&self) -> bool {
        self.serverid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverid(&mut self, v: u64) {
        self.serverid = ::std::option::Option::Some(v);
    }

    // optional uint64 matchid = 4;

    pub fn matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }

    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &m.request_id },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &mut m.request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids",
            |m: &CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &m.account_ids },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &mut m.account_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serverid",
            |m: &CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &m.serverid },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &mut m.serverid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchid",
            |m: &CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &m.matchid },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends| { &mut m.matchid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends>(
            "CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                16 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                24 => {
                    self.serverid = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.matchid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.account_ids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.serverid {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_ids {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.serverid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.matchid {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
        CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.account_ids.clear();
        self.serverid = ::std::option::Option::None;
        self.matchid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
        static instance: CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends = CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
            request_id: ::std::option::Option::None,
            account_ids: ::std::vec::Vec::new(),
            serverid: ::std::option::Option::None,
            matchid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:WatchableMatchInfo)
pub struct WatchableMatchInfo {
    // message fields
    // @@protoc_insertion_point(field:WatchableMatchInfo.server_ip)
    pub server_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.tv_port)
    pub tv_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.tv_spectators)
    pub tv_spectators: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.tv_time)
    pub tv_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.tv_watch_password)
    pub tv_watch_password: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.cl_decryptdata_key)
    pub cl_decryptdata_key: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.cl_decryptdata_key_pub)
    pub cl_decryptdata_key_pub: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.game_type)
    pub game_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.game_mapgroup)
    pub game_mapgroup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.game_map)
    pub game_map: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.server_id)
    pub server_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:WatchableMatchInfo.reservation_id)
    pub reservation_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:WatchableMatchInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a WatchableMatchInfo {
    fn default() -> &'a WatchableMatchInfo {
        <WatchableMatchInfo as ::protobuf::Message>::default_instance()
    }
}

impl WatchableMatchInfo {
    pub fn new() -> WatchableMatchInfo {
        ::std::default::Default::default()
    }

    // optional uint32 server_ip = 1;

    pub fn server_ip(&self) -> u32 {
        self.server_ip.unwrap_or(0)
    }

    pub fn clear_server_ip(&mut self) {
        self.server_ip = ::std::option::Option::None;
    }

    pub fn has_server_ip(&self) -> bool {
        self.server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip(&mut self, v: u32) {
        self.server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_port = 2;

    pub fn tv_port(&self) -> u32 {
        self.tv_port.unwrap_or(0)
    }

    pub fn clear_tv_port(&mut self) {
        self.tv_port = ::std::option::Option::None;
    }

    pub fn has_tv_port(&self) -> bool {
        self.tv_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_port(&mut self, v: u32) {
        self.tv_port = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_spectators = 3;

    pub fn tv_spectators(&self) -> u32 {
        self.tv_spectators.unwrap_or(0)
    }

    pub fn clear_tv_spectators(&mut self) {
        self.tv_spectators = ::std::option::Option::None;
    }

    pub fn has_tv_spectators(&self) -> bool {
        self.tv_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_spectators(&mut self, v: u32) {
        self.tv_spectators = ::std::option::Option::Some(v);
    }

    // optional uint32 tv_time = 4;

    pub fn tv_time(&self) -> u32 {
        self.tv_time.unwrap_or(0)
    }

    pub fn clear_tv_time(&mut self) {
        self.tv_time = ::std::option::Option::None;
    }

    pub fn has_tv_time(&self) -> bool {
        self.tv_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_time(&mut self, v: u32) {
        self.tv_time = ::std::option::Option::Some(v);
    }

    // optional bytes tv_watch_password = 5;

    pub fn tv_watch_password(&self) -> &[u8] {
        match self.tv_watch_password.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_tv_watch_password(&mut self) {
        self.tv_watch_password = ::std::option::Option::None;
    }

    pub fn has_tv_watch_password(&self) -> bool {
        self.tv_watch_password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_watch_password(&mut self, v: ::std::vec::Vec<u8>) {
        self.tv_watch_password = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tv_watch_password(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.tv_watch_password.is_none() {
            self.tv_watch_password = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.tv_watch_password.as_mut().unwrap()
    }

    // Take field
    pub fn take_tv_watch_password(&mut self) -> ::std::vec::Vec<u8> {
        self.tv_watch_password.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 cl_decryptdata_key = 6;

    pub fn cl_decryptdata_key(&self) -> u64 {
        self.cl_decryptdata_key.unwrap_or(0)
    }

    pub fn clear_cl_decryptdata_key(&mut self) {
        self.cl_decryptdata_key = ::std::option::Option::None;
    }

    pub fn has_cl_decryptdata_key(&self) -> bool {
        self.cl_decryptdata_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cl_decryptdata_key(&mut self, v: u64) {
        self.cl_decryptdata_key = ::std::option::Option::Some(v);
    }

    // optional uint64 cl_decryptdata_key_pub = 7;

    pub fn cl_decryptdata_key_pub(&self) -> u64 {
        self.cl_decryptdata_key_pub.unwrap_or(0)
    }

    pub fn clear_cl_decryptdata_key_pub(&mut self) {
        self.cl_decryptdata_key_pub = ::std::option::Option::None;
    }

    pub fn has_cl_decryptdata_key_pub(&self) -> bool {
        self.cl_decryptdata_key_pub.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cl_decryptdata_key_pub(&mut self, v: u64) {
        self.cl_decryptdata_key_pub = ::std::option::Option::Some(v);
    }

    // optional uint32 game_type = 8;

    pub fn game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional string game_mapgroup = 9;

    pub fn game_mapgroup(&self) -> &str {
        match self.game_mapgroup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_mapgroup(&mut self) {
        self.game_mapgroup = ::std::option::Option::None;
    }

    pub fn has_game_mapgroup(&self) -> bool {
        self.game_mapgroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mapgroup(&mut self, v: ::std::string::String) {
        self.game_mapgroup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_mapgroup(&mut self) -> &mut ::std::string::String {
        if self.game_mapgroup.is_none() {
            self.game_mapgroup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_mapgroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_mapgroup(&mut self) -> ::std::string::String {
        self.game_mapgroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string game_map = 10;

    pub fn game_map(&self) -> &str {
        match self.game_map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_map(&mut self) {
        self.game_map = ::std::option::Option::None;
    }

    pub fn has_game_map(&self) -> bool {
        self.game_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_map(&mut self, v: ::std::string::String) {
        self.game_map = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_map(&mut self) -> &mut ::std::string::String {
        if self.game_map.is_none() {
            self.game_map = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_map.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_map(&mut self) -> ::std::string::String {
        self.game_map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 server_id = 11;

    pub fn server_id(&self) -> u64 {
        self.server_id.unwrap_or(0)
    }

    pub fn clear_server_id(&mut self) {
        self.server_id = ::std::option::Option::None;
    }

    pub fn has_server_id(&self) -> bool {
        self.server_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_id(&mut self, v: u64) {
        self.server_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 12;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint64 reservation_id = 13;

    pub fn reservation_id(&self) -> u64 {
        self.reservation_id.unwrap_or(0)
    }

    pub fn clear_reservation_id(&mut self) {
        self.reservation_id = ::std::option::Option::None;
    }

    pub fn has_reservation_id(&self) -> bool {
        self.reservation_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation_id(&mut self, v: u64) {
        self.reservation_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_ip",
            |m: &WatchableMatchInfo| { &m.server_ip },
            |m: &mut WatchableMatchInfo| { &mut m.server_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_port",
            |m: &WatchableMatchInfo| { &m.tv_port },
            |m: &mut WatchableMatchInfo| { &mut m.tv_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_spectators",
            |m: &WatchableMatchInfo| { &m.tv_spectators },
            |m: &mut WatchableMatchInfo| { &mut m.tv_spectators },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_time",
            |m: &WatchableMatchInfo| { &m.tv_time },
            |m: &mut WatchableMatchInfo| { &mut m.tv_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "tv_watch_password",
            |m: &WatchableMatchInfo| { &m.tv_watch_password },
            |m: &mut WatchableMatchInfo| { &mut m.tv_watch_password },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cl_decryptdata_key",
            |m: &WatchableMatchInfo| { &m.cl_decryptdata_key },
            |m: &mut WatchableMatchInfo| { &mut m.cl_decryptdata_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "cl_decryptdata_key_pub",
            |m: &WatchableMatchInfo| { &m.cl_decryptdata_key_pub },
            |m: &mut WatchableMatchInfo| { &mut m.cl_decryptdata_key_pub },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_type",
            |m: &WatchableMatchInfo| { &m.game_type },
            |m: &mut WatchableMatchInfo| { &mut m.game_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_mapgroup",
            |m: &WatchableMatchInfo| { &m.game_mapgroup },
            |m: &mut WatchableMatchInfo| { &mut m.game_mapgroup },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_map",
            |m: &WatchableMatchInfo| { &m.game_map },
            |m: &mut WatchableMatchInfo| { &mut m.game_map },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_id",
            |m: &WatchableMatchInfo| { &m.server_id },
            |m: &mut WatchableMatchInfo| { &mut m.server_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &WatchableMatchInfo| { &m.match_id },
            |m: &mut WatchableMatchInfo| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reservation_id",
            |m: &WatchableMatchInfo| { &m.reservation_id },
            |m: &mut WatchableMatchInfo| { &mut m.reservation_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<WatchableMatchInfo>(
            "WatchableMatchInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for WatchableMatchInfo {
    const NAME: &'static str = "WatchableMatchInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.server_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.tv_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.tv_spectators = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.tv_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.tv_watch_password = ::std::option::Option::Some(is.read_bytes()?);
                },
                48 => {
                    self.cl_decryptdata_key = ::std::option::Option::Some(is.read_uint64()?);
                },
                56 => {
                    self.cl_decryptdata_key_pub = ::std::option::Option::Some(is.read_uint64()?);
                },
                64 => {
                    self.game_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    self.game_mapgroup = ::std::option::Option::Some(is.read_string()?);
                },
                82 => {
                    self.game_map = ::std::option::Option::Some(is.read_string()?);
                },
                88 => {
                    self.server_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                96 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                104 => {
                    self.reservation_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_ip {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.tv_port {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.tv_spectators {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.tv_time {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.tv_watch_password.as_ref() {
            my_size += ::protobuf::rt::bytes_size(5, &v);
        }
        if let Some(v) = self.cl_decryptdata_key {
            my_size += ::protobuf::rt::uint64_size(6, v);
        }
        if let Some(v) = self.cl_decryptdata_key_pub {
            my_size += ::protobuf::rt::uint64_size(7, v);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.game_mapgroup.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.game_map.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.server_id {
            my_size += ::protobuf::rt::uint64_size(11, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(12, v);
        }
        if let Some(v) = self.reservation_id {
            my_size += ::protobuf::rt::uint64_size(13, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.server_ip {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tv_port {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.tv_spectators {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.tv_time {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.tv_watch_password.as_ref() {
            os.write_bytes(5, v)?;
        }
        if let Some(v) = self.cl_decryptdata_key {
            os.write_uint64(6, v)?;
        }
        if let Some(v) = self.cl_decryptdata_key_pub {
            os.write_uint64(7, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.game_mapgroup.as_ref() {
            os.write_string(9, v)?;
        }
        if let Some(v) = self.game_map.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.server_id {
            os.write_uint64(11, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.reservation_id {
            os.write_uint64(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> WatchableMatchInfo {
        WatchableMatchInfo::new()
    }

    fn clear(&mut self) {
        self.server_ip = ::std::option::Option::None;
        self.tv_port = ::std::option::Option::None;
        self.tv_spectators = ::std::option::Option::None;
        self.tv_time = ::std::option::Option::None;
        self.tv_watch_password = ::std::option::Option::None;
        self.cl_decryptdata_key = ::std::option::Option::None;
        self.cl_decryptdata_key_pub = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.game_mapgroup = ::std::option::Option::None;
        self.game_map = ::std::option::Option::None;
        self.server_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.reservation_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static WatchableMatchInfo {
        static instance: WatchableMatchInfo = WatchableMatchInfo {
            server_ip: ::std::option::Option::None,
            tv_port: ::std::option::Option::None,
            tv_spectators: ::std::option::Option::None,
            tv_time: ::std::option::Option::None,
            tv_watch_password: ::std::option::Option::None,
            cl_decryptdata_key: ::std::option::Option::None,
            cl_decryptdata_key_pub: ::std::option::Option::None,
            game_type: ::std::option::Option::None,
            game_mapgroup: ::std::option::Option::None,
            game_map: ::std::option::Option::None,
            server_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            reservation_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for WatchableMatchInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("WatchableMatchInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for WatchableMatchInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchableMatchInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientRequestJoinFriendData)
pub struct CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinFriendData.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinFriendData.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinFriendData.join_token)
    pub join_token: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinFriendData.join_ipp)
    pub join_ipp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinFriendData.res)
    pub res: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinFriendData.errormsg)
    pub errormsg: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientRequestJoinFriendData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
        <CMsgGCCStrike15_v2_ClientRequestJoinFriendData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 join_token = 3;

    pub fn join_token(&self) -> u32 {
        self.join_token.unwrap_or(0)
    }

    pub fn clear_join_token(&mut self) {
        self.join_token = ::std::option::Option::None;
    }

    pub fn has_join_token(&self) -> bool {
        self.join_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_token(&mut self, v: u32) {
        self.join_token = ::std::option::Option::Some(v);
    }

    // optional uint32 join_ipp = 4;

    pub fn join_ipp(&self) -> u32 {
        self.join_ipp.unwrap_or(0)
    }

    pub fn clear_join_ipp(&mut self) {
        self.join_ipp = ::std::option::Option::None;
    }

    pub fn has_join_ipp(&self) -> bool {
        self.join_ipp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_ipp(&mut self, v: u32) {
        self.join_ipp = ::std::option::Option::Some(v);
    }

    // optional string errormsg = 6;

    pub fn errormsg(&self) -> &str {
        match self.errormsg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_errormsg(&mut self) {
        self.errormsg = ::std::option::Option::None;
    }

    pub fn has_errormsg(&self) -> bool {
        self.errormsg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_errormsg(&mut self, v: ::std::string::String) {
        self.errormsg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_errormsg(&mut self) -> &mut ::std::string::String {
        if self.errormsg.is_none() {
            self.errormsg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.errormsg.as_mut().unwrap()
    }

    // Take field
    pub fn take_errormsg(&mut self) -> ::std::string::String {
        self.errormsg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.version },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "join_token",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.join_token },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.join_token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "join_ipp",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.join_ipp },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.join_ipp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>(
            "res",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.res },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.res },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "errormsg",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &m.errormsg },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinFriendData| { &mut m.errormsg },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientRequestJoinFriendData>(
            "CMsgGCCStrike15_v2_ClientRequestJoinFriendData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientRequestJoinFriendData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.join_token = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.join_ipp = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.res)?;
                },
                50 => {
                    self.errormsg = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.join_token {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.join_ipp {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.res.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.errormsg.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.join_token {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.join_ipp {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.res.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.errormsg.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
        CMsgGCCStrike15_v2_ClientRequestJoinFriendData::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.join_token = ::std::option::Option::None;
        self.join_ipp = ::std::option::Option::None;
        self.res.clear();
        self.errormsg = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
        static instance: CMsgGCCStrike15_v2_ClientRequestJoinFriendData = CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
            version: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            join_token: ::std::option::Option::None,
            join_ipp: ::std::option::Option::None,
            res: ::protobuf::MessageField::none(),
            errormsg: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientRequestJoinFriendData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestJoinFriendData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientRequestJoinServerData)
pub struct CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinServerData.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinServerData.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinServerData.serverid)
    pub serverid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinServerData.server_ip)
    pub server_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinServerData.server_port)
    pub server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestJoinServerData.res)
    pub res: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientRequestJoinServerData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientRequestJoinServerData {
        <CMsgGCCStrike15_v2_ClientRequestJoinServerData as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestJoinServerData {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 serverid = 3;

    pub fn serverid(&self) -> u64 {
        self.serverid.unwrap_or(0)
    }

    pub fn clear_serverid(&mut self) {
        self.serverid = ::std::option::Option::None;
    }

    pub fn has_serverid(&self) -> bool {
        self.serverid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverid(&mut self, v: u64) {
        self.serverid = ::std::option::Option::Some(v);
    }

    // optional uint32 server_ip = 4;

    pub fn server_ip(&self) -> u32 {
        self.server_ip.unwrap_or(0)
    }

    pub fn clear_server_ip(&mut self) {
        self.server_ip = ::std::option::Option::None;
    }

    pub fn has_server_ip(&self) -> bool {
        self.server_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_ip(&mut self, v: u32) {
        self.server_ip = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 5;

    pub fn server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "version",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.version },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "serverid",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.serverid },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.serverid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_ip",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.server_ip },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.server_ip },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_port",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.server_port },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.server_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve>(
            "res",
            |m: &CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &m.res },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestJoinServerData| { &mut m.res },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientRequestJoinServerData>(
            "CMsgGCCStrike15_v2_ClientRequestJoinServerData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientRequestJoinServerData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.serverid = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.server_ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.res)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.serverid {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.server_ip {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.res.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.serverid {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.server_ip {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.res.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientRequestJoinServerData {
        CMsgGCCStrike15_v2_ClientRequestJoinServerData::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.serverid = ::std::option::Option::None;
        self.server_ip = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.res.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestJoinServerData {
        static instance: CMsgGCCStrike15_v2_ClientRequestJoinServerData = CMsgGCCStrike15_v2_ClientRequestJoinServerData {
            version: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            serverid: ::std::option::Option::None,
            server_ip: ::std::option::Option::None,
            server_port: ::std::option::Option::None,
            res: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientRequestJoinServerData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestJoinServerData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCstrike15_v2_ClientRequestNewMission)
pub struct CMsgGCCstrike15_v2_ClientRequestNewMission {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_ClientRequestNewMission.mission_id)
    pub mission_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_ClientRequestNewMission.campaign_id)
    pub campaign_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCstrike15_v2_ClientRequestNewMission.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCstrike15_v2_ClientRequestNewMission {
    fn default() -> &'a CMsgGCCstrike15_v2_ClientRequestNewMission {
        <CMsgGCCstrike15_v2_ClientRequestNewMission as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCstrike15_v2_ClientRequestNewMission {
    pub fn new() -> CMsgGCCstrike15_v2_ClientRequestNewMission {
        ::std::default::Default::default()
    }

    // optional uint32 mission_id = 2;

    pub fn mission_id(&self) -> u32 {
        self.mission_id.unwrap_or(0)
    }

    pub fn clear_mission_id(&mut self) {
        self.mission_id = ::std::option::Option::None;
    }

    pub fn has_mission_id(&self) -> bool {
        self.mission_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_id(&mut self, v: u32) {
        self.mission_id = ::std::option::Option::Some(v);
    }

    // optional uint32 campaign_id = 3;

    pub fn campaign_id(&self) -> u32 {
        self.campaign_id.unwrap_or(0)
    }

    pub fn clear_campaign_id(&mut self) {
        self.campaign_id = ::std::option::Option::None;
    }

    pub fn has_campaign_id(&self) -> bool {
        self.campaign_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_campaign_id(&mut self, v: u32) {
        self.campaign_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "mission_id",
            |m: &CMsgGCCstrike15_v2_ClientRequestNewMission| { &m.mission_id },
            |m: &mut CMsgGCCstrike15_v2_ClientRequestNewMission| { &mut m.mission_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "campaign_id",
            |m: &CMsgGCCstrike15_v2_ClientRequestNewMission| { &m.campaign_id },
            |m: &mut CMsgGCCstrike15_v2_ClientRequestNewMission| { &mut m.campaign_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCstrike15_v2_ClientRequestNewMission>(
            "CMsgGCCstrike15_v2_ClientRequestNewMission",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCstrike15_v2_ClientRequestNewMission {
    const NAME: &'static str = "CMsgGCCstrike15_v2_ClientRequestNewMission";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.mission_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.campaign_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mission_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.campaign_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.mission_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.campaign_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCstrike15_v2_ClientRequestNewMission {
        CMsgGCCstrike15_v2_ClientRequestNewMission::new()
    }

    fn clear(&mut self) {
        self.mission_id = ::std::option::Option::None;
        self.campaign_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCstrike15_v2_ClientRequestNewMission {
        static instance: CMsgGCCstrike15_v2_ClientRequestNewMission = CMsgGCCstrike15_v2_ClientRequestNewMission {
            mission_id: ::std::option::Option::None,
            campaign_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCstrike15_v2_ClientRequestNewMission {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCstrike15_v2_ClientRequestNewMission").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCstrike15_v2_ClientRequestNewMission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCstrike15_v2_ClientRequestNewMission {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded)
pub struct CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.xp_progress_data)
    pub xp_progress_data: ::std::vec::Vec<XpProgressData>,
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.current_xp)
    pub current_xp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.current_level)
    pub current_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.upgraded_defidx)
    pub upgraded_defidx: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    fn default() -> &'a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        <CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    pub fn new() -> CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 current_xp = 3;

    pub fn current_xp(&self) -> u32 {
        self.current_xp.unwrap_or(0)
    }

    pub fn clear_current_xp(&mut self) {
        self.current_xp = ::std::option::Option::None;
    }

    pub fn has_current_xp(&self) -> bool {
        self.current_xp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_xp(&mut self, v: u32) {
        self.current_xp = ::std::option::Option::Some(v);
    }

    // optional uint32 current_level = 4;

    pub fn current_level(&self) -> u32 {
        self.current_level.unwrap_or(0)
    }

    pub fn clear_current_level(&mut self) {
        self.current_level = ::std::option::Option::None;
    }

    pub fn has_current_level(&self) -> bool {
        self.current_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_level(&mut self, v: u32) {
        self.current_level = ::std::option::Option::Some(v);
    }

    // optional uint32 upgraded_defidx = 5;

    pub fn upgraded_defidx(&self) -> u32 {
        self.upgraded_defidx.unwrap_or(0)
    }

    pub fn clear_upgraded_defidx(&mut self) {
        self.upgraded_defidx = ::std::option::Option::None;
    }

    pub fn has_upgraded_defidx(&self) -> bool {
        self.upgraded_defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgraded_defidx(&mut self, v: u32) {
        self.upgraded_defidx = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "xp_progress_data",
            |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.xp_progress_data },
            |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.xp_progress_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.account_id },
            |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_xp",
            |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.current_xp },
            |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.current_xp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "current_level",
            |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.current_level },
            |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.current_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "upgraded_defidx",
            |m: &CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &m.upgraded_defidx },
            |m: &mut CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded| { &mut m.upgraded_defidx },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded>(
            "CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    const NAME: &'static str = "CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.xp_progress_data.push(is.read_message()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.current_xp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.current_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.upgraded_defidx = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.xp_progress_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.current_xp {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.current_level {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.upgraded_defidx {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.xp_progress_data {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.current_xp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.current_level {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.upgraded_defidx {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::new()
    }

    fn clear(&mut self) {
        self.xp_progress_data.clear();
        self.account_id = ::std::option::Option::None;
        self.current_xp = ::std::option::Option::None;
        self.current_level = ::std::option::Option::None;
        self.upgraded_defidx = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
        static instance: CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded = CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
            xp_progress_data: ::std::vec::Vec::new(),
            account_id: ::std::option::Option::None,
            current_xp: ::std::option::Option::None,
            current_level: ::std::option::Option::None,
            upgraded_defidx: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_WatchInfoUsers)
pub struct CMsgGCCStrike15_v2_WatchInfoUsers {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_WatchInfoUsers.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_WatchInfoUsers.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_WatchInfoUsers.watchable_match_infos)
    pub watchable_match_infos: ::std::vec::Vec<WatchableMatchInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_WatchInfoUsers.extended_timeout)
    pub extended_timeout: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_WatchInfoUsers.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_WatchInfoUsers {
    fn default() -> &'a CMsgGCCStrike15_v2_WatchInfoUsers {
        <CMsgGCCStrike15_v2_WatchInfoUsers as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_WatchInfoUsers {
    pub fn new() -> CMsgGCCStrike15_v2_WatchInfoUsers {
        ::std::default::Default::default()
    }

    // optional uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint32 extended_timeout = 5;

    pub fn extended_timeout(&self) -> u32 {
        self.extended_timeout.unwrap_or(0)
    }

    pub fn clear_extended_timeout(&mut self) {
        self.extended_timeout = ::std::option::Option::None;
    }

    pub fn has_extended_timeout(&self) -> bool {
        self.extended_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extended_timeout(&mut self, v: u32) {
        self.extended_timeout = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgGCCStrike15_v2_WatchInfoUsers| { &m.request_id },
            |m: &mut CMsgGCCStrike15_v2_WatchInfoUsers| { &mut m.request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids",
            |m: &CMsgGCCStrike15_v2_WatchInfoUsers| { &m.account_ids },
            |m: &mut CMsgGCCStrike15_v2_WatchInfoUsers| { &mut m.account_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "watchable_match_infos",
            |m: &CMsgGCCStrike15_v2_WatchInfoUsers| { &m.watchable_match_infos },
            |m: &mut CMsgGCCStrike15_v2_WatchInfoUsers| { &mut m.watchable_match_infos },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "extended_timeout",
            |m: &CMsgGCCStrike15_v2_WatchInfoUsers| { &m.extended_timeout },
            |m: &mut CMsgGCCStrike15_v2_WatchInfoUsers| { &mut m.extended_timeout },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_WatchInfoUsers>(
            "CMsgGCCStrike15_v2_WatchInfoUsers",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_WatchInfoUsers {
    const NAME: &'static str = "CMsgGCCStrike15_v2_WatchInfoUsers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                16 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                26 => {
                    self.watchable_match_infos.push(is.read_message()?);
                },
                40 => {
                    self.extended_timeout = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.account_ids {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.watchable_match_infos {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.extended_timeout {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_ids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.watchable_match_infos {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.extended_timeout {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_WatchInfoUsers {
        CMsgGCCStrike15_v2_WatchInfoUsers::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.account_ids.clear();
        self.watchable_match_infos.clear();
        self.extended_timeout = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_WatchInfoUsers {
        static instance: CMsgGCCStrike15_v2_WatchInfoUsers = CMsgGCCStrike15_v2_WatchInfoUsers {
            request_id: ::std::option::Option::None,
            account_ids: ::std::vec::Vec::new(),
            watchable_match_infos: ::std::vec::Vec::new(),
            extended_timeout: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_WatchInfoUsers {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_WatchInfoUsers").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_WatchInfoUsers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_WatchInfoUsers {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientRequestPlayersProfile)
pub struct CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestPlayersProfile.request_id__deprecated)
    pub request_id__deprecated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestPlayersProfile.account_ids__deprecated)
    pub account_ids__deprecated: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestPlayersProfile.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientRequestPlayersProfile.request_level)
    pub request_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientRequestPlayersProfile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
        <CMsgGCCStrike15_v2_ClientRequestPlayersProfile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    pub fn new() -> CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
        ::std::default::Default::default()
    }

    // optional uint32 request_id__deprecated = 1;

    pub fn request_id__deprecated(&self) -> u32 {
        self.request_id__deprecated.unwrap_or(0)
    }

    pub fn clear_request_id__deprecated(&mut self) {
        self.request_id__deprecated = ::std::option::Option::None;
    }

    pub fn has_request_id__deprecated(&self) -> bool {
        self.request_id__deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id__deprecated(&mut self, v: u32) {
        self.request_id__deprecated = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 3;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 request_level = 4;

    pub fn request_level(&self) -> u32 {
        self.request_level.unwrap_or(0)
    }

    pub fn clear_request_level(&mut self) {
        self.request_level = ::std::option::Option::None;
    }

    pub fn has_request_level(&self) -> bool {
        self.request_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_level(&mut self, v: u32) {
        self.request_level = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id__deprecated",
            |m: &CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &m.request_id__deprecated },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &mut m.request_id__deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_ids__deprecated",
            |m: &CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &m.account_ids__deprecated },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &mut m.account_ids__deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_level",
            |m: &CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &m.request_level },
            |m: &mut CMsgGCCStrike15_v2_ClientRequestPlayersProfile| { &mut m.request_level },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientRequestPlayersProfile>(
            "CMsgGCCStrike15_v2_ClientRequestPlayersProfile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientRequestPlayersProfile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id__deprecated = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids__deprecated)?;
                },
                16 => {
                    self.account_ids__deprecated.push(is.read_uint32()?);
                },
                24 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.request_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id__deprecated {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.account_ids__deprecated {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.request_level {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id__deprecated {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_ids__deprecated {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.account_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.request_level {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
        CMsgGCCStrike15_v2_ClientRequestPlayersProfile::new()
    }

    fn clear(&mut self) {
        self.request_id__deprecated = ::std::option::Option::None;
        self.account_ids__deprecated.clear();
        self.account_id = ::std::option::Option::None;
        self.request_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
        static instance: CMsgGCCStrike15_v2_ClientRequestPlayersProfile = CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
            request_id__deprecated: ::std::option::Option::None,
            account_ids__deprecated: ::std::vec::Vec::new(),
            account_id: ::std::option::Option::None,
            request_level: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientRequestPlayersProfile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientRequestPlayersProfile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_PlayersProfile)
pub struct CMsgGCCStrike15_v2_PlayersProfile {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayersProfile.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayersProfile.account_profiles)
    pub account_profiles: ::std::vec::Vec<CMsgGCCStrike15_v2_MatchmakingGC2ClientHello>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_PlayersProfile.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_PlayersProfile {
    fn default() -> &'a CMsgGCCStrike15_v2_PlayersProfile {
        <CMsgGCCStrike15_v2_PlayersProfile as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_PlayersProfile {
    pub fn new() -> CMsgGCCStrike15_v2_PlayersProfile {
        ::std::default::Default::default()
    }

    // optional uint32 request_id = 1;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "request_id",
            |m: &CMsgGCCStrike15_v2_PlayersProfile| { &m.request_id },
            |m: &mut CMsgGCCStrike15_v2_PlayersProfile| { &mut m.request_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "account_profiles",
            |m: &CMsgGCCStrike15_v2_PlayersProfile| { &m.account_profiles },
            |m: &mut CMsgGCCStrike15_v2_PlayersProfile| { &mut m.account_profiles },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_PlayersProfile>(
            "CMsgGCCStrike15_v2_PlayersProfile",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_PlayersProfile {
    const NAME: &'static str = "CMsgGCCStrike15_v2_PlayersProfile";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.account_profiles.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.account_profiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.account_profiles {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_PlayersProfile {
        CMsgGCCStrike15_v2_PlayersProfile::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.account_profiles.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_PlayersProfile {
        static instance: CMsgGCCStrike15_v2_PlayersProfile = CMsgGCCStrike15_v2_PlayersProfile {
            request_id: ::std::option::Option::None,
            account_profiles: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_PlayersProfile {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_PlayersProfile").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_PlayersProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_PlayersProfile {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate)
pub struct CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.caseid)
    pub caseid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.suspectid)
    pub suspectid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.fractionid)
    pub fractionid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.rpt_aimbot)
    pub rpt_aimbot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.rpt_wallhack)
    pub rpt_wallhack: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.rpt_speedhack)
    pub rpt_speedhack: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.rpt_teamharm)
    pub rpt_teamharm: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.reason)
    pub reason: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    fn default() -> &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
        <CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    pub fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
        ::std::default::Default::default()
    }

    // optional uint64 caseid = 1;

    pub fn caseid(&self) -> u64 {
        self.caseid.unwrap_or(0)
    }

    pub fn clear_caseid(&mut self) {
        self.caseid = ::std::option::Option::None;
    }

    pub fn has_caseid(&self) -> bool {
        self.caseid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseid(&mut self, v: u64) {
        self.caseid = ::std::option::Option::Some(v);
    }

    // optional uint32 suspectid = 3;

    pub fn suspectid(&self) -> u32 {
        self.suspectid.unwrap_or(0)
    }

    pub fn clear_suspectid(&mut self) {
        self.suspectid = ::std::option::Option::None;
    }

    pub fn has_suspectid(&self) -> bool {
        self.suspectid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suspectid(&mut self, v: u32) {
        self.suspectid = ::std::option::Option::Some(v);
    }

    // optional uint32 fractionid = 4;

    pub fn fractionid(&self) -> u32 {
        self.fractionid.unwrap_or(0)
    }

    pub fn clear_fractionid(&mut self) {
        self.fractionid = ::std::option::Option::None;
    }

    pub fn has_fractionid(&self) -> bool {
        self.fractionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fractionid(&mut self, v: u32) {
        self.fractionid = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_aimbot = 5;

    pub fn rpt_aimbot(&self) -> u32 {
        self.rpt_aimbot.unwrap_or(0)
    }

    pub fn clear_rpt_aimbot(&mut self) {
        self.rpt_aimbot = ::std::option::Option::None;
    }

    pub fn has_rpt_aimbot(&self) -> bool {
        self.rpt_aimbot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_aimbot(&mut self, v: u32) {
        self.rpt_aimbot = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_wallhack = 6;

    pub fn rpt_wallhack(&self) -> u32 {
        self.rpt_wallhack.unwrap_or(0)
    }

    pub fn clear_rpt_wallhack(&mut self) {
        self.rpt_wallhack = ::std::option::Option::None;
    }

    pub fn has_rpt_wallhack(&self) -> bool {
        self.rpt_wallhack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_wallhack(&mut self, v: u32) {
        self.rpt_wallhack = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_speedhack = 7;

    pub fn rpt_speedhack(&self) -> u32 {
        self.rpt_speedhack.unwrap_or(0)
    }

    pub fn clear_rpt_speedhack(&mut self) {
        self.rpt_speedhack = ::std::option::Option::None;
    }

    pub fn has_rpt_speedhack(&self) -> bool {
        self.rpt_speedhack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_speedhack(&mut self, v: u32) {
        self.rpt_speedhack = ::std::option::Option::Some(v);
    }

    // optional uint32 rpt_teamharm = 8;

    pub fn rpt_teamharm(&self) -> u32 {
        self.rpt_teamharm.unwrap_or(0)
    }

    pub fn clear_rpt_teamharm(&mut self) {
        self.rpt_teamharm = ::std::option::Option::None;
    }

    pub fn has_rpt_teamharm(&self) -> bool {
        self.rpt_teamharm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpt_teamharm(&mut self, v: u32) {
        self.rpt_teamharm = ::std::option::Option::Some(v);
    }

    // optional uint32 reason = 9;

    pub fn reason(&self) -> u32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: u32) {
        self.reason = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caseid",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.caseid },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.caseid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "suspectid",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.suspectid },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.suspectid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fractionid",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.fractionid },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.fractionid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_aimbot",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.rpt_aimbot },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.rpt_aimbot },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_wallhack",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.rpt_wallhack },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.rpt_wallhack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_speedhack",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.rpt_speedhack },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.rpt_speedhack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rpt_teamharm",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.rpt_teamharm },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.rpt_teamharm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &m.reason },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate>(
            "CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    const NAME: &'static str = "CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.caseid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.suspectid = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.fractionid = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rpt_aimbot = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.rpt_wallhack = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.rpt_speedhack = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.rpt_teamharm = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.caseid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.suspectid {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.fractionid {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rpt_aimbot {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.rpt_wallhack {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.rpt_speedhack {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.rpt_teamharm {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.caseid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.suspectid {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.fractionid {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rpt_aimbot {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.rpt_wallhack {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.rpt_speedhack {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.rpt_teamharm {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.reason {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
        CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::new()
    }

    fn clear(&mut self) {
        self.caseid = ::std::option::Option::None;
        self.suspectid = ::std::option::Option::None;
        self.fractionid = ::std::option::Option::None;
        self.rpt_aimbot = ::std::option::Option::None;
        self.rpt_wallhack = ::std::option::Option::None;
        self.rpt_speedhack = ::std::option::Option::None;
        self.rpt_teamharm = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
        static instance: CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
            caseid: ::std::option::Option::None,
            suspectid: ::std::option::Option::None,
            fractionid: ::std::option::Option::None,
            rpt_aimbot: ::std::option::Option::None,
            rpt_wallhack: ::std::option::Option::None,
            rpt_speedhack: ::std::option::Option::None,
            rpt_teamharm: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment)
pub struct CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.caseid)
    pub caseid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.caseurl)
    pub caseurl: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.verdict)
    pub verdict: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.throttleseconds)
    pub throttleseconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.suspectid)
    pub suspectid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.fractionid)
    pub fractionid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.numrounds)
    pub numrounds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.fractionrounds)
    pub fractionrounds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.streakconvictions)
    pub streakconvictions: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.reason)
    pub reason: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    fn default() -> &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
        <CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    pub fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
        ::std::default::Default::default()
    }

    // optional uint64 caseid = 1;

    pub fn caseid(&self) -> u64 {
        self.caseid.unwrap_or(0)
    }

    pub fn clear_caseid(&mut self) {
        self.caseid = ::std::option::Option::None;
    }

    pub fn has_caseid(&self) -> bool {
        self.caseid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseid(&mut self, v: u64) {
        self.caseid = ::std::option::Option::Some(v);
    }

    // optional string caseurl = 2;

    pub fn caseurl(&self) -> &str {
        match self.caseurl.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_caseurl(&mut self) {
        self.caseurl = ::std::option::Option::None;
    }

    pub fn has_caseurl(&self) -> bool {
        self.caseurl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseurl(&mut self, v: ::std::string::String) {
        self.caseurl = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_caseurl(&mut self) -> &mut ::std::string::String {
        if self.caseurl.is_none() {
            self.caseurl = ::std::option::Option::Some(::std::string::String::new());
        }
        self.caseurl.as_mut().unwrap()
    }

    // Take field
    pub fn take_caseurl(&mut self) -> ::std::string::String {
        self.caseurl.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 verdict = 3;

    pub fn verdict(&self) -> u32 {
        self.verdict.unwrap_or(0)
    }

    pub fn clear_verdict(&mut self) {
        self.verdict = ::std::option::Option::None;
    }

    pub fn has_verdict(&self) -> bool {
        self.verdict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verdict(&mut self, v: u32) {
        self.verdict = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 4;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 throttleseconds = 5;

    pub fn throttleseconds(&self) -> u32 {
        self.throttleseconds.unwrap_or(0)
    }

    pub fn clear_throttleseconds(&mut self) {
        self.throttleseconds = ::std::option::Option::None;
    }

    pub fn has_throttleseconds(&self) -> bool {
        self.throttleseconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_throttleseconds(&mut self, v: u32) {
        self.throttleseconds = ::std::option::Option::Some(v);
    }

    // optional uint32 suspectid = 6;

    pub fn suspectid(&self) -> u32 {
        self.suspectid.unwrap_or(0)
    }

    pub fn clear_suspectid(&mut self) {
        self.suspectid = ::std::option::Option::None;
    }

    pub fn has_suspectid(&self) -> bool {
        self.suspectid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suspectid(&mut self, v: u32) {
        self.suspectid = ::std::option::Option::Some(v);
    }

    // optional uint32 fractionid = 7;

    pub fn fractionid(&self) -> u32 {
        self.fractionid.unwrap_or(0)
    }

    pub fn clear_fractionid(&mut self) {
        self.fractionid = ::std::option::Option::None;
    }

    pub fn has_fractionid(&self) -> bool {
        self.fractionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fractionid(&mut self, v: u32) {
        self.fractionid = ::std::option::Option::Some(v);
    }

    // optional uint32 numrounds = 8;

    pub fn numrounds(&self) -> u32 {
        self.numrounds.unwrap_or(0)
    }

    pub fn clear_numrounds(&mut self) {
        self.numrounds = ::std::option::Option::None;
    }

    pub fn has_numrounds(&self) -> bool {
        self.numrounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_numrounds(&mut self, v: u32) {
        self.numrounds = ::std::option::Option::Some(v);
    }

    // optional uint32 fractionrounds = 9;

    pub fn fractionrounds(&self) -> u32 {
        self.fractionrounds.unwrap_or(0)
    }

    pub fn clear_fractionrounds(&mut self) {
        self.fractionrounds = ::std::option::Option::None;
    }

    pub fn has_fractionrounds(&self) -> bool {
        self.fractionrounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fractionrounds(&mut self, v: u32) {
        self.fractionrounds = ::std::option::Option::Some(v);
    }

    // optional int32 streakconvictions = 10;

    pub fn streakconvictions(&self) -> i32 {
        self.streakconvictions.unwrap_or(0)
    }

    pub fn clear_streakconvictions(&mut self) {
        self.streakconvictions = ::std::option::Option::None;
    }

    pub fn has_streakconvictions(&self) -> bool {
        self.streakconvictions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_streakconvictions(&mut self, v: i32) {
        self.streakconvictions = ::std::option::Option::Some(v);
    }

    // optional uint32 reason = 11;

    pub fn reason(&self) -> u32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: u32) {
        self.reason = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caseid",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.caseid },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.caseid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caseurl",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.caseurl },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.caseurl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "verdict",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.verdict },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.verdict },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timestamp",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.timestamp },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "throttleseconds",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.throttleseconds },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.throttleseconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "suspectid",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.suspectid },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.suspectid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fractionid",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.fractionid },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.fractionid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "numrounds",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.numrounds },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.numrounds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "fractionrounds",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.fractionrounds },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.fractionrounds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "streakconvictions",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.streakconvictions },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.streakconvictions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "reason",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &m.reason },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment| { &mut m.reason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment>(
            "CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    const NAME: &'static str = "CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.caseid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.caseurl = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.verdict = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.throttleseconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.suspectid = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.fractionid = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.numrounds = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.fractionrounds = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.streakconvictions = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.caseid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.caseurl.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.verdict {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.throttleseconds {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.suspectid {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.fractionid {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.numrounds {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.fractionrounds {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.streakconvictions {
            my_size += ::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.reason {
            my_size += ::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.caseid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.caseurl.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.verdict {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.throttleseconds {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.suspectid {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.fractionid {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.numrounds {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.fractionrounds {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.streakconvictions {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.reason {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
        CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::new()
    }

    fn clear(&mut self) {
        self.caseid = ::std::option::Option::None;
        self.caseurl = ::std::option::Option::None;
        self.verdict = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.throttleseconds = ::std::option::Option::None;
        self.suspectid = ::std::option::Option::None;
        self.fractionid = ::std::option::Option::None;
        self.numrounds = ::std::option::Option::None;
        self.fractionrounds = ::std::option::Option::None;
        self.streakconvictions = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
        static instance: CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
            caseid: ::std::option::Option::None,
            caseurl: ::std::option::Option::None,
            verdict: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            throttleseconds: ::std::option::Option::None,
            suspectid: ::std::option::Option::None,
            fractionid: ::std::option::Option::None,
            numrounds: ::std::option::Option::None,
            fractionrounds: ::std::option::Option::None,
            streakconvictions: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus)
pub struct CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.caseid)
    pub caseid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.statusid)
    pub statusid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    fn default() -> &'a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
        <CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    pub fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
        ::std::default::Default::default()
    }

    // optional uint64 caseid = 1;

    pub fn caseid(&self) -> u64 {
        self.caseid.unwrap_or(0)
    }

    pub fn clear_caseid(&mut self) {
        self.caseid = ::std::option::Option::None;
    }

    pub fn has_caseid(&self) -> bool {
        self.caseid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseid(&mut self, v: u64) {
        self.caseid = ::std::option::Option::Some(v);
    }

    // optional uint32 statusid = 2;

    pub fn statusid(&self) -> u32 {
        self.statusid.unwrap_or(0)
    }

    pub fn clear_statusid(&mut self) {
        self.statusid = ::std::option::Option::None;
    }

    pub fn has_statusid(&self) -> bool {
        self.statusid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_statusid(&mut self, v: u32) {
        self.statusid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caseid",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus| { &m.caseid },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus| { &mut m.caseid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "statusid",
            |m: &CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus| { &m.statusid },
            |m: &mut CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus| { &mut m.statusid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus>(
            "CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    const NAME: &'static str = "CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.caseid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.statusid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.caseid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.statusid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.caseid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.statusid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
        CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus::new()
    }

    fn clear(&mut self) {
        self.caseid = ::std::option::Option::None;
        self.statusid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
        static instance: CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
            caseid: ::std::option::Option::None,
            statusid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CClientHeaderOverwatchEvidence)
pub struct CClientHeaderOverwatchEvidence {
    // message fields
    // @@protoc_insertion_point(field:CClientHeaderOverwatchEvidence.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CClientHeaderOverwatchEvidence.caseid)
    pub caseid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CClientHeaderOverwatchEvidence.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CClientHeaderOverwatchEvidence {
    fn default() -> &'a CClientHeaderOverwatchEvidence {
        <CClientHeaderOverwatchEvidence as ::protobuf::Message>::default_instance()
    }
}

impl CClientHeaderOverwatchEvidence {
    pub fn new() -> CClientHeaderOverwatchEvidence {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 caseid = 2;

    pub fn caseid(&self) -> u64 {
        self.caseid.unwrap_or(0)
    }

    pub fn clear_caseid(&mut self) {
        self.caseid = ::std::option::Option::None;
    }

    pub fn has_caseid(&self) -> bool {
        self.caseid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_caseid(&mut self, v: u64) {
        self.caseid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CClientHeaderOverwatchEvidence| { &m.accountid },
            |m: &mut CClientHeaderOverwatchEvidence| { &mut m.accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "caseid",
            |m: &CClientHeaderOverwatchEvidence| { &m.caseid },
            |m: &mut CClientHeaderOverwatchEvidence| { &mut m.caseid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CClientHeaderOverwatchEvidence>(
            "CClientHeaderOverwatchEvidence",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CClientHeaderOverwatchEvidence {
    const NAME: &'static str = "CClientHeaderOverwatchEvidence";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.caseid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.caseid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.caseid {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CClientHeaderOverwatchEvidence {
        CClientHeaderOverwatchEvidence::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.caseid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CClientHeaderOverwatchEvidence {
        static instance: CClientHeaderOverwatchEvidence = CClientHeaderOverwatchEvidence {
            accountid: ::std::option::Option::None,
            caseid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CClientHeaderOverwatchEvidence {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CClientHeaderOverwatchEvidence").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CClientHeaderOverwatchEvidence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClientHeaderOverwatchEvidence {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GC2ClientTextMsg)
pub struct CMsgGCCStrike15_v2_GC2ClientTextMsg {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientTextMsg.id)
    pub id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientTextMsg.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientTextMsg.payload)
    pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GC2ClientTextMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GC2ClientTextMsg {
    fn default() -> &'a CMsgGCCStrike15_v2_GC2ClientTextMsg {
        <CMsgGCCStrike15_v2_GC2ClientTextMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GC2ClientTextMsg {
    pub fn new() -> CMsgGCCStrike15_v2_GC2ClientTextMsg {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 type = 2;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 3;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CMsgGCCStrike15_v2_GC2ClientTextMsg| { &m.id },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientTextMsg| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgGCCStrike15_v2_GC2ClientTextMsg| { &m.type_ },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientTextMsg| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "payload",
            |m: &CMsgGCCStrike15_v2_GC2ClientTextMsg| { &m.payload },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientTextMsg| { &mut m.payload },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GC2ClientTextMsg>(
            "CMsgGCCStrike15_v2_GC2ClientTextMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GC2ClientTextMsg {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GC2ClientTextMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.payload = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GC2ClientTextMsg {
        CMsgGCCStrike15_v2_GC2ClientTextMsg::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GC2ClientTextMsg {
        static instance: CMsgGCCStrike15_v2_GC2ClientTextMsg = CMsgGCCStrike15_v2_GC2ClientTextMsg {
            id: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GC2ClientTextMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GC2ClientTextMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GC2ClientTextMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GC2ClientTextMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Client2GCTextMsg)
pub struct CMsgGCCStrike15_v2_Client2GCTextMsg {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCTextMsg.id)
    pub id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCTextMsg.args)
    pub args: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Client2GCTextMsg.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Client2GCTextMsg {
    fn default() -> &'a CMsgGCCStrike15_v2_Client2GCTextMsg {
        <CMsgGCCStrike15_v2_Client2GCTextMsg as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Client2GCTextMsg {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCTextMsg {
        ::std::default::Default::default()
    }

    // optional uint32 id = 1;

    pub fn id(&self) -> u32 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u32) {
        self.id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "id",
            |m: &CMsgGCCStrike15_v2_Client2GCTextMsg| { &m.id },
            |m: &mut CMsgGCCStrike15_v2_Client2GCTextMsg| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &CMsgGCCStrike15_v2_Client2GCTextMsg| { &m.args },
            |m: &mut CMsgGCCStrike15_v2_Client2GCTextMsg| { &mut m.args },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Client2GCTextMsg>(
            "CMsgGCCStrike15_v2_Client2GCTextMsg",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCTextMsg {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Client2GCTextMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.args.push(is.read_bytes()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.args {
            my_size += ::protobuf::rt::bytes_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint32(1, v)?;
        }
        for v in &self.args {
            os.write_bytes(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Client2GCTextMsg {
        CMsgGCCStrike15_v2_Client2GCTextMsg::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.args.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCTextMsg {
        static instance: CMsgGCCStrike15_v2_Client2GCTextMsg = CMsgGCCStrike15_v2_Client2GCTextMsg {
            id: ::std::option::Option::None,
            args: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Client2GCTextMsg {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Client2GCTextMsg").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Client2GCTextMsg {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCTextMsg {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchEndRunRewardDrops)
pub struct CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchEndRunRewardDrops.serverinfo)
    pub serverinfo: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingServerReservationResponse>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchEndRunRewardDrops.match_end_quest_data)
    pub match_end_quest_data: ::protobuf::MessageField<CMsgGC_ServerQuestUpdateData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchEndRunRewardDrops.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
        <CMsgGCCStrike15_v2_MatchEndRunRewardDrops as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    pub fn new() -> CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingServerReservationResponse>(
            "serverinfo",
            |m: &CMsgGCCStrike15_v2_MatchEndRunRewardDrops| { &m.serverinfo },
            |m: &mut CMsgGCCStrike15_v2_MatchEndRunRewardDrops| { &mut m.serverinfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGC_ServerQuestUpdateData>(
            "match_end_quest_data",
            |m: &CMsgGCCStrike15_v2_MatchEndRunRewardDrops| { &m.match_end_quest_data },
            |m: &mut CMsgGCCStrike15_v2_MatchEndRunRewardDrops| { &mut m.match_end_quest_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchEndRunRewardDrops>(
            "CMsgGCCStrike15_v2_MatchEndRunRewardDrops",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchEndRunRewardDrops";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.serverinfo)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.match_end_quest_data)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serverinfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.match_end_quest_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.serverinfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.match_end_quest_data.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
        CMsgGCCStrike15_v2_MatchEndRunRewardDrops::new()
    }

    fn clear(&mut self) {
        self.serverinfo.clear();
        self.match_end_quest_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
        static instance: CMsgGCCStrike15_v2_MatchEndRunRewardDrops = CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
            serverinfo: ::protobuf::MessageField::none(),
            match_end_quest_data: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchEndRunRewardDrops").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchEndRunRewardDrops {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CEconItemPreviewDataBlock)
pub struct CEconItemPreviewDataBlock {
    // message fields
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.itemid)
    pub itemid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.defindex)
    pub defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.paintindex)
    pub paintindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.rarity)
    pub rarity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.quality)
    pub quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.paintwear)
    pub paintwear: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.paintseed)
    pub paintseed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.killeaterscoretype)
    pub killeaterscoretype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.killeatervalue)
    pub killeatervalue: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.customname)
    pub customname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.stickers)
    pub stickers: ::std::vec::Vec<cecon_item_preview_data_block::Sticker>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.inventory)
    pub inventory: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.origin)
    pub origin: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.questid)
    pub questid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.dropreason)
    pub dropreason: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CEconItemPreviewDataBlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEconItemPreviewDataBlock {
    fn default() -> &'a CEconItemPreviewDataBlock {
        <CEconItemPreviewDataBlock as ::protobuf::Message>::default_instance()
    }
}

impl CEconItemPreviewDataBlock {
    pub fn new() -> CEconItemPreviewDataBlock {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint64 itemid = 2;

    pub fn itemid(&self) -> u64 {
        self.itemid.unwrap_or(0)
    }

    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: u64) {
        self.itemid = ::std::option::Option::Some(v);
    }

    // optional uint32 defindex = 3;

    pub fn defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional uint32 paintindex = 4;

    pub fn paintindex(&self) -> u32 {
        self.paintindex.unwrap_or(0)
    }

    pub fn clear_paintindex(&mut self) {
        self.paintindex = ::std::option::Option::None;
    }

    pub fn has_paintindex(&self) -> bool {
        self.paintindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paintindex(&mut self, v: u32) {
        self.paintindex = ::std::option::Option::Some(v);
    }

    // optional uint32 rarity = 5;

    pub fn rarity(&self) -> u32 {
        self.rarity.unwrap_or(0)
    }

    pub fn clear_rarity(&mut self) {
        self.rarity = ::std::option::Option::None;
    }

    pub fn has_rarity(&self) -> bool {
        self.rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rarity(&mut self, v: u32) {
        self.rarity = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 6;

    pub fn quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 paintwear = 7;

    pub fn paintwear(&self) -> u32 {
        self.paintwear.unwrap_or(0)
    }

    pub fn clear_paintwear(&mut self) {
        self.paintwear = ::std::option::Option::None;
    }

    pub fn has_paintwear(&self) -> bool {
        self.paintwear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paintwear(&mut self, v: u32) {
        self.paintwear = ::std::option::Option::Some(v);
    }

    // optional uint32 paintseed = 8;

    pub fn paintseed(&self) -> u32 {
        self.paintseed.unwrap_or(0)
    }

    pub fn clear_paintseed(&mut self) {
        self.paintseed = ::std::option::Option::None;
    }

    pub fn has_paintseed(&self) -> bool {
        self.paintseed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paintseed(&mut self, v: u32) {
        self.paintseed = ::std::option::Option::Some(v);
    }

    // optional uint32 killeaterscoretype = 9;

    pub fn killeaterscoretype(&self) -> u32 {
        self.killeaterscoretype.unwrap_or(0)
    }

    pub fn clear_killeaterscoretype(&mut self) {
        self.killeaterscoretype = ::std::option::Option::None;
    }

    pub fn has_killeaterscoretype(&self) -> bool {
        self.killeaterscoretype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killeaterscoretype(&mut self, v: u32) {
        self.killeaterscoretype = ::std::option::Option::Some(v);
    }

    // optional uint32 killeatervalue = 10;

    pub fn killeatervalue(&self) -> u32 {
        self.killeatervalue.unwrap_or(0)
    }

    pub fn clear_killeatervalue(&mut self) {
        self.killeatervalue = ::std::option::Option::None;
    }

    pub fn has_killeatervalue(&self) -> bool {
        self.killeatervalue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killeatervalue(&mut self, v: u32) {
        self.killeatervalue = ::std::option::Option::Some(v);
    }

    // optional string customname = 11;

    pub fn customname(&self) -> &str {
        match self.customname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_customname(&mut self) {
        self.customname = ::std::option::Option::None;
    }

    pub fn has_customname(&self) -> bool {
        self.customname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_customname(&mut self, v: ::std::string::String) {
        self.customname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_customname(&mut self) -> &mut ::std::string::String {
        if self.customname.is_none() {
            self.customname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.customname.as_mut().unwrap()
    }

    // Take field
    pub fn take_customname(&mut self) -> ::std::string::String {
        self.customname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 inventory = 13;

    pub fn inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }

    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 14;

    pub fn origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }

    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    // optional uint32 questid = 15;

    pub fn questid(&self) -> u32 {
        self.questid.unwrap_or(0)
    }

    pub fn clear_questid(&mut self) {
        self.questid = ::std::option::Option::None;
    }

    pub fn has_questid(&self) -> bool {
        self.questid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_questid(&mut self, v: u32) {
        self.questid = ::std::option::Option::Some(v);
    }

    // optional uint32 dropreason = 16;

    pub fn dropreason(&self) -> u32 {
        self.dropreason.unwrap_or(0)
    }

    pub fn clear_dropreason(&mut self) {
        self.dropreason = ::std::option::Option::None;
    }

    pub fn has_dropreason(&self) -> bool {
        self.dropreason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dropreason(&mut self, v: u32) {
        self.dropreason = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CEconItemPreviewDataBlock| { &m.accountid },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "itemid",
            |m: &CEconItemPreviewDataBlock| { &m.itemid },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.itemid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "defindex",
            |m: &CEconItemPreviewDataBlock| { &m.defindex },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.defindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paintindex",
            |m: &CEconItemPreviewDataBlock| { &m.paintindex },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.paintindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "rarity",
            |m: &CEconItemPreviewDataBlock| { &m.rarity },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.rarity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "quality",
            |m: &CEconItemPreviewDataBlock| { &m.quality },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.quality },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paintwear",
            |m: &CEconItemPreviewDataBlock| { &m.paintwear },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.paintwear },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "paintseed",
            |m: &CEconItemPreviewDataBlock| { &m.paintseed },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.paintseed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "killeaterscoretype",
            |m: &CEconItemPreviewDataBlock| { &m.killeaterscoretype },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.killeaterscoretype },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "killeatervalue",
            |m: &CEconItemPreviewDataBlock| { &m.killeatervalue },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.killeatervalue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "customname",
            |m: &CEconItemPreviewDataBlock| { &m.customname },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.customname },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stickers",
            |m: &CEconItemPreviewDataBlock| { &m.stickers },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.stickers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "inventory",
            |m: &CEconItemPreviewDataBlock| { &m.inventory },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.inventory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "origin",
            |m: &CEconItemPreviewDataBlock| { &m.origin },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.origin },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "questid",
            |m: &CEconItemPreviewDataBlock| { &m.questid },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.questid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "dropreason",
            |m: &CEconItemPreviewDataBlock| { &m.dropreason },
            |m: &mut CEconItemPreviewDataBlock| { &mut m.dropreason },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CEconItemPreviewDataBlock>(
            "CEconItemPreviewDataBlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CEconItemPreviewDataBlock {
    const NAME: &'static str = "CEconItemPreviewDataBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.itemid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.paintindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rarity = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.paintwear = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.paintseed = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.killeaterscoretype = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.killeatervalue = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.customname = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    self.stickers.push(is.read_message()?);
                },
                104 => {
                    self.inventory = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.origin = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.questid = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.dropreason = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.itemid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.paintindex {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rarity {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.quality {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.paintwear {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.paintseed {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.killeaterscoretype {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.killeatervalue {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.customname.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        for value in &self.stickers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.inventory {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.origin {
            my_size += ::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.questid {
            my_size += ::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.dropreason {
            my_size += ::protobuf::rt::uint32_size(16, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.itemid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.defindex {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.paintindex {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rarity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.paintwear {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.paintseed {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.killeaterscoretype {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.killeatervalue {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.customname.as_ref() {
            os.write_string(11, v)?;
        }
        for v in &self.stickers {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        if let Some(v) = self.inventory {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.questid {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.dropreason {
            os.write_uint32(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEconItemPreviewDataBlock {
        CEconItemPreviewDataBlock::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.itemid = ::std::option::Option::None;
        self.defindex = ::std::option::Option::None;
        self.paintindex = ::std::option::Option::None;
        self.rarity = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.paintwear = ::std::option::Option::None;
        self.paintseed = ::std::option::Option::None;
        self.killeaterscoretype = ::std::option::Option::None;
        self.killeatervalue = ::std::option::Option::None;
        self.customname = ::std::option::Option::None;
        self.stickers.clear();
        self.inventory = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.questid = ::std::option::Option::None;
        self.dropreason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEconItemPreviewDataBlock {
        static instance: CEconItemPreviewDataBlock = CEconItemPreviewDataBlock {
            accountid: ::std::option::Option::None,
            itemid: ::std::option::Option::None,
            defindex: ::std::option::Option::None,
            paintindex: ::std::option::Option::None,
            rarity: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            paintwear: ::std::option::Option::None,
            paintseed: ::std::option::Option::None,
            killeaterscoretype: ::std::option::Option::None,
            killeatervalue: ::std::option::Option::None,
            customname: ::std::option::Option::None,
            stickers: ::std::vec::Vec::new(),
            inventory: ::std::option::Option::None,
            origin: ::std::option::Option::None,
            questid: ::std::option::Option::None,
            dropreason: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CEconItemPreviewDataBlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CEconItemPreviewDataBlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CEconItemPreviewDataBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CEconItemPreviewDataBlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CEconItemPreviewDataBlock`
pub mod cecon_item_preview_data_block {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CEconItemPreviewDataBlock.Sticker)
    pub struct Sticker {
        // message fields
        // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.Sticker.slot)
        pub slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.Sticker.sticker_id)
        pub sticker_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.Sticker.wear)
        pub wear: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.Sticker.scale)
        pub scale: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.Sticker.rotation)
        pub rotation: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CEconItemPreviewDataBlock.Sticker.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Sticker {
        fn default() -> &'a Sticker {
            <Sticker as ::protobuf::Message>::default_instance()
        }
    }

    impl Sticker {
        pub fn new() -> Sticker {
            ::std::default::Default::default()
        }

        // optional uint32 slot = 1;

        pub fn slot(&self) -> u32 {
            self.slot.unwrap_or(0)
        }

        pub fn clear_slot(&mut self) {
            self.slot = ::std::option::Option::None;
        }

        pub fn has_slot(&self) -> bool {
            self.slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot(&mut self, v: u32) {
            self.slot = ::std::option::Option::Some(v);
        }

        // optional uint32 sticker_id = 2;

        pub fn sticker_id(&self) -> u32 {
            self.sticker_id.unwrap_or(0)
        }

        pub fn clear_sticker_id(&mut self) {
            self.sticker_id = ::std::option::Option::None;
        }

        pub fn has_sticker_id(&self) -> bool {
            self.sticker_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sticker_id(&mut self, v: u32) {
            self.sticker_id = ::std::option::Option::Some(v);
        }

        // optional float wear = 3;

        pub fn wear(&self) -> f32 {
            self.wear.unwrap_or(0.)
        }

        pub fn clear_wear(&mut self) {
            self.wear = ::std::option::Option::None;
        }

        pub fn has_wear(&self) -> bool {
            self.wear.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wear(&mut self, v: f32) {
            self.wear = ::std::option::Option::Some(v);
        }

        // optional float scale = 4;

        pub fn scale(&self) -> f32 {
            self.scale.unwrap_or(0.)
        }

        pub fn clear_scale(&mut self) {
            self.scale = ::std::option::Option::None;
        }

        pub fn has_scale(&self) -> bool {
            self.scale.is_some()
        }

        // Param is passed by value, moved
        pub fn set_scale(&mut self, v: f32) {
            self.scale = ::std::option::Option::Some(v);
        }

        // optional float rotation = 5;

        pub fn rotation(&self) -> f32 {
            self.rotation.unwrap_or(0.)
        }

        pub fn clear_rotation(&mut self) {
            self.rotation = ::std::option::Option::None;
        }

        pub fn has_rotation(&self) -> bool {
            self.rotation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rotation(&mut self, v: f32) {
            self.rotation = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "slot",
                |m: &Sticker| { &m.slot },
                |m: &mut Sticker| { &mut m.slot },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sticker_id",
                |m: &Sticker| { &m.sticker_id },
                |m: &mut Sticker| { &mut m.sticker_id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "wear",
                |m: &Sticker| { &m.wear },
                |m: &mut Sticker| { &mut m.wear },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "scale",
                |m: &Sticker| { &m.scale },
                |m: &mut Sticker| { &mut m.scale },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "rotation",
                |m: &Sticker| { &m.rotation },
                |m: &mut Sticker| { &mut m.rotation },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Sticker>(
                "CEconItemPreviewDataBlock.Sticker",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Sticker {
        const NAME: &'static str = "Sticker";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.sticker_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    29 => {
                        self.wear = ::std::option::Option::Some(is.read_float()?);
                    },
                    37 => {
                        self.scale = ::std::option::Option::Some(is.read_float()?);
                    },
                    45 => {
                        self.rotation = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.slot {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.sticker_id {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.wear {
                my_size += 1 + 4;
            }
            if let Some(v) = self.scale {
                my_size += 1 + 4;
            }
            if let Some(v) = self.rotation {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.slot {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.sticker_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.wear {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.scale {
                os.write_float(4, v)?;
            }
            if let Some(v) = self.rotation {
                os.write_float(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Sticker {
            Sticker::new()
        }

        fn clear(&mut self) {
            self.slot = ::std::option::Option::None;
            self.sticker_id = ::std::option::Option::None;
            self.wear = ::std::option::Option::None;
            self.scale = ::std::option::Option::None;
            self.rotation = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Sticker {
            static instance: Sticker = Sticker {
                slot: ::std::option::Option::None,
                sticker_id: ::std::option::Option::None,
                wear: ::std::option::Option::None,
                scale: ::std::option::Option::None,
                rotation: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Sticker {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CEconItemPreviewDataBlock.Sticker").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Sticker {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Sticker {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchEndRewardDropsNotification)
pub struct CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.iteminfo)
    pub iteminfo: ::protobuf::MessageField<CEconItemPreviewDataBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
        <CMsgGCCStrike15_v2_MatchEndRewardDropsNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    pub fn new() -> CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CEconItemPreviewDataBlock>(
            "iteminfo",
            |m: &CMsgGCCStrike15_v2_MatchEndRewardDropsNotification| { &m.iteminfo },
            |m: &mut CMsgGCCStrike15_v2_MatchEndRewardDropsNotification| { &mut m.iteminfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchEndRewardDropsNotification>(
            "CMsgGCCStrike15_v2_MatchEndRewardDropsNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchEndRewardDropsNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.iteminfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.iteminfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
        CMsgGCCStrike15_v2_MatchEndRewardDropsNotification::new()
    }

    fn clear(&mut self) {
        self.iteminfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
        static instance: CMsgGCCStrike15_v2_MatchEndRewardDropsNotification = CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
            iteminfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchEndRewardDropsNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchEndRewardDropsNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgItemAcknowledged)
pub struct CMsgItemAcknowledged {
    // message fields
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.iteminfo)
    pub iteminfo: ::protobuf::MessageField<CEconItemPreviewDataBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgItemAcknowledged.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgItemAcknowledged {
    fn default() -> &'a CMsgItemAcknowledged {
        <CMsgItemAcknowledged as ::protobuf::Message>::default_instance()
    }
}

impl CMsgItemAcknowledged {
    pub fn new() -> CMsgItemAcknowledged {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CEconItemPreviewDataBlock>(
            "iteminfo",
            |m: &CMsgItemAcknowledged| { &m.iteminfo },
            |m: &mut CMsgItemAcknowledged| { &mut m.iteminfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgItemAcknowledged>(
            "CMsgItemAcknowledged",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgItemAcknowledged {
    const NAME: &'static str = "CMsgItemAcknowledged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.iteminfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.iteminfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgItemAcknowledged {
        CMsgItemAcknowledged::new()
    }

    fn clear(&mut self) {
        self.iteminfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgItemAcknowledged {
        static instance: CMsgItemAcknowledged = CMsgItemAcknowledged {
            iteminfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgItemAcknowledged {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgItemAcknowledged").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgItemAcknowledged {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgItemAcknowledged {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest)
pub struct CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.param_s)
    pub param_s: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.param_a)
    pub param_a: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.param_d)
    pub param_d: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.param_m)
    pub param_m: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    fn default() -> &'a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
        <CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
        ::std::default::Default::default()
    }

    // optional uint64 param_s = 1;

    pub fn param_s(&self) -> u64 {
        self.param_s.unwrap_or(0)
    }

    pub fn clear_param_s(&mut self) {
        self.param_s = ::std::option::Option::None;
    }

    pub fn has_param_s(&self) -> bool {
        self.param_s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_s(&mut self, v: u64) {
        self.param_s = ::std::option::Option::Some(v);
    }

    // optional uint64 param_a = 2;

    pub fn param_a(&self) -> u64 {
        self.param_a.unwrap_or(0)
    }

    pub fn clear_param_a(&mut self) {
        self.param_a = ::std::option::Option::None;
    }

    pub fn has_param_a(&self) -> bool {
        self.param_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_a(&mut self, v: u64) {
        self.param_a = ::std::option::Option::Some(v);
    }

    // optional uint64 param_d = 3;

    pub fn param_d(&self) -> u64 {
        self.param_d.unwrap_or(0)
    }

    pub fn clear_param_d(&mut self) {
        self.param_d = ::std::option::Option::None;
    }

    pub fn has_param_d(&self) -> bool {
        self.param_d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_d(&mut self, v: u64) {
        self.param_d = ::std::option::Option::Some(v);
    }

    // optional uint64 param_m = 4;

    pub fn param_m(&self) -> u64 {
        self.param_m.unwrap_or(0)
    }

    pub fn clear_param_m(&mut self) {
        self.param_m = ::std::option::Option::None;
    }

    pub fn has_param_m(&self) -> bool {
        self.param_m.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_m(&mut self, v: u64) {
        self.param_m = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_s",
            |m: &CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &m.param_s },
            |m: &mut CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &mut m.param_s },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_a",
            |m: &CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &m.param_a },
            |m: &mut CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &mut m.param_a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_d",
            |m: &CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &m.param_d },
            |m: &mut CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &mut m.param_d },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "param_m",
            |m: &CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &m.param_m },
            |m: &mut CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest| { &mut m.param_m },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest>(
            "CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.param_s = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.param_a = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.param_d = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.param_m = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.param_s {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.param_a {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.param_d {
            my_size += ::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.param_m {
            my_size += ::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.param_s {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.param_a {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.param_d {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.param_m {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
        CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest::new()
    }

    fn clear(&mut self) {
        self.param_s = ::std::option::Option::None;
        self.param_a = ::std::option::Option::None;
        self.param_d = ::std::option::Option::None;
        self.param_m = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
        static instance: CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
            param_s: ::std::option::Option::None,
            param_a: ::std::option::Option::None,
            param_d: ::std::option::Option::None,
            param_m: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse)
pub struct CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.iteminfo)
    pub iteminfo: ::protobuf::MessageField<CEconItemPreviewDataBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    fn default() -> &'a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
        <CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CEconItemPreviewDataBlock>(
            "iteminfo",
            |m: &CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse| { &m.iteminfo },
            |m: &mut CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse| { &mut m.iteminfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse>(
            "CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.iteminfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.iteminfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
        CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse::new()
    }

    fn clear(&mut self) {
        self.iteminfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
        static instance: CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
            iteminfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification)
pub struct CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.defindex)
    pub defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.accountids)
    pub accountids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    fn default() -> &'a CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
        <CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    pub fn new() -> CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 defindex = 2;

    pub fn defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification| { &m.match_id },
            |m: &mut CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "defindex",
            |m: &CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification| { &m.defindex },
            |m: &mut CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification| { &mut m.defindex },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "accountids",
            |m: &CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification| { &m.accountids },
            |m: &mut CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification| { &mut m.accountids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification>(
            "CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    const NAME: &'static str = "CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.accountids)?;
                },
                24 => {
                    self.accountids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.defindex {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.accountids {
            my_size += ::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.defindex {
            os.write_uint32(2, v)?;
        }
        for v in &self.accountids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
        CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.defindex = ::std::option::Option::None;
        self.accountids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
        static instance: CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification = CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
            match_id: ::std::option::Option::None,
            defindex: ::std::option::Option::None,
            accountids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames)
pub struct CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
        <CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames>(
            "CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
        CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
        static instance: CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser)
pub struct CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.accountid)
    pub accountid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
        <CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser| { &m.accountid },
            |m: &mut CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser| { &mut m.accountid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser>(
            "CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
        CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
        static instance: CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
            accountid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchListRequestRecentUserGames)
pub struct CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.accountid)
    pub accountid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
        <CMsgGCCStrike15_v2_MatchListRequestRecentUserGames as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CMsgGCCStrike15_v2_MatchListRequestRecentUserGames| { &m.accountid },
            |m: &mut CMsgGCCStrike15_v2_MatchListRequestRecentUserGames| { &mut m.accountid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchListRequestRecentUserGames>(
            "CMsgGCCStrike15_v2_MatchListRequestRecentUserGames",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchListRequestRecentUserGames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
        CMsgGCCStrike15_v2_MatchListRequestRecentUserGames::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
        static instance: CMsgGCCStrike15_v2_MatchListRequestRecentUserGames = CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
            accountid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchListRequestRecentUserGames").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestRecentUserGames {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchListRequestTournamentGames)
pub struct CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchListRequestTournamentGames.eventid)
    pub eventid: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchListRequestTournamentGames.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
        <CMsgGCCStrike15_v2_MatchListRequestTournamentGames as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
        ::std::default::Default::default()
    }

    // optional int32 eventid = 1;

    pub fn eventid(&self) -> i32 {
        self.eventid.unwrap_or(0)
    }

    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: i32) {
        self.eventid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eventid",
            |m: &CMsgGCCStrike15_v2_MatchListRequestTournamentGames| { &m.eventid },
            |m: &mut CMsgGCCStrike15_v2_MatchListRequestTournamentGames| { &mut m.eventid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchListRequestTournamentGames>(
            "CMsgGCCStrike15_v2_MatchListRequestTournamentGames",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchListRequestTournamentGames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eventid = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eventid {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
        CMsgGCCStrike15_v2_MatchListRequestTournamentGames::new()
    }

    fn clear(&mut self) {
        self.eventid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
        static instance: CMsgGCCStrike15_v2_MatchListRequestTournamentGames = CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
            eventid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchListRequestTournamentGames").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestTournamentGames {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchListRequestFullGameInfo)
pub struct CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.matchid)
    pub matchid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.outcomeid)
    pub outcomeid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.token)
    pub token: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
        <CMsgGCCStrike15_v2_MatchListRequestFullGameInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    pub fn new() -> CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
        ::std::default::Default::default()
    }

    // optional uint64 matchid = 1;

    pub fn matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }

    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }

    // optional uint64 outcomeid = 2;

    pub fn outcomeid(&self) -> u64 {
        self.outcomeid.unwrap_or(0)
    }

    pub fn clear_outcomeid(&mut self) {
        self.outcomeid = ::std::option::Option::None;
    }

    pub fn has_outcomeid(&self) -> bool {
        self.outcomeid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outcomeid(&mut self, v: u64) {
        self.outcomeid = ::std::option::Option::Some(v);
    }

    // optional uint32 token = 3;

    pub fn token(&self) -> u32 {
        self.token.unwrap_or(0)
    }

    pub fn clear_token(&mut self) {
        self.token = ::std::option::Option::None;
    }

    pub fn has_token(&self) -> bool {
        self.token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token(&mut self, v: u32) {
        self.token = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchid",
            |m: &CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &m.matchid },
            |m: &mut CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &mut m.matchid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "outcomeid",
            |m: &CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &m.outcomeid },
            |m: &mut CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &mut m.outcomeid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "token",
            |m: &CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &m.token },
            |m: &mut CMsgGCCStrike15_v2_MatchListRequestFullGameInfo| { &mut m.token },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchListRequestFullGameInfo>(
            "CMsgGCCStrike15_v2_MatchListRequestFullGameInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchListRequestFullGameInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.matchid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.outcomeid = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.token = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.outcomeid {
            my_size += ::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.token {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.matchid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.outcomeid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.token {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
        CMsgGCCStrike15_v2_MatchListRequestFullGameInfo::new()
    }

    fn clear(&mut self) {
        self.matchid = ::std::option::Option::None;
        self.outcomeid = ::std::option::Option::None;
        self.token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
        static instance: CMsgGCCStrike15_v2_MatchListRequestFullGameInfo = CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
            matchid: ::std::option::Option::None,
            outcomeid: ::std::option::Option::None,
            token: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchListRequestFullGameInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchListRequestFullGameInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CDataGCCStrike15_v2_MatchInfo)
pub struct CDataGCCStrike15_v2_MatchInfo {
    // message fields
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_MatchInfo.matchid)
    pub matchid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_MatchInfo.matchtime)
    pub matchtime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_MatchInfo.watchablematchinfo)
    pub watchablematchinfo: ::protobuf::MessageField<WatchableMatchInfo>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_MatchInfo.roundstats_legacy)
    pub roundstats_legacy: ::protobuf::MessageField<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_MatchInfo.roundstatsall)
    pub roundstatsall: ::std::vec::Vec<CMsgGCCStrike15_v2_MatchmakingServerRoundStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CDataGCCStrike15_v2_MatchInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_MatchInfo {
    fn default() -> &'a CDataGCCStrike15_v2_MatchInfo {
        <CDataGCCStrike15_v2_MatchInfo as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_MatchInfo {
    pub fn new() -> CDataGCCStrike15_v2_MatchInfo {
        ::std::default::Default::default()
    }

    // optional uint64 matchid = 1;

    pub fn matchid(&self) -> u64 {
        self.matchid.unwrap_or(0)
    }

    pub fn clear_matchid(&mut self) {
        self.matchid = ::std::option::Option::None;
    }

    pub fn has_matchid(&self) -> bool {
        self.matchid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchid(&mut self, v: u64) {
        self.matchid = ::std::option::Option::Some(v);
    }

    // optional uint32 matchtime = 2;

    pub fn matchtime(&self) -> u32 {
        self.matchtime.unwrap_or(0)
    }

    pub fn clear_matchtime(&mut self) {
        self.matchtime = ::std::option::Option::None;
    }

    pub fn has_matchtime(&self) -> bool {
        self.matchtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchtime(&mut self, v: u32) {
        self.matchtime = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchid",
            |m: &CDataGCCStrike15_v2_MatchInfo| { &m.matchid },
            |m: &mut CDataGCCStrike15_v2_MatchInfo| { &mut m.matchid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "matchtime",
            |m: &CDataGCCStrike15_v2_MatchInfo| { &m.matchtime },
            |m: &mut CDataGCCStrike15_v2_MatchInfo| { &mut m.matchtime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, WatchableMatchInfo>(
            "watchablematchinfo",
            |m: &CDataGCCStrike15_v2_MatchInfo| { &m.watchablematchinfo },
            |m: &mut CDataGCCStrike15_v2_MatchInfo| { &mut m.watchablematchinfo },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CMsgGCCStrike15_v2_MatchmakingServerRoundStats>(
            "roundstats_legacy",
            |m: &CDataGCCStrike15_v2_MatchInfo| { &m.roundstats_legacy },
            |m: &mut CDataGCCStrike15_v2_MatchInfo| { &mut m.roundstats_legacy },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "roundstatsall",
            |m: &CDataGCCStrike15_v2_MatchInfo| { &m.roundstatsall },
            |m: &mut CDataGCCStrike15_v2_MatchInfo| { &mut m.roundstatsall },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDataGCCStrike15_v2_MatchInfo>(
            "CDataGCCStrike15_v2_MatchInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_MatchInfo {
    const NAME: &'static str = "CDataGCCStrike15_v2_MatchInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.matchid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.matchtime = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.watchablematchinfo)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.roundstats_legacy)?;
                },
                42 => {
                    self.roundstatsall.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.matchid {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.matchtime {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.watchablematchinfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.roundstats_legacy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.roundstatsall {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.matchid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.matchtime {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.watchablematchinfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.roundstats_legacy.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.roundstatsall {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDataGCCStrike15_v2_MatchInfo {
        CDataGCCStrike15_v2_MatchInfo::new()
    }

    fn clear(&mut self) {
        self.matchid = ::std::option::Option::None;
        self.matchtime = ::std::option::Option::None;
        self.watchablematchinfo.clear();
        self.roundstats_legacy.clear();
        self.roundstatsall.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_MatchInfo {
        static instance: CDataGCCStrike15_v2_MatchInfo = CDataGCCStrike15_v2_MatchInfo {
            matchid: ::std::option::Option::None,
            matchtime: ::std::option::Option::None,
            watchablematchinfo: ::protobuf::MessageField::none(),
            roundstats_legacy: ::protobuf::MessageField::none(),
            roundstatsall: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDataGCCStrike15_v2_MatchInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDataGCCStrike15_v2_MatchInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDataGCCStrike15_v2_MatchInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_MatchInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CDataGCCStrike15_v2_TournamentGroupTeam)
pub struct CDataGCCStrike15_v2_TournamentGroupTeam {
    // message fields
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroupTeam.team_id)
    pub team_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroupTeam.score)
    pub score: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroupTeam.correctpick)
    pub correctpick: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CDataGCCStrike15_v2_TournamentGroupTeam.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_TournamentGroupTeam {
    fn default() -> &'a CDataGCCStrike15_v2_TournamentGroupTeam {
        <CDataGCCStrike15_v2_TournamentGroupTeam as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_TournamentGroupTeam {
    pub fn new() -> CDataGCCStrike15_v2_TournamentGroupTeam {
        ::std::default::Default::default()
    }

    // optional int32 team_id = 1;

    pub fn team_id(&self) -> i32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: i32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional int32 score = 2;

    pub fn score(&self) -> i32 {
        self.score.unwrap_or(0)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: i32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional bool correctpick = 3;

    pub fn correctpick(&self) -> bool {
        self.correctpick.unwrap_or(false)
    }

    pub fn clear_correctpick(&mut self) {
        self.correctpick = ::std::option::Option::None;
    }

    pub fn has_correctpick(&self) -> bool {
        self.correctpick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_correctpick(&mut self, v: bool) {
        self.correctpick = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "team_id",
            |m: &CDataGCCStrike15_v2_TournamentGroupTeam| { &m.team_id },
            |m: &mut CDataGCCStrike15_v2_TournamentGroupTeam| { &mut m.team_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "score",
            |m: &CDataGCCStrike15_v2_TournamentGroupTeam| { &m.score },
            |m: &mut CDataGCCStrike15_v2_TournamentGroupTeam| { &mut m.score },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "correctpick",
            |m: &CDataGCCStrike15_v2_TournamentGroupTeam| { &m.correctpick },
            |m: &mut CDataGCCStrike15_v2_TournamentGroupTeam| { &mut m.correctpick },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDataGCCStrike15_v2_TournamentGroupTeam>(
            "CDataGCCStrike15_v2_TournamentGroupTeam",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentGroupTeam {
    const NAME: &'static str = "CDataGCCStrike15_v2_TournamentGroupTeam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.score = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.correctpick = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.score {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.correctpick {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.team_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.score {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.correctpick {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDataGCCStrike15_v2_TournamentGroupTeam {
        CDataGCCStrike15_v2_TournamentGroupTeam::new()
    }

    fn clear(&mut self) {
        self.team_id = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.correctpick = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentGroupTeam {
        static instance: CDataGCCStrike15_v2_TournamentGroupTeam = CDataGCCStrike15_v2_TournamentGroupTeam {
            team_id: ::std::option::Option::None,
            score: ::std::option::Option::None,
            correctpick: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDataGCCStrike15_v2_TournamentGroupTeam {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDataGCCStrike15_v2_TournamentGroupTeam").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDataGCCStrike15_v2_TournamentGroupTeam {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentGroupTeam {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CDataGCCStrike15_v2_TournamentGroup)
pub struct CDataGCCStrike15_v2_TournamentGroup {
    // message fields
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.groupid)
    pub groupid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.desc)
    pub desc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.picks__deprecated)
    pub picks__deprecated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.teams)
    pub teams: ::std::vec::Vec<CDataGCCStrike15_v2_TournamentGroupTeam>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.stage_ids)
    pub stage_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.picklockuntiltime)
    pub picklockuntiltime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.pickableteams)
    pub pickableteams: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.points_per_pick)
    pub points_per_pick: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.picks)
    pub picks: ::std::vec::Vec<cdata_gccstrike15_v2_tournament_group::Picks>,
    // special fields
    // @@protoc_insertion_point(special_field:CDataGCCStrike15_v2_TournamentGroup.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_TournamentGroup {
    fn default() -> &'a CDataGCCStrike15_v2_TournamentGroup {
        <CDataGCCStrike15_v2_TournamentGroup as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_TournamentGroup {
    pub fn new() -> CDataGCCStrike15_v2_TournamentGroup {
        ::std::default::Default::default()
    }

    // optional uint32 groupid = 1;

    pub fn groupid(&self) -> u32 {
        self.groupid.unwrap_or(0)
    }

    pub fn clear_groupid(&mut self) {
        self.groupid = ::std::option::Option::None;
    }

    pub fn has_groupid(&self) -> bool {
        self.groupid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupid(&mut self, v: u32) {
        self.groupid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc = 3;

    pub fn desc(&self) -> &str {
        match self.desc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_desc(&mut self) {
        self.desc = ::std::option::Option::None;
    }

    pub fn has_desc(&self) -> bool {
        self.desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: ::std::string::String) {
        self.desc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut ::std::string::String {
        if self.desc.is_none() {
            self.desc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc(&mut self) -> ::std::string::String {
        self.desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 picks__deprecated = 4;

    pub fn picks__deprecated(&self) -> u32 {
        self.picks__deprecated.unwrap_or(0)
    }

    pub fn clear_picks__deprecated(&mut self) {
        self.picks__deprecated = ::std::option::Option::None;
    }

    pub fn has_picks__deprecated(&self) -> bool {
        self.picks__deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_picks__deprecated(&mut self, v: u32) {
        self.picks__deprecated = ::std::option::Option::Some(v);
    }

    // optional uint32 picklockuntiltime = 7;

    pub fn picklockuntiltime(&self) -> u32 {
        self.picklockuntiltime.unwrap_or(0)
    }

    pub fn clear_picklockuntiltime(&mut self) {
        self.picklockuntiltime = ::std::option::Option::None;
    }

    pub fn has_picklockuntiltime(&self) -> bool {
        self.picklockuntiltime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_picklockuntiltime(&mut self, v: u32) {
        self.picklockuntiltime = ::std::option::Option::Some(v);
    }

    // optional uint32 pickableteams = 8;

    pub fn pickableteams(&self) -> u32 {
        self.pickableteams.unwrap_or(0)
    }

    pub fn clear_pickableteams(&mut self) {
        self.pickableteams = ::std::option::Option::None;
    }

    pub fn has_pickableteams(&self) -> bool {
        self.pickableteams.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pickableteams(&mut self, v: u32) {
        self.pickableteams = ::std::option::Option::Some(v);
    }

    // optional uint32 points_per_pick = 9;

    pub fn points_per_pick(&self) -> u32 {
        self.points_per_pick.unwrap_or(0)
    }

    pub fn clear_points_per_pick(&mut self) {
        self.points_per_pick = ::std::option::Option::None;
    }

    pub fn has_points_per_pick(&self) -> bool {
        self.points_per_pick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_per_pick(&mut self, v: u32) {
        self.points_per_pick = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "groupid",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.groupid },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.groupid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.name },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desc",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.desc },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.desc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "picks__deprecated",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.picks__deprecated },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.picks__deprecated },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "teams",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.teams },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.teams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "stage_ids",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.stage_ids },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.stage_ids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "picklockuntiltime",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.picklockuntiltime },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.picklockuntiltime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pickableteams",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.pickableteams },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.pickableteams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "points_per_pick",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.points_per_pick },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.points_per_pick },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "picks",
            |m: &CDataGCCStrike15_v2_TournamentGroup| { &m.picks },
            |m: &mut CDataGCCStrike15_v2_TournamentGroup| { &mut m.picks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDataGCCStrike15_v2_TournamentGroup>(
            "CDataGCCStrike15_v2_TournamentGroup",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentGroup {
    const NAME: &'static str = "CDataGCCStrike15_v2_TournamentGroup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.groupid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.desc = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.picks__deprecated = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.teams.push(is.read_message()?);
                },
                50 => {
                    is.read_repeated_packed_int32_into(&mut self.stage_ids)?;
                },
                48 => {
                    self.stage_ids.push(is.read_int32()?);
                },
                56 => {
                    self.picklockuntiltime = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.pickableteams = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.points_per_pick = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.picks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.groupid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.desc.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.picks__deprecated {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.stage_ids {
            my_size += ::protobuf::rt::int32_size(6, *value);
        };
        if let Some(v) = self.picklockuntiltime {
            my_size += ::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.pickableteams {
            my_size += ::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.points_per_pick {
            my_size += ::protobuf::rt::uint32_size(9, v);
        }
        for value in &self.picks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.groupid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.desc.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.picks__deprecated {
            os.write_uint32(4, v)?;
        }
        for v in &self.teams {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.stage_ids {
            os.write_int32(6, *v)?;
        };
        if let Some(v) = self.picklockuntiltime {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.pickableteams {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.points_per_pick {
            os.write_uint32(9, v)?;
        }
        for v in &self.picks {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDataGCCStrike15_v2_TournamentGroup {
        CDataGCCStrike15_v2_TournamentGroup::new()
    }

    fn clear(&mut self) {
        self.groupid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.desc = ::std::option::Option::None;
        self.picks__deprecated = ::std::option::Option::None;
        self.teams.clear();
        self.stage_ids.clear();
        self.picklockuntiltime = ::std::option::Option::None;
        self.pickableteams = ::std::option::Option::None;
        self.points_per_pick = ::std::option::Option::None;
        self.picks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentGroup {
        static instance: CDataGCCStrike15_v2_TournamentGroup = CDataGCCStrike15_v2_TournamentGroup {
            groupid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            desc: ::std::option::Option::None,
            picks__deprecated: ::std::option::Option::None,
            teams: ::std::vec::Vec::new(),
            stage_ids: ::std::vec::Vec::new(),
            picklockuntiltime: ::std::option::Option::None,
            pickableteams: ::std::option::Option::None,
            points_per_pick: ::std::option::Option::None,
            picks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDataGCCStrike15_v2_TournamentGroup {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDataGCCStrike15_v2_TournamentGroup").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDataGCCStrike15_v2_TournamentGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentGroup {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CDataGCCStrike15_v2_TournamentGroup`
pub mod cdata_gccstrike15_v2_tournament_group {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CDataGCCStrike15_v2_TournamentGroup.Picks)
    pub struct Picks {
        // message fields
        // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentGroup.Picks.pickids)
        pub pickids: ::std::vec::Vec<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CDataGCCStrike15_v2_TournamentGroup.Picks.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Picks {
        fn default() -> &'a Picks {
            <Picks as ::protobuf::Message>::default_instance()
        }
    }

    impl Picks {
        pub fn new() -> Picks {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(1);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "pickids",
                |m: &Picks| { &m.pickids },
                |m: &mut Picks| { &mut m.pickids },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Picks>(
                "CDataGCCStrike15_v2_TournamentGroup.Picks",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Picks {
        const NAME: &'static str = "Picks";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int32_into(&mut self.pickids)?;
                    },
                    8 => {
                        self.pickids.push(is.read_int32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.pickids {
                my_size += ::protobuf::rt::int32_size(1, *value);
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            for v in &self.pickids {
                os.write_int32(1, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Picks {
            Picks::new()
        }

        fn clear(&mut self) {
            self.pickids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Picks {
            static instance: Picks = Picks {
                pickids: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Picks {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CDataGCCStrike15_v2_TournamentGroup.Picks").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Picks {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Picks {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CDataGCCStrike15_v2_TournamentSection)
pub struct CDataGCCStrike15_v2_TournamentSection {
    // message fields
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentSection.sectionid)
    pub sectionid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentSection.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentSection.desc)
    pub desc: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentSection.groups)
    pub groups: ::std::vec::Vec<CDataGCCStrike15_v2_TournamentGroup>,
    // special fields
    // @@protoc_insertion_point(special_field:CDataGCCStrike15_v2_TournamentSection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_TournamentSection {
    fn default() -> &'a CDataGCCStrike15_v2_TournamentSection {
        <CDataGCCStrike15_v2_TournamentSection as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_TournamentSection {
    pub fn new() -> CDataGCCStrike15_v2_TournamentSection {
        ::std::default::Default::default()
    }

    // optional uint32 sectionid = 1;

    pub fn sectionid(&self) -> u32 {
        self.sectionid.unwrap_or(0)
    }

    pub fn clear_sectionid(&mut self) {
        self.sectionid = ::std::option::Option::None;
    }

    pub fn has_sectionid(&self) -> bool {
        self.sectionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sectionid(&mut self, v: u32) {
        self.sectionid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string desc = 3;

    pub fn desc(&self) -> &str {
        match self.desc.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_desc(&mut self) {
        self.desc = ::std::option::Option::None;
    }

    pub fn has_desc(&self) -> bool {
        self.desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: ::std::string::String) {
        self.desc = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut ::std::string::String {
        if self.desc.is_none() {
            self.desc = ::std::option::Option::Some(::std::string::String::new());
        }
        self.desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc(&mut self) -> ::std::string::String {
        self.desc.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "sectionid",
            |m: &CDataGCCStrike15_v2_TournamentSection| { &m.sectionid },
            |m: &mut CDataGCCStrike15_v2_TournamentSection| { &mut m.sectionid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &CDataGCCStrike15_v2_TournamentSection| { &m.name },
            |m: &mut CDataGCCStrike15_v2_TournamentSection| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "desc",
            |m: &CDataGCCStrike15_v2_TournamentSection| { &m.desc },
            |m: &mut CDataGCCStrike15_v2_TournamentSection| { &mut m.desc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "groups",
            |m: &CDataGCCStrike15_v2_TournamentSection| { &m.groups },
            |m: &mut CDataGCCStrike15_v2_TournamentSection| { &mut m.groups },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDataGCCStrike15_v2_TournamentSection>(
            "CDataGCCStrike15_v2_TournamentSection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentSection {
    const NAME: &'static str = "CDataGCCStrike15_v2_TournamentSection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sectionid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.desc = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.groups.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sectionid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.desc.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.sectionid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.desc.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.groups {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDataGCCStrike15_v2_TournamentSection {
        CDataGCCStrike15_v2_TournamentSection::new()
    }

    fn clear(&mut self) {
        self.sectionid = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.desc = ::std::option::Option::None;
        self.groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentSection {
        static instance: CDataGCCStrike15_v2_TournamentSection = CDataGCCStrike15_v2_TournamentSection {
            sectionid: ::std::option::Option::None,
            name: ::std::option::Option::None,
            desc: ::std::option::Option::None,
            groups: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDataGCCStrike15_v2_TournamentSection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDataGCCStrike15_v2_TournamentSection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDataGCCStrike15_v2_TournamentSection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentSection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CDataGCCStrike15_v2_TournamentInfo)
pub struct CDataGCCStrike15_v2_TournamentInfo {
    // message fields
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentInfo.sections)
    pub sections: ::std::vec::Vec<CDataGCCStrike15_v2_TournamentSection>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentInfo.tournament_event)
    pub tournament_event: ::protobuf::MessageField<TournamentEvent>,
    // @@protoc_insertion_point(field:CDataGCCStrike15_v2_TournamentInfo.tournament_teams)
    pub tournament_teams: ::std::vec::Vec<TournamentTeam>,
    // special fields
    // @@protoc_insertion_point(special_field:CDataGCCStrike15_v2_TournamentInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CDataGCCStrike15_v2_TournamentInfo {
    fn default() -> &'a CDataGCCStrike15_v2_TournamentInfo {
        <CDataGCCStrike15_v2_TournamentInfo as ::protobuf::Message>::default_instance()
    }
}

impl CDataGCCStrike15_v2_TournamentInfo {
    pub fn new() -> CDataGCCStrike15_v2_TournamentInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "sections",
            |m: &CDataGCCStrike15_v2_TournamentInfo| { &m.sections },
            |m: &mut CDataGCCStrike15_v2_TournamentInfo| { &mut m.sections },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TournamentEvent>(
            "tournament_event",
            |m: &CDataGCCStrike15_v2_TournamentInfo| { &m.tournament_event },
            |m: &mut CDataGCCStrike15_v2_TournamentInfo| { &mut m.tournament_event },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tournament_teams",
            |m: &CDataGCCStrike15_v2_TournamentInfo| { &m.tournament_teams },
            |m: &mut CDataGCCStrike15_v2_TournamentInfo| { &mut m.tournament_teams },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CDataGCCStrike15_v2_TournamentInfo>(
            "CDataGCCStrike15_v2_TournamentInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CDataGCCStrike15_v2_TournamentInfo {
    const NAME: &'static str = "CDataGCCStrike15_v2_TournamentInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sections.push(is.read_message()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tournament_event)?;
                },
                26 => {
                    self.tournament_teams.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tournament_event.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tournament_teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.sections {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.tournament_event.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.tournament_teams {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CDataGCCStrike15_v2_TournamentInfo {
        CDataGCCStrike15_v2_TournamentInfo::new()
    }

    fn clear(&mut self) {
        self.sections.clear();
        self.tournament_event.clear();
        self.tournament_teams.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CDataGCCStrike15_v2_TournamentInfo {
        static instance: CDataGCCStrike15_v2_TournamentInfo = CDataGCCStrike15_v2_TournamentInfo {
            sections: ::std::vec::Vec::new(),
            tournament_event: ::protobuf::MessageField::none(),
            tournament_teams: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CDataGCCStrike15_v2_TournamentInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CDataGCCStrike15_v2_TournamentInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CDataGCCStrike15_v2_TournamentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CDataGCCStrike15_v2_TournamentInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_MatchList)
pub struct CMsgGCCStrike15_v2_MatchList {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchList.msgrequestid)
    pub msgrequestid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchList.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchList.servertime)
    pub servertime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchList.matches)
    pub matches: ::std::vec::Vec<CDataGCCStrike15_v2_MatchInfo>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchList.streams)
    pub streams: ::std::vec::Vec<TournamentTeam>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_MatchList.tournamentinfo)
    pub tournamentinfo: ::protobuf::MessageField<CDataGCCStrike15_v2_TournamentInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_MatchList.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_MatchList {
    fn default() -> &'a CMsgGCCStrike15_v2_MatchList {
        <CMsgGCCStrike15_v2_MatchList as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_MatchList {
    pub fn new() -> CMsgGCCStrike15_v2_MatchList {
        ::std::default::Default::default()
    }

    // optional uint32 msgrequestid = 1;

    pub fn msgrequestid(&self) -> u32 {
        self.msgrequestid.unwrap_or(0)
    }

    pub fn clear_msgrequestid(&mut self) {
        self.msgrequestid = ::std::option::Option::None;
    }

    pub fn has_msgrequestid(&self) -> bool {
        self.msgrequestid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgrequestid(&mut self, v: u32) {
        self.msgrequestid = ::std::option::Option::Some(v);
    }

    // optional uint32 accountid = 2;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 servertime = 3;

    pub fn servertime(&self) -> u32 {
        self.servertime.unwrap_or(0)
    }

    pub fn clear_servertime(&mut self) {
        self.servertime = ::std::option::Option::None;
    }

    pub fn has_servertime(&self) -> bool {
        self.servertime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servertime(&mut self, v: u32) {
        self.servertime = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msgrequestid",
            |m: &CMsgGCCStrike15_v2_MatchList| { &m.msgrequestid },
            |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.msgrequestid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CMsgGCCStrike15_v2_MatchList| { &m.accountid },
            |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "servertime",
            |m: &CMsgGCCStrike15_v2_MatchList| { &m.servertime },
            |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.servertime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "matches",
            |m: &CMsgGCCStrike15_v2_MatchList| { &m.matches },
            |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.matches },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "streams",
            |m: &CMsgGCCStrike15_v2_MatchList| { &m.streams },
            |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.streams },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, CDataGCCStrike15_v2_TournamentInfo>(
            "tournamentinfo",
            |m: &CMsgGCCStrike15_v2_MatchList| { &m.tournamentinfo },
            |m: &mut CMsgGCCStrike15_v2_MatchList| { &mut m.tournamentinfo },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_MatchList>(
            "CMsgGCCStrike15_v2_MatchList",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_MatchList {
    const NAME: &'static str = "CMsgGCCStrike15_v2_MatchList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msgrequestid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.servertime = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.matches.push(is.read_message()?);
                },
                42 => {
                    self.streams.push(is.read_message()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tournamentinfo)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msgrequestid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.servertime {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.streams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tournamentinfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.msgrequestid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.accountid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.servertime {
            os.write_uint32(3, v)?;
        }
        for v in &self.matches {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.streams {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.tournamentinfo.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_MatchList {
        CMsgGCCStrike15_v2_MatchList::new()
    }

    fn clear(&mut self) {
        self.msgrequestid = ::std::option::Option::None;
        self.accountid = ::std::option::Option::None;
        self.servertime = ::std::option::Option::None;
        self.matches.clear();
        self.streams.clear();
        self.tournamentinfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_MatchList {
        static instance: CMsgGCCStrike15_v2_MatchList = CMsgGCCStrike15_v2_MatchList {
            msgrequestid: ::std::option::Option::None,
            accountid: ::std::option::Option::None,
            servertime: ::std::option::Option::None,
            matches: ::std::vec::Vec::new(),
            streams: ::std::vec::Vec::new(),
            tournamentinfo: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_MatchList {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_MatchList").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_MatchList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_MatchList {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Predictions)
pub struct CMsgGCCStrike15_v2_Predictions {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Predictions.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Predictions.group_match_team_picks)
    pub group_match_team_picks: ::std::vec::Vec<cmsg_gccstrike15_v2_predictions::GroupMatchTeamPick>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Predictions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Predictions {
    fn default() -> &'a CMsgGCCStrike15_v2_Predictions {
        <CMsgGCCStrike15_v2_Predictions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Predictions {
    pub fn new() -> CMsgGCCStrike15_v2_Predictions {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgGCCStrike15_v2_Predictions| { &m.event_id },
            |m: &mut CMsgGCCStrike15_v2_Predictions| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "group_match_team_picks",
            |m: &CMsgGCCStrike15_v2_Predictions| { &m.group_match_team_picks },
            |m: &mut CMsgGCCStrike15_v2_Predictions| { &mut m.group_match_team_picks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Predictions>(
            "CMsgGCCStrike15_v2_Predictions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Predictions {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Predictions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.group_match_team_picks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.group_match_team_picks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.group_match_team_picks {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Predictions {
        CMsgGCCStrike15_v2_Predictions::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.group_match_team_picks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Predictions {
        static instance: CMsgGCCStrike15_v2_Predictions = CMsgGCCStrike15_v2_Predictions {
            event_id: ::std::option::Option::None,
            group_match_team_picks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Predictions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Predictions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Predictions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Predictions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCCStrike15_v2_Predictions`
pub mod cmsg_gccstrike15_v2_predictions {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick)
    pub struct GroupMatchTeamPick {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick.sectionid)
        pub sectionid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick.groupid)
        pub groupid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick.index)
        pub index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick.teamid)
        pub teamid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick.itemid)
        pub itemid: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GroupMatchTeamPick {
        fn default() -> &'a GroupMatchTeamPick {
            <GroupMatchTeamPick as ::protobuf::Message>::default_instance()
        }
    }

    impl GroupMatchTeamPick {
        pub fn new() -> GroupMatchTeamPick {
            ::std::default::Default::default()
        }

        // optional int32 sectionid = 1;

        pub fn sectionid(&self) -> i32 {
            self.sectionid.unwrap_or(0)
        }

        pub fn clear_sectionid(&mut self) {
            self.sectionid = ::std::option::Option::None;
        }

        pub fn has_sectionid(&self) -> bool {
            self.sectionid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sectionid(&mut self, v: i32) {
            self.sectionid = ::std::option::Option::Some(v);
        }

        // optional int32 groupid = 2;

        pub fn groupid(&self) -> i32 {
            self.groupid.unwrap_or(0)
        }

        pub fn clear_groupid(&mut self) {
            self.groupid = ::std::option::Option::None;
        }

        pub fn has_groupid(&self) -> bool {
            self.groupid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_groupid(&mut self, v: i32) {
            self.groupid = ::std::option::Option::Some(v);
        }

        // optional int32 index = 3;

        pub fn index(&self) -> i32 {
            self.index.unwrap_or(0)
        }

        pub fn clear_index(&mut self) {
            self.index = ::std::option::Option::None;
        }

        pub fn has_index(&self) -> bool {
            self.index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_index(&mut self, v: i32) {
            self.index = ::std::option::Option::Some(v);
        }

        // optional int32 teamid = 4;

        pub fn teamid(&self) -> i32 {
            self.teamid.unwrap_or(0)
        }

        pub fn clear_teamid(&mut self) {
            self.teamid = ::std::option::Option::None;
        }

        pub fn has_teamid(&self) -> bool {
            self.teamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_teamid(&mut self, v: i32) {
            self.teamid = ::std::option::Option::Some(v);
        }

        // optional uint64 itemid = 5;

        pub fn itemid(&self) -> u64 {
            self.itemid.unwrap_or(0)
        }

        pub fn clear_itemid(&mut self) {
            self.itemid = ::std::option::Option::None;
        }

        pub fn has_itemid(&self) -> bool {
            self.itemid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_itemid(&mut self, v: u64) {
            self.itemid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sectionid",
                |m: &GroupMatchTeamPick| { &m.sectionid },
                |m: &mut GroupMatchTeamPick| { &mut m.sectionid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "groupid",
                |m: &GroupMatchTeamPick| { &m.groupid },
                |m: &mut GroupMatchTeamPick| { &mut m.groupid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "index",
                |m: &GroupMatchTeamPick| { &m.index },
                |m: &mut GroupMatchTeamPick| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "teamid",
                |m: &GroupMatchTeamPick| { &m.teamid },
                |m: &mut GroupMatchTeamPick| { &mut m.teamid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "itemid",
                |m: &GroupMatchTeamPick| { &m.itemid },
                |m: &mut GroupMatchTeamPick| { &mut m.itemid },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GroupMatchTeamPick>(
                "CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GroupMatchTeamPick {
        const NAME: &'static str = "GroupMatchTeamPick";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.sectionid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.groupid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.teamid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.itemid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.sectionid {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.groupid {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.index {
                my_size += ::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.teamid {
                my_size += ::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.itemid {
                my_size += ::protobuf::rt::uint64_size(5, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.sectionid {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.groupid {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.index {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.teamid {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.itemid {
                os.write_uint64(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GroupMatchTeamPick {
            GroupMatchTeamPick::new()
        }

        fn clear(&mut self) {
            self.sectionid = ::std::option::Option::None;
            self.groupid = ::std::option::Option::None;
            self.index = ::std::option::Option::None;
            self.teamid = ::std::option::Option::None;
            self.itemid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GroupMatchTeamPick {
            static instance: GroupMatchTeamPick = GroupMatchTeamPick {
                sectionid: ::std::option::Option::None,
                groupid: ::std::option::Option::None,
                index: ::std::option::Option::None,
                teamid: ::std::option::Option::None,
                itemid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GroupMatchTeamPick {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GroupMatchTeamPick {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GroupMatchTeamPick {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Fantasy)
pub struct CMsgGCCStrike15_v2_Fantasy {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Fantasy.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Fantasy.teams)
    pub teams: ::std::vec::Vec<cmsg_gccstrike15_v2_fantasy::FantasyTeam>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Fantasy.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Fantasy {
    fn default() -> &'a CMsgGCCStrike15_v2_Fantasy {
        <CMsgGCCStrike15_v2_Fantasy as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Fantasy {
    pub fn new() -> CMsgGCCStrike15_v2_Fantasy {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "event_id",
            |m: &CMsgGCCStrike15_v2_Fantasy| { &m.event_id },
            |m: &mut CMsgGCCStrike15_v2_Fantasy| { &mut m.event_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "teams",
            |m: &CMsgGCCStrike15_v2_Fantasy| { &m.teams },
            |m: &mut CMsgGCCStrike15_v2_Fantasy| { &mut m.teams },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Fantasy>(
            "CMsgGCCStrike15_v2_Fantasy",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Fantasy {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Fantasy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.teams.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.teams {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Fantasy {
        CMsgGCCStrike15_v2_Fantasy::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.teams.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Fantasy {
        static instance: CMsgGCCStrike15_v2_Fantasy = CMsgGCCStrike15_v2_Fantasy {
            event_id: ::std::option::Option::None,
            teams: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Fantasy {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Fantasy").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Fantasy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Fantasy {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCCStrike15_v2_Fantasy`
pub mod cmsg_gccstrike15_v2_fantasy {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Fantasy.FantasySlot)
    pub struct FantasySlot {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Fantasy.FantasySlot.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Fantasy.FantasySlot.pick)
        pub pick: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Fantasy.FantasySlot.itemid)
        pub itemid: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Fantasy.FantasySlot.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FantasySlot {
        fn default() -> &'a FantasySlot {
            <FantasySlot as ::protobuf::Message>::default_instance()
        }
    }

    impl FantasySlot {
        pub fn new() -> FantasySlot {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional int32 pick = 2;

        pub fn pick(&self) -> i32 {
            self.pick.unwrap_or(0)
        }

        pub fn clear_pick(&mut self) {
            self.pick = ::std::option::Option::None;
        }

        pub fn has_pick(&self) -> bool {
            self.pick.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pick(&mut self, v: i32) {
            self.pick = ::std::option::Option::Some(v);
        }

        // optional uint64 itemid = 3;

        pub fn itemid(&self) -> u64 {
            self.itemid.unwrap_or(0)
        }

        pub fn clear_itemid(&mut self) {
            self.itemid = ::std::option::Option::None;
        }

        pub fn has_itemid(&self) -> bool {
            self.itemid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_itemid(&mut self, v: u64) {
            self.itemid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "type",
                |m: &FantasySlot| { &m.type_ },
                |m: &mut FantasySlot| { &mut m.type_ },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "pick",
                |m: &FantasySlot| { &m.pick },
                |m: &mut FantasySlot| { &mut m.pick },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "itemid",
                |m: &FantasySlot| { &m.itemid },
                |m: &mut FantasySlot| { &mut m.itemid },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FantasySlot>(
                "CMsgGCCStrike15_v2_Fantasy.FantasySlot",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FantasySlot {
        const NAME: &'static str = "FantasySlot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.pick = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.itemid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.pick {
                my_size += ::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.itemid {
                my_size += ::protobuf::rt::uint64_size(3, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.pick {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.itemid {
                os.write_uint64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FantasySlot {
            FantasySlot::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.pick = ::std::option::Option::None;
            self.itemid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FantasySlot {
            static instance: FantasySlot = FantasySlot {
                type_: ::std::option::Option::None,
                pick: ::std::option::Option::None,
                itemid: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FantasySlot {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Fantasy.FantasySlot").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FantasySlot {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FantasySlot {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Fantasy.FantasyTeam)
    pub struct FantasyTeam {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Fantasy.FantasyTeam.sectionid)
        pub sectionid: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Fantasy.FantasyTeam.slots)
        pub slots: ::std::vec::Vec<FantasySlot>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Fantasy.FantasyTeam.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FantasyTeam {
        fn default() -> &'a FantasyTeam {
            <FantasyTeam as ::protobuf::Message>::default_instance()
        }
    }

    impl FantasyTeam {
        pub fn new() -> FantasyTeam {
            ::std::default::Default::default()
        }

        // optional int32 sectionid = 1;

        pub fn sectionid(&self) -> i32 {
            self.sectionid.unwrap_or(0)
        }

        pub fn clear_sectionid(&mut self) {
            self.sectionid = ::std::option::Option::None;
        }

        pub fn has_sectionid(&self) -> bool {
            self.sectionid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sectionid(&mut self, v: i32) {
            self.sectionid = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "sectionid",
                |m: &FantasyTeam| { &m.sectionid },
                |m: &mut FantasyTeam| { &mut m.sectionid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "slots",
                |m: &FantasyTeam| { &m.slots },
                |m: &mut FantasyTeam| { &mut m.slots },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FantasyTeam>(
                "CMsgGCCStrike15_v2_Fantasy.FantasyTeam",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for FantasyTeam {
        const NAME: &'static str = "FantasyTeam";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.sectionid = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.slots.push(is.read_message()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.sectionid {
                my_size += ::protobuf::rt::int32_size(1, v);
            }
            for value in &self.slots {
                let len = value.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.sectionid {
                os.write_int32(1, v)?;
            }
            for v in &self.slots {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FantasyTeam {
            FantasyTeam::new()
        }

        fn clear(&mut self) {
            self.sectionid = ::std::option::Option::None;
            self.slots.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FantasyTeam {
            static instance: FantasyTeam = FantasyTeam {
                sectionid: ::std::option::Option::None,
                slots: ::std::vec::Vec::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for FantasyTeam {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Fantasy.FantasyTeam").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for FantasyTeam {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for FantasyTeam {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CAttribute_String)
pub struct CAttribute_String {
    // message fields
    // @@protoc_insertion_point(field:CAttribute_String.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CAttribute_String.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAttribute_String {
    fn default() -> &'a CAttribute_String {
        <CAttribute_String as ::protobuf::Message>::default_instance()
    }
}

impl CAttribute_String {
    pub fn new() -> CAttribute_String {
        ::std::default::Default::default()
    }

    // optional string value = 1;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value",
            |m: &CAttribute_String| { &m.value },
            |m: &mut CAttribute_String| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CAttribute_String>(
            "CAttribute_String",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CAttribute_String {
    const NAME: &'static str = "CAttribute_String";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.value.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAttribute_String {
        CAttribute_String::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAttribute_String {
        static instance: CAttribute_String = CAttribute_String {
            value: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CAttribute_String {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CAttribute_String").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CAttribute_String {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CAttribute_String {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCToGCReloadVersions)
pub struct CMsgGCToGCReloadVersions {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCReloadVersions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCReloadVersions {
    fn default() -> &'a CMsgGCToGCReloadVersions {
        <CMsgGCToGCReloadVersions as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCReloadVersions {
    pub fn new() -> CMsgGCToGCReloadVersions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCToGCReloadVersions>(
            "CMsgGCToGCReloadVersions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCToGCReloadVersions {
    const NAME: &'static str = "CMsgGCToGCReloadVersions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCReloadVersions {
        CMsgGCToGCReloadVersions::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCReloadVersions {
        static instance: CMsgGCToGCReloadVersions = CMsgGCToGCReloadVersions {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCToGCReloadVersions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCToGCReloadVersions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCToGCReloadVersions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCToGCReloadVersions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgCStrike15Welcome)
pub struct CMsgCStrike15Welcome {
    // message fields
    // @@protoc_insertion_point(field:CMsgCStrike15Welcome.store_item_hash)
    pub store_item_hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCStrike15Welcome.timeplayedconsecutively)
    pub timeplayedconsecutively: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCStrike15Welcome.time_first_played)
    pub time_first_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCStrike15Welcome.last_time_played)
    pub last_time_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCStrike15Welcome.last_ip_address)
    pub last_ip_address: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCStrike15Welcome.gscookieid)
    pub gscookieid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgCStrike15Welcome.uniqueid)
    pub uniqueid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCStrike15Welcome.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCStrike15Welcome {
    fn default() -> &'a CMsgCStrike15Welcome {
        <CMsgCStrike15Welcome as ::protobuf::Message>::default_instance()
    }
}

impl CMsgCStrike15Welcome {
    pub fn new() -> CMsgCStrike15Welcome {
        ::std::default::Default::default()
    }

    // optional uint32 store_item_hash = 5;

    pub fn store_item_hash(&self) -> u32 {
        self.store_item_hash.unwrap_or(0)
    }

    pub fn clear_store_item_hash(&mut self) {
        self.store_item_hash = ::std::option::Option::None;
    }

    pub fn has_store_item_hash(&self) -> bool {
        self.store_item_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_item_hash(&mut self, v: u32) {
        self.store_item_hash = ::std::option::Option::Some(v);
    }

    // optional uint32 timeplayedconsecutively = 6;

    pub fn timeplayedconsecutively(&self) -> u32 {
        self.timeplayedconsecutively.unwrap_or(0)
    }

    pub fn clear_timeplayedconsecutively(&mut self) {
        self.timeplayedconsecutively = ::std::option::Option::None;
    }

    pub fn has_timeplayedconsecutively(&self) -> bool {
        self.timeplayedconsecutively.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeplayedconsecutively(&mut self, v: u32) {
        self.timeplayedconsecutively = ::std::option::Option::Some(v);
    }

    // optional uint32 time_first_played = 10;

    pub fn time_first_played(&self) -> u32 {
        self.time_first_played.unwrap_or(0)
    }

    pub fn clear_time_first_played(&mut self) {
        self.time_first_played = ::std::option::Option::None;
    }

    pub fn has_time_first_played(&self) -> bool {
        self.time_first_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_first_played(&mut self, v: u32) {
        self.time_first_played = ::std::option::Option::Some(v);
    }

    // optional uint32 last_time_played = 12;

    pub fn last_time_played(&self) -> u32 {
        self.last_time_played.unwrap_or(0)
    }

    pub fn clear_last_time_played(&mut self) {
        self.last_time_played = ::std::option::Option::None;
    }

    pub fn has_last_time_played(&self) -> bool {
        self.last_time_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_time_played(&mut self, v: u32) {
        self.last_time_played = ::std::option::Option::Some(v);
    }

    // optional uint32 last_ip_address = 13;

    pub fn last_ip_address(&self) -> u32 {
        self.last_ip_address.unwrap_or(0)
    }

    pub fn clear_last_ip_address(&mut self) {
        self.last_ip_address = ::std::option::Option::None;
    }

    pub fn has_last_ip_address(&self) -> bool {
        self.last_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_ip_address(&mut self, v: u32) {
        self.last_ip_address = ::std::option::Option::Some(v);
    }

    // optional uint64 gscookieid = 18;

    pub fn gscookieid(&self) -> u64 {
        self.gscookieid.unwrap_or(0)
    }

    pub fn clear_gscookieid(&mut self) {
        self.gscookieid = ::std::option::Option::None;
    }

    pub fn has_gscookieid(&self) -> bool {
        self.gscookieid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gscookieid(&mut self, v: u64) {
        self.gscookieid = ::std::option::Option::Some(v);
    }

    // optional uint64 uniqueid = 19;

    pub fn uniqueid(&self) -> u64 {
        self.uniqueid.unwrap_or(0)
    }

    pub fn clear_uniqueid(&mut self) {
        self.uniqueid = ::std::option::Option::None;
    }

    pub fn has_uniqueid(&self) -> bool {
        self.uniqueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uniqueid(&mut self, v: u64) {
        self.uniqueid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "store_item_hash",
            |m: &CMsgCStrike15Welcome| { &m.store_item_hash },
            |m: &mut CMsgCStrike15Welcome| { &mut m.store_item_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeplayedconsecutively",
            |m: &CMsgCStrike15Welcome| { &m.timeplayedconsecutively },
            |m: &mut CMsgCStrike15Welcome| { &mut m.timeplayedconsecutively },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_first_played",
            |m: &CMsgCStrike15Welcome| { &m.time_first_played },
            |m: &mut CMsgCStrike15Welcome| { &mut m.time_first_played },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_time_played",
            |m: &CMsgCStrike15Welcome| { &m.last_time_played },
            |m: &mut CMsgCStrike15Welcome| { &mut m.last_time_played },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "last_ip_address",
            |m: &CMsgCStrike15Welcome| { &m.last_ip_address },
            |m: &mut CMsgCStrike15Welcome| { &mut m.last_ip_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gscookieid",
            |m: &CMsgCStrike15Welcome| { &m.gscookieid },
            |m: &mut CMsgCStrike15Welcome| { &mut m.gscookieid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "uniqueid",
            |m: &CMsgCStrike15Welcome| { &m.uniqueid },
            |m: &mut CMsgCStrike15Welcome| { &mut m.uniqueid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgCStrike15Welcome>(
            "CMsgCStrike15Welcome",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgCStrike15Welcome {
    const NAME: &'static str = "CMsgCStrike15Welcome";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                40 => {
                    self.store_item_hash = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.timeplayedconsecutively = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.time_first_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.last_time_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.last_ip_address = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.gscookieid = ::std::option::Option::Some(is.read_uint64()?);
                },
                152 => {
                    self.uniqueid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.store_item_hash {
            my_size += ::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.timeplayedconsecutively {
            my_size += ::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.time_first_played {
            my_size += ::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.last_time_played {
            my_size += ::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.last_ip_address {
            my_size += ::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.gscookieid {
            my_size += ::protobuf::rt::uint64_size(18, v);
        }
        if let Some(v) = self.uniqueid {
            my_size += ::protobuf::rt::uint64_size(19, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.store_item_hash {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.timeplayedconsecutively {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.time_first_played {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.last_time_played {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.last_ip_address {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.gscookieid {
            os.write_uint64(18, v)?;
        }
        if let Some(v) = self.uniqueid {
            os.write_uint64(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCStrike15Welcome {
        CMsgCStrike15Welcome::new()
    }

    fn clear(&mut self) {
        self.store_item_hash = ::std::option::Option::None;
        self.timeplayedconsecutively = ::std::option::Option::None;
        self.time_first_played = ::std::option::Option::None;
        self.last_time_played = ::std::option::Option::None;
        self.last_ip_address = ::std::option::Option::None;
        self.gscookieid = ::std::option::Option::None;
        self.uniqueid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCStrike15Welcome {
        static instance: CMsgCStrike15Welcome = CMsgCStrike15Welcome {
            store_item_hash: ::std::option::Option::None,
            timeplayedconsecutively: ::std::option::Option::None,
            time_first_played: ::std::option::Option::None,
            last_time_played: ::std::option::Option::None,
            last_ip_address: ::std::option::Option::None,
            gscookieid: ::std::option::Option::None,
            uniqueid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgCStrike15Welcome {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgCStrike15Welcome").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgCStrike15Welcome {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgCStrike15Welcome {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientVarValueNotificationInfo)
pub struct CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.value_name)
    pub value_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.value_int)
    pub value_int: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.server_addr)
    pub server_addr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.server_port)
    pub server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.choked_blocks)
    pub choked_blocks: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
        <CMsgGCCStrike15_v2_ClientVarValueNotificationInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    pub fn new() -> CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
        ::std::default::Default::default()
    }

    // optional string value_name = 1;

    pub fn value_name(&self) -> &str {
        match self.value_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value_name(&mut self) {
        self.value_name = ::std::option::Option::None;
    }

    pub fn has_value_name(&self) -> bool {
        self.value_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_name(&mut self, v: ::std::string::String) {
        self.value_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_name(&mut self) -> &mut ::std::string::String {
        if self.value_name.is_none() {
            self.value_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_name(&mut self) -> ::std::string::String {
        self.value_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 value_int = 2;

    pub fn value_int(&self) -> i32 {
        self.value_int.unwrap_or(0)
    }

    pub fn clear_value_int(&mut self) {
        self.value_int = ::std::option::Option::None;
    }

    pub fn has_value_int(&self) -> bool {
        self.value_int.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_int(&mut self, v: i32) {
        self.value_int = ::std::option::Option::Some(v);
    }

    // optional uint32 server_addr = 3;

    pub fn server_addr(&self) -> u32 {
        self.server_addr.unwrap_or(0)
    }

    pub fn clear_server_addr(&mut self) {
        self.server_addr = ::std::option::Option::None;
    }

    pub fn has_server_addr(&self) -> bool {
        self.server_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_addr(&mut self, v: u32) {
        self.server_addr = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 4;

    pub fn server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value_name",
            |m: &CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &m.value_name },
            |m: &mut CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &mut m.value_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "value_int",
            |m: &CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &m.value_int },
            |m: &mut CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &mut m.value_int },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_addr",
            |m: &CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &m.server_addr },
            |m: &mut CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &mut m.server_addr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_port",
            |m: &CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &m.server_port },
            |m: &mut CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &mut m.server_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "choked_blocks",
            |m: &CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &m.choked_blocks },
            |m: &mut CMsgGCCStrike15_v2_ClientVarValueNotificationInfo| { &mut m.choked_blocks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientVarValueNotificationInfo>(
            "CMsgGCCStrike15_v2_ClientVarValueNotificationInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientVarValueNotificationInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.value_int = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.server_addr = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.choked_blocks.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.value_int {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.server_addr {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.server_port {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.choked_blocks {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.value_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.value_int {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.server_addr {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(4, v)?;
        }
        for v in &self.choked_blocks {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
        CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::new()
    }

    fn clear(&mut self) {
        self.value_name = ::std::option::Option::None;
        self.value_int = ::std::option::Option::None;
        self.server_addr = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.choked_blocks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
        static instance: CMsgGCCStrike15_v2_ClientVarValueNotificationInfo = CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
            value_name: ::std::option::Option::None,
            value_int: ::std::option::Option::None,
            server_addr: ::std::option::Option::None,
            server_port: ::std::option::Option::None,
            choked_blocks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientVarValueNotificationInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientVarValueNotificationInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ServerVarValueNotificationInfo)
pub struct CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.viewangles)
    pub viewangles: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.type)
    pub type_: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    fn default() -> &'a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
        <CMsgGCCStrike15_v2_ServerVarValueNotificationInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    pub fn new() -> CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 type = 3;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &m.accountid },
            |m: &mut CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &mut m.accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "viewangles",
            |m: &CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &m.viewangles },
            |m: &mut CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &mut m.viewangles },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &m.type_ },
            |m: &mut CMsgGCCStrike15_v2_ServerVarValueNotificationInfo| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ServerVarValueNotificationInfo>(
            "CMsgGCCStrike15_v2_ServerVarValueNotificationInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ServerVarValueNotificationInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.viewangles)?;
                },
                16 => {
                    self.viewangles.push(is.read_uint32()?);
                },
                24 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.viewangles {
            my_size += ::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.type_ {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        for v in &self.viewangles {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.type_ {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
        CMsgGCCStrike15_v2_ServerVarValueNotificationInfo::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.viewangles.clear();
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
        static instance: CMsgGCCStrike15_v2_ServerVarValueNotificationInfo = CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
            accountid: ::std::option::Option::None,
            viewangles: ::std::vec::Vec::new(),
            type_: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ServerVarValueNotificationInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ServerVarValueNotificationInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GiftsLeaderboardRequest)
pub struct CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GiftsLeaderboardRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    fn default() -> &'a CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
        <CMsgGCCStrike15_v2_GiftsLeaderboardRequest as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    pub fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GiftsLeaderboardRequest>(
            "CMsgGCCStrike15_v2_GiftsLeaderboardRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GiftsLeaderboardRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
        CMsgGCCStrike15_v2_GiftsLeaderboardRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
        static instance: CMsgGCCStrike15_v2_GiftsLeaderboardRequest = CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GiftsLeaderboardRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GiftsLeaderboardRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GiftsLeaderboardResponse)
pub struct CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.servertime)
    pub servertime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.time_period_seconds)
    pub time_period_seconds: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.total_gifts_given)
    pub total_gifts_given: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.total_givers)
    pub total_givers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.entries)
    pub entries: ::std::vec::Vec<cmsg_gccstrike15_v2_gifts_leaderboard_response::GiftLeaderboardEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    fn default() -> &'a CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
        <CMsgGCCStrike15_v2_GiftsLeaderboardResponse as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    pub fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
        ::std::default::Default::default()
    }

    // optional uint32 servertime = 1;

    pub fn servertime(&self) -> u32 {
        self.servertime.unwrap_or(0)
    }

    pub fn clear_servertime(&mut self) {
        self.servertime = ::std::option::Option::None;
    }

    pub fn has_servertime(&self) -> bool {
        self.servertime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servertime(&mut self, v: u32) {
        self.servertime = ::std::option::Option::Some(v);
    }

    // optional uint32 time_period_seconds = 2;

    pub fn time_period_seconds(&self) -> u32 {
        self.time_period_seconds.unwrap_or(0)
    }

    pub fn clear_time_period_seconds(&mut self) {
        self.time_period_seconds = ::std::option::Option::None;
    }

    pub fn has_time_period_seconds(&self) -> bool {
        self.time_period_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_period_seconds(&mut self, v: u32) {
        self.time_period_seconds = ::std::option::Option::Some(v);
    }

    // optional uint32 total_gifts_given = 3;

    pub fn total_gifts_given(&self) -> u32 {
        self.total_gifts_given.unwrap_or(0)
    }

    pub fn clear_total_gifts_given(&mut self) {
        self.total_gifts_given = ::std::option::Option::None;
    }

    pub fn has_total_gifts_given(&self) -> bool {
        self.total_gifts_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_gifts_given(&mut self, v: u32) {
        self.total_gifts_given = ::std::option::Option::Some(v);
    }

    // optional uint32 total_givers = 4;

    pub fn total_givers(&self) -> u32 {
        self.total_givers.unwrap_or(0)
    }

    pub fn clear_total_givers(&mut self) {
        self.total_givers = ::std::option::Option::None;
    }

    pub fn has_total_givers(&self) -> bool {
        self.total_givers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_givers(&mut self, v: u32) {
        self.total_givers = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "servertime",
            |m: &CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &m.servertime },
            |m: &mut CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &mut m.servertime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "time_period_seconds",
            |m: &CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &m.time_period_seconds },
            |m: &mut CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &mut m.time_period_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_gifts_given",
            |m: &CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &m.total_gifts_given },
            |m: &mut CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &mut m.total_gifts_given },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "total_givers",
            |m: &CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &m.total_givers },
            |m: &mut CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &mut m.total_givers },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "entries",
            |m: &CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &m.entries },
            |m: &mut CMsgGCCStrike15_v2_GiftsLeaderboardResponse| { &mut m.entries },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GiftsLeaderboardResponse>(
            "CMsgGCCStrike15_v2_GiftsLeaderboardResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GiftsLeaderboardResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.servertime = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.time_period_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.total_gifts_given = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.total_givers = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.servertime {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.time_period_seconds {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.total_gifts_given {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.total_givers {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.servertime {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time_period_seconds {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.total_gifts_given {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.total_givers {
            os.write_uint32(4, v)?;
        }
        for v in &self.entries {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
        CMsgGCCStrike15_v2_GiftsLeaderboardResponse::new()
    }

    fn clear(&mut self) {
        self.servertime = ::std::option::Option::None;
        self.time_period_seconds = ::std::option::Option::None;
        self.total_gifts_given = ::std::option::Option::None;
        self.total_givers = ::std::option::Option::None;
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
        static instance: CMsgGCCStrike15_v2_GiftsLeaderboardResponse = CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
            servertime: ::std::option::Option::None,
            time_period_seconds: ::std::option::Option::None,
            total_gifts_given: ::std::option::Option::None,
            total_givers: ::std::option::Option::None,
            entries: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GiftsLeaderboardResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GiftsLeaderboardResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CMsgGCCStrike15_v2_GiftsLeaderboardResponse`
pub mod cmsg_gccstrike15_v2_gifts_leaderboard_response {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry)
    pub struct GiftLeaderboardEntry {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry.accountid)
        pub accountid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry.gifts)
        pub gifts: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GiftLeaderboardEntry {
        fn default() -> &'a GiftLeaderboardEntry {
            <GiftLeaderboardEntry as ::protobuf::Message>::default_instance()
        }
    }

    impl GiftLeaderboardEntry {
        pub fn new() -> GiftLeaderboardEntry {
            ::std::default::Default::default()
        }

        // optional uint32 accountid = 1;

        pub fn accountid(&self) -> u32 {
            self.accountid.unwrap_or(0)
        }

        pub fn clear_accountid(&mut self) {
            self.accountid = ::std::option::Option::None;
        }

        pub fn has_accountid(&self) -> bool {
            self.accountid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_accountid(&mut self, v: u32) {
            self.accountid = ::std::option::Option::Some(v);
        }

        // optional uint32 gifts = 2;

        pub fn gifts(&self) -> u32 {
            self.gifts.unwrap_or(0)
        }

        pub fn clear_gifts(&mut self) {
            self.gifts = ::std::option::Option::None;
        }

        pub fn has_gifts(&self) -> bool {
            self.gifts.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gifts(&mut self, v: u32) {
            self.gifts = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "accountid",
                |m: &GiftLeaderboardEntry| { &m.accountid },
                |m: &mut GiftLeaderboardEntry| { &mut m.accountid },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
                "gifts",
                |m: &GiftLeaderboardEntry| { &m.gifts },
                |m: &mut GiftLeaderboardEntry| { &mut m.gifts },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GiftLeaderboardEntry>(
                "CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GiftLeaderboardEntry {
        const NAME: &'static str = "GiftLeaderboardEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.gifts = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.accountid {
                my_size += ::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.gifts {
                my_size += ::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.accountid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.gifts {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GiftLeaderboardEntry {
            GiftLeaderboardEntry::new()
        }

        fn clear(&mut self) {
            self.accountid = ::std::option::Option::None;
            self.gifts = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GiftLeaderboardEntry {
            static instance: GiftLeaderboardEntry = GiftLeaderboardEntry {
                accountid: ::std::option::Option::None,
                gifts: ::std::option::Option::None,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GiftLeaderboardEntry {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GiftLeaderboardEntry {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GiftLeaderboardEntry {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientSubmitSurveyVote)
pub struct CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientSubmitSurveyVote.survey_id)
    pub survey_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientSubmitSurveyVote.vote)
    pub vote: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientSubmitSurveyVote.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
        <CMsgGCCStrike15_v2_ClientSubmitSurveyVote as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    pub fn new() -> CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
        ::std::default::Default::default()
    }

    // optional uint32 survey_id = 1;

    pub fn survey_id(&self) -> u32 {
        self.survey_id.unwrap_or(0)
    }

    pub fn clear_survey_id(&mut self) {
        self.survey_id = ::std::option::Option::None;
    }

    pub fn has_survey_id(&self) -> bool {
        self.survey_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_survey_id(&mut self, v: u32) {
        self.survey_id = ::std::option::Option::Some(v);
    }

    // optional uint32 vote = 2;

    pub fn vote(&self) -> u32 {
        self.vote.unwrap_or(0)
    }

    pub fn clear_vote(&mut self) {
        self.vote = ::std::option::Option::None;
    }

    pub fn has_vote(&self) -> bool {
        self.vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: u32) {
        self.vote = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "survey_id",
            |m: &CMsgGCCStrike15_v2_ClientSubmitSurveyVote| { &m.survey_id },
            |m: &mut CMsgGCCStrike15_v2_ClientSubmitSurveyVote| { &mut m.survey_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "vote",
            |m: &CMsgGCCStrike15_v2_ClientSubmitSurveyVote| { &m.vote },
            |m: &mut CMsgGCCStrike15_v2_ClientSubmitSurveyVote| { &mut m.vote },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientSubmitSurveyVote>(
            "CMsgGCCStrike15_v2_ClientSubmitSurveyVote",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientSubmitSurveyVote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.survey_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.vote = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.survey_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.vote {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.survey_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.vote {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
        CMsgGCCStrike15_v2_ClientSubmitSurveyVote::new()
    }

    fn clear(&mut self) {
        self.survey_id = ::std::option::Option::None;
        self.vote = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
        static instance: CMsgGCCStrike15_v2_ClientSubmitSurveyVote = CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
            survey_id: ::std::option::Option::None,
            vote: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientSubmitSurveyVote").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientSubmitSurveyVote {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Server2GCClientValidate)
pub struct CMsgGCCStrike15_v2_Server2GCClientValidate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Server2GCClientValidate.accountid)
    pub accountid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Server2GCClientValidate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Server2GCClientValidate {
    fn default() -> &'a CMsgGCCStrike15_v2_Server2GCClientValidate {
        <CMsgGCCStrike15_v2_Server2GCClientValidate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Server2GCClientValidate {
    pub fn new() -> CMsgGCCStrike15_v2_Server2GCClientValidate {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CMsgGCCStrike15_v2_Server2GCClientValidate| { &m.accountid },
            |m: &mut CMsgGCCStrike15_v2_Server2GCClientValidate| { &mut m.accountid },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Server2GCClientValidate>(
            "CMsgGCCStrike15_v2_Server2GCClientValidate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Server2GCClientValidate {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Server2GCClientValidate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Server2GCClientValidate {
        CMsgGCCStrike15_v2_Server2GCClientValidate::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Server2GCClientValidate {
        static instance: CMsgGCCStrike15_v2_Server2GCClientValidate = CMsgGCCStrike15_v2_Server2GCClientValidate {
            accountid: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Server2GCClientValidate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Server2GCClientValidate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Server2GCClientValidate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Server2GCClientValidate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure)
pub struct CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.path)
    pub path: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.file)
    pub file: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.crc)
    pub crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.hash)
    pub hash: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.len)
    pub len: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.pack_number)
    pub pack_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.pack_file_id)
    pub pack_file_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    fn default() -> &'a CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
        <CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    pub fn new() -> CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional string path = 2;

    pub fn path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_path(&mut self) {
        self.path = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path = ::std::option::Option::Some(::std::string::String::new());
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string file = 3;

    pub fn file(&self) -> &str {
        match self.file.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file(&mut self) {
        self.file = ::std::option::Option::None;
    }

    pub fn has_file(&self) -> bool {
        self.file.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: ::std::string::String) {
        self.file = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file(&mut self) -> &mut ::std::string::String {
        if self.file.is_none() {
            self.file = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file.as_mut().unwrap()
    }

    // Take field
    pub fn take_file(&mut self) -> ::std::string::String {
        self.file.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 crc = 4;

    pub fn crc(&self) -> u32 {
        self.crc.unwrap_or(0)
    }

    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: u32) {
        self.crc = ::std::option::Option::Some(v);
    }

    // optional int32 hash = 5;

    pub fn hash(&self) -> i32 {
        self.hash.unwrap_or(0)
    }

    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: i32) {
        self.hash = ::std::option::Option::Some(v);
    }

    // optional int32 len = 6;

    pub fn len(&self) -> i32 {
        self.len.unwrap_or(0)
    }

    pub fn clear_len(&mut self) {
        self.len = ::std::option::Option::None;
    }

    pub fn has_len(&self) -> bool {
        self.len.is_some()
    }

    // Param is passed by value, moved
    pub fn set_len(&mut self, v: i32) {
        self.len = ::std::option::Option::Some(v);
    }

    // optional int32 pack_number = 7;

    pub fn pack_number(&self) -> i32 {
        self.pack_number.unwrap_or(0)
    }

    pub fn clear_pack_number(&mut self) {
        self.pack_number = ::std::option::Option::None;
    }

    pub fn has_pack_number(&self) -> bool {
        self.pack_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pack_number(&mut self, v: i32) {
        self.pack_number = ::std::option::Option::Some(v);
    }

    // optional int32 pack_file_id = 8;

    pub fn pack_file_id(&self) -> i32 {
        self.pack_file_id.unwrap_or(0)
    }

    pub fn clear_pack_file_id(&mut self) {
        self.pack_file_id = ::std::option::Option::None;
    }

    pub fn has_pack_file_id(&self) -> bool {
        self.pack_file_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pack_file_id(&mut self, v: i32) {
        self.pack_file_id = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "accountid",
            |m: &CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &m.accountid },
            |m: &mut CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &mut m.accountid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "path",
            |m: &CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &m.path },
            |m: &mut CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "file",
            |m: &CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &m.file },
            |m: &mut CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &mut m.file },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "crc",
            |m: &CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &m.crc },
            |m: &mut CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &mut m.crc },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "hash",
            |m: &CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &m.hash },
            |m: &mut CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &mut m.hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "len",
            |m: &CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &m.len },
            |m: &mut CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &mut m.len },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pack_number",
            |m: &CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &m.pack_number },
            |m: &mut CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &mut m.pack_number },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "pack_file_id",
            |m: &CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &m.pack_file_id },
            |m: &mut CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure| { &mut m.pack_file_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure>(
            "CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.path = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.file = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.hash = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.len = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.pack_number = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.pack_file_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.file.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.crc {
            my_size += ::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.hash {
            my_size += ::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.len {
            my_size += ::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.pack_number {
            my_size += ::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.pack_file_id {
            my_size += ::protobuf::rt::int32_size(8, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.path.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.file.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.crc {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.hash {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.len {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.pack_number {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.pack_file_id {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
        CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.path = ::std::option::Option::None;
        self.file = ::std::option::Option::None;
        self.crc = ::std::option::Option::None;
        self.hash = ::std::option::Option::None;
        self.len = ::std::option::Option::None;
        self.pack_number = ::std::option::Option::None;
        self.pack_file_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
        static instance: CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure = CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
            accountid: ::std::option::Option::None,
            path: ::std::option::Option::None,
            file: ::std::option::Option::None,
            crc: ::std::option::Option::None,
            hash: ::std::option::Option::None,
            len: ::std::option::Option::None,
            pack_number: ::std::option::Option::None,
            pack_file_id: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GC2ClientTournamentInfo)
pub struct CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientTournamentInfo.eventid)
    pub eventid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientTournamentInfo.stageid)
    pub stageid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientTournamentInfo.game_type)
    pub game_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GC2ClientTournamentInfo.teamids)
    pub teamids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GC2ClientTournamentInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    fn default() -> &'a CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
        <CMsgGCCStrike15_v2_GC2ClientTournamentInfo as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    pub fn new() -> CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
        ::std::default::Default::default()
    }

    // optional uint32 eventid = 1;

    pub fn eventid(&self) -> u32 {
        self.eventid.unwrap_or(0)
    }

    pub fn clear_eventid(&mut self) {
        self.eventid = ::std::option::Option::None;
    }

    pub fn has_eventid(&self) -> bool {
        self.eventid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventid(&mut self, v: u32) {
        self.eventid = ::std::option::Option::Some(v);
    }

    // optional uint32 stageid = 2;

    pub fn stageid(&self) -> u32 {
        self.stageid.unwrap_or(0)
    }

    pub fn clear_stageid(&mut self) {
        self.stageid = ::std::option::Option::None;
    }

    pub fn has_stageid(&self) -> bool {
        self.stageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stageid(&mut self, v: u32) {
        self.stageid = ::std::option::Option::Some(v);
    }

    // optional uint32 game_type = 3;

    pub fn game_type(&self) -> u32 {
        self.game_type.unwrap_or(0)
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "eventid",
            |m: &CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &m.eventid },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &mut m.eventid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stageid",
            |m: &CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &m.stageid },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &mut m.stageid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "game_type",
            |m: &CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &m.game_type },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &mut m.game_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "teamids",
            |m: &CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &m.teamids },
            |m: &mut CMsgGCCStrike15_v2_GC2ClientTournamentInfo| { &mut m.teamids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GC2ClientTournamentInfo>(
            "CMsgGCCStrike15_v2_GC2ClientTournamentInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GC2ClientTournamentInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eventid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.stageid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.game_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.teamids)?;
                },
                32 => {
                    self.teamids.push(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eventid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.stageid {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.game_type {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.teamids {
            my_size += ::protobuf::rt::uint32_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.eventid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.stageid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(3, v)?;
        }
        for v in &self.teamids {
            os.write_uint32(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
        CMsgGCCStrike15_v2_GC2ClientTournamentInfo::new()
    }

    fn clear(&mut self) {
        self.eventid = ::std::option::Option::None;
        self.stageid = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.teamids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
        static instance: CMsgGCCStrike15_v2_GC2ClientTournamentInfo = CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
            eventid: ::std::option::Option::None,
            stageid: ::std::option::Option::None,
            game_type: ::std::option::Option::None,
            teamids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GC2ClientTournamentInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GC2ClientTournamentInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOEconCoupon)
pub struct CSOEconCoupon {
    // message fields
    // @@protoc_insertion_point(field:CSOEconCoupon.entryid)
    pub entryid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconCoupon.defidx)
    pub defidx: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconCoupon.expiration_date)
    pub expiration_date: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconCoupon.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconCoupon {
    fn default() -> &'a CSOEconCoupon {
        <CSOEconCoupon as ::protobuf::Message>::default_instance()
    }
}

impl CSOEconCoupon {
    pub fn new() -> CSOEconCoupon {
        ::std::default::Default::default()
    }

    // optional uint32 entryid = 1;

    pub fn entryid(&self) -> u32 {
        self.entryid.unwrap_or(0)
    }

    pub fn clear_entryid(&mut self) {
        self.entryid = ::std::option::Option::None;
    }

    pub fn has_entryid(&self) -> bool {
        self.entryid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entryid(&mut self, v: u32) {
        self.entryid = ::std::option::Option::Some(v);
    }

    // optional uint32 defidx = 2;

    pub fn defidx(&self) -> u32 {
        self.defidx.unwrap_or(0)
    }

    pub fn clear_defidx(&mut self) {
        self.defidx = ::std::option::Option::None;
    }

    pub fn has_defidx(&self) -> bool {
        self.defidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defidx(&mut self, v: u32) {
        self.defidx = ::std::option::Option::Some(v);
    }

    // optional fixed32 expiration_date = 3;

    pub fn expiration_date(&self) -> u32 {
        self.expiration_date.unwrap_or(0)
    }

    pub fn clear_expiration_date(&mut self) {
        self.expiration_date = ::std::option::Option::None;
    }

    pub fn has_expiration_date(&self) -> bool {
        self.expiration_date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_date(&mut self, v: u32) {
        self.expiration_date = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "entryid",
            |m: &CSOEconCoupon| { &m.entryid },
            |m: &mut CSOEconCoupon| { &mut m.entryid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "defidx",
            |m: &CSOEconCoupon| { &m.defidx },
            |m: &mut CSOEconCoupon| { &mut m.defidx },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "expiration_date",
            |m: &CSOEconCoupon| { &m.expiration_date },
            |m: &mut CSOEconCoupon| { &mut m.expiration_date },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOEconCoupon>(
            "CSOEconCoupon",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOEconCoupon {
    const NAME: &'static str = "CSOEconCoupon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entryid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.defidx = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.expiration_date = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entryid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.defidx {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.expiration_date {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entryid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.defidx {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.expiration_date {
            os.write_fixed32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconCoupon {
        CSOEconCoupon::new()
    }

    fn clear(&mut self) {
        self.entryid = ::std::option::Option::None;
        self.defidx = ::std::option::Option::None;
        self.expiration_date = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconCoupon {
        static instance: CSOEconCoupon = CSOEconCoupon {
            entryid: ::std::option::Option::None,
            defidx: ::std::option::Option::None,
            expiration_date: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOEconCoupon {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOEconCoupon").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOEconCoupon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOEconCoupon {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOQuestProgress)
pub struct CSOQuestProgress {
    // message fields
    // @@protoc_insertion_point(field:CSOQuestProgress.questid)
    pub questid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestProgress.points_remaining)
    pub points_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestProgress.bonus_points)
    pub bonus_points: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOQuestProgress.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOQuestProgress {
    fn default() -> &'a CSOQuestProgress {
        <CSOQuestProgress as ::protobuf::Message>::default_instance()
    }
}

impl CSOQuestProgress {
    pub fn new() -> CSOQuestProgress {
        ::std::default::Default::default()
    }

    // optional uint32 questid = 1;

    pub fn questid(&self) -> u32 {
        self.questid.unwrap_or(0)
    }

    pub fn clear_questid(&mut self) {
        self.questid = ::std::option::Option::None;
    }

    pub fn has_questid(&self) -> bool {
        self.questid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_questid(&mut self, v: u32) {
        self.questid = ::std::option::Option::Some(v);
    }

    // optional uint32 points_remaining = 2;

    pub fn points_remaining(&self) -> u32 {
        self.points_remaining.unwrap_or(0)
    }

    pub fn clear_points_remaining(&mut self) {
        self.points_remaining = ::std::option::Option::None;
    }

    pub fn has_points_remaining(&self) -> bool {
        self.points_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_remaining(&mut self, v: u32) {
        self.points_remaining = ::std::option::Option::Some(v);
    }

    // optional uint32 bonus_points = 3;

    pub fn bonus_points(&self) -> u32 {
        self.bonus_points.unwrap_or(0)
    }

    pub fn clear_bonus_points(&mut self) {
        self.bonus_points = ::std::option::Option::None;
    }

    pub fn has_bonus_points(&self) -> bool {
        self.bonus_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_points(&mut self, v: u32) {
        self.bonus_points = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "questid",
            |m: &CSOQuestProgress| { &m.questid },
            |m: &mut CSOQuestProgress| { &mut m.questid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "points_remaining",
            |m: &CSOQuestProgress| { &m.points_remaining },
            |m: &mut CSOQuestProgress| { &mut m.points_remaining },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "bonus_points",
            |m: &CSOQuestProgress| { &m.bonus_points },
            |m: &mut CSOQuestProgress| { &mut m.bonus_points },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOQuestProgress>(
            "CSOQuestProgress",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOQuestProgress {
    const NAME: &'static str = "CSOQuestProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.questid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.points_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.bonus_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.questid {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.points_remaining {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.bonus_points {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.questid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.points_remaining {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bonus_points {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOQuestProgress {
        CSOQuestProgress::new()
    }

    fn clear(&mut self) {
        self.questid = ::std::option::Option::None;
        self.points_remaining = ::std::option::Option::None;
        self.bonus_points = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOQuestProgress {
        static instance: CSOQuestProgress = CSOQuestProgress {
            questid: ::std::option::Option::None,
            points_remaining: ::std::option::Option::None,
            bonus_points: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOQuestProgress {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOQuestProgress").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOQuestProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOQuestProgress {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CSOPersonaDataPublic)
pub struct CSOPersonaDataPublic {
    // message fields
    // @@protoc_insertion_point(field:CSOPersonaDataPublic.player_level)
    pub player_level: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOPersonaDataPublic.commendation)
    pub commendation: ::protobuf::MessageField<PlayerCommendationInfo>,
    // @@protoc_insertion_point(field:CSOPersonaDataPublic.elevated_state)
    pub elevated_state: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOPersonaDataPublic.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOPersonaDataPublic {
    fn default() -> &'a CSOPersonaDataPublic {
        <CSOPersonaDataPublic as ::protobuf::Message>::default_instance()
    }
}

impl CSOPersonaDataPublic {
    pub fn new() -> CSOPersonaDataPublic {
        ::std::default::Default::default()
    }

    // optional int32 player_level = 1;

    pub fn player_level(&self) -> i32 {
        self.player_level.unwrap_or(0)
    }

    pub fn clear_player_level(&mut self) {
        self.player_level = ::std::option::Option::None;
    }

    pub fn has_player_level(&self) -> bool {
        self.player_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_level(&mut self, v: i32) {
        self.player_level = ::std::option::Option::Some(v);
    }

    // optional bool elevated_state = 3;

    pub fn elevated_state(&self) -> bool {
        self.elevated_state.unwrap_or(false)
    }

    pub fn clear_elevated_state(&mut self) {
        self.elevated_state = ::std::option::Option::None;
    }

    pub fn has_elevated_state(&self) -> bool {
        self.elevated_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elevated_state(&mut self, v: bool) {
        self.elevated_state = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "player_level",
            |m: &CSOPersonaDataPublic| { &m.player_level },
            |m: &mut CSOPersonaDataPublic| { &mut m.player_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PlayerCommendationInfo>(
            "commendation",
            |m: &CSOPersonaDataPublic| { &m.commendation },
            |m: &mut CSOPersonaDataPublic| { &mut m.commendation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "elevated_state",
            |m: &CSOPersonaDataPublic| { &m.elevated_state },
            |m: &mut CSOPersonaDataPublic| { &mut m.elevated_state },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CSOPersonaDataPublic>(
            "CSOPersonaDataPublic",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CSOPersonaDataPublic {
    const NAME: &'static str = "CSOPersonaDataPublic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_level = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.commendation)?;
                },
                24 => {
                    self.elevated_state = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_level {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.commendation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.elevated_state {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.player_level {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.commendation.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.elevated_state {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOPersonaDataPublic {
        CSOPersonaDataPublic::new()
    }

    fn clear(&mut self) {
        self.player_level = ::std::option::Option::None;
        self.commendation.clear();
        self.elevated_state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOPersonaDataPublic {
        static instance: CSOPersonaDataPublic = CSOPersonaDataPublic {
            player_level: ::std::option::Option::None,
            commendation: ::protobuf::MessageField::none(),
            elevated_state: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CSOPersonaDataPublic {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CSOPersonaDataPublic").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CSOPersonaDataPublic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSOPersonaDataPublic {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGC_GlobalGame_Subscribe)
pub struct CMsgGC_GlobalGame_Subscribe {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GlobalGame_Subscribe.ticket)
    pub ticket: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GlobalGame_Subscribe.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GlobalGame_Subscribe {
    fn default() -> &'a CMsgGC_GlobalGame_Subscribe {
        <CMsgGC_GlobalGame_Subscribe as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GlobalGame_Subscribe {
    pub fn new() -> CMsgGC_GlobalGame_Subscribe {
        ::std::default::Default::default()
    }

    // optional uint64 ticket = 1;

    pub fn ticket(&self) -> u64 {
        self.ticket.unwrap_or(0)
    }

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: u64) {
        self.ticket = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket",
            |m: &CMsgGC_GlobalGame_Subscribe| { &m.ticket },
            |m: &mut CMsgGC_GlobalGame_Subscribe| { &mut m.ticket },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GlobalGame_Subscribe>(
            "CMsgGC_GlobalGame_Subscribe",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GlobalGame_Subscribe {
    const NAME: &'static str = "CMsgGC_GlobalGame_Subscribe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ticket = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ticket {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ticket {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GlobalGame_Subscribe {
        CMsgGC_GlobalGame_Subscribe::new()
    }

    fn clear(&mut self) {
        self.ticket = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GlobalGame_Subscribe {
        static instance: CMsgGC_GlobalGame_Subscribe = CMsgGC_GlobalGame_Subscribe {
            ticket: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GlobalGame_Subscribe {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GlobalGame_Subscribe").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GlobalGame_Subscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GlobalGame_Subscribe {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGC_GlobalGame_Unsubscribe)
pub struct CMsgGC_GlobalGame_Unsubscribe {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GlobalGame_Unsubscribe.timeleft)
    pub timeleft: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GlobalGame_Unsubscribe.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GlobalGame_Unsubscribe {
    fn default() -> &'a CMsgGC_GlobalGame_Unsubscribe {
        <CMsgGC_GlobalGame_Unsubscribe as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GlobalGame_Unsubscribe {
    pub fn new() -> CMsgGC_GlobalGame_Unsubscribe {
        ::std::default::Default::default()
    }

    // optional int32 timeleft = 1;

    pub fn timeleft(&self) -> i32 {
        self.timeleft.unwrap_or(0)
    }

    pub fn clear_timeleft(&mut self) {
        self.timeleft = ::std::option::Option::None;
    }

    pub fn has_timeleft(&self) -> bool {
        self.timeleft.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeleft(&mut self, v: i32) {
        self.timeleft = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "timeleft",
            |m: &CMsgGC_GlobalGame_Unsubscribe| { &m.timeleft },
            |m: &mut CMsgGC_GlobalGame_Unsubscribe| { &mut m.timeleft },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GlobalGame_Unsubscribe>(
            "CMsgGC_GlobalGame_Unsubscribe",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GlobalGame_Unsubscribe {
    const NAME: &'static str = "CMsgGC_GlobalGame_Unsubscribe";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.timeleft = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timeleft {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timeleft {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GlobalGame_Unsubscribe {
        CMsgGC_GlobalGame_Unsubscribe::new()
    }

    fn clear(&mut self) {
        self.timeleft = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GlobalGame_Unsubscribe {
        static instance: CMsgGC_GlobalGame_Unsubscribe = CMsgGC_GlobalGame_Unsubscribe {
            timeleft: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GlobalGame_Unsubscribe {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GlobalGame_Unsubscribe").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GlobalGame_Unsubscribe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GlobalGame_Unsubscribe {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGC_GlobalGame_Play)
pub struct CMsgGC_GlobalGame_Play {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GlobalGame_Play.ticket)
    pub ticket: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGC_GlobalGame_Play.gametimems)
    pub gametimems: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_GlobalGame_Play.msperpoint)
    pub msperpoint: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GlobalGame_Play.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GlobalGame_Play {
    fn default() -> &'a CMsgGC_GlobalGame_Play {
        <CMsgGC_GlobalGame_Play as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GlobalGame_Play {
    pub fn new() -> CMsgGC_GlobalGame_Play {
        ::std::default::Default::default()
    }

    // optional uint64 ticket = 1;

    pub fn ticket(&self) -> u64 {
        self.ticket.unwrap_or(0)
    }

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: u64) {
        self.ticket = ::std::option::Option::Some(v);
    }

    // optional uint32 gametimems = 2;

    pub fn gametimems(&self) -> u32 {
        self.gametimems.unwrap_or(0)
    }

    pub fn clear_gametimems(&mut self) {
        self.gametimems = ::std::option::Option::None;
    }

    pub fn has_gametimems(&self) -> bool {
        self.gametimems.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gametimems(&mut self, v: u32) {
        self.gametimems = ::std::option::Option::Some(v);
    }

    // optional uint32 msperpoint = 3;

    pub fn msperpoint(&self) -> u32 {
        self.msperpoint.unwrap_or(0)
    }

    pub fn clear_msperpoint(&mut self) {
        self.msperpoint = ::std::option::Option::None;
    }

    pub fn has_msperpoint(&self) -> bool {
        self.msperpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msperpoint(&mut self, v: u32) {
        self.msperpoint = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket",
            |m: &CMsgGC_GlobalGame_Play| { &m.ticket },
            |m: &mut CMsgGC_GlobalGame_Play| { &mut m.ticket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "gametimems",
            |m: &CMsgGC_GlobalGame_Play| { &m.gametimems },
            |m: &mut CMsgGC_GlobalGame_Play| { &mut m.gametimems },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "msperpoint",
            |m: &CMsgGC_GlobalGame_Play| { &m.msperpoint },
            |m: &mut CMsgGC_GlobalGame_Play| { &mut m.msperpoint },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGC_GlobalGame_Play>(
            "CMsgGC_GlobalGame_Play",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGC_GlobalGame_Play {
    const NAME: &'static str = "CMsgGC_GlobalGame_Play";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ticket = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.gametimems = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.msperpoint = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ticket {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.gametimems {
            my_size += ::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.msperpoint {
            my_size += ::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ticket {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.gametimems {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.msperpoint {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GlobalGame_Play {
        CMsgGC_GlobalGame_Play::new()
    }

    fn clear(&mut self) {
        self.ticket = ::std::option::Option::None;
        self.gametimems = ::std::option::Option::None;
        self.msperpoint = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GlobalGame_Play {
        static instance: CMsgGC_GlobalGame_Play = CMsgGC_GlobalGame_Play {
            ticket: ::std::option::Option::None,
            gametimems: ::std::option::Option::None,
            msperpoint: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGC_GlobalGame_Play {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGC_GlobalGame_Play").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGC_GlobalGame_Play {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGC_GlobalGame_Play {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_AcknowledgePenalty)
pub struct CMsgGCCStrike15_v2_AcknowledgePenalty {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_AcknowledgePenalty.acknowledged)
    pub acknowledged: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_AcknowledgePenalty.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_AcknowledgePenalty {
    fn default() -> &'a CMsgGCCStrike15_v2_AcknowledgePenalty {
        <CMsgGCCStrike15_v2_AcknowledgePenalty as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_AcknowledgePenalty {
    pub fn new() -> CMsgGCCStrike15_v2_AcknowledgePenalty {
        ::std::default::Default::default()
    }

    // optional int32 acknowledged = 1;

    pub fn acknowledged(&self) -> i32 {
        self.acknowledged.unwrap_or(0)
    }

    pub fn clear_acknowledged(&mut self) {
        self.acknowledged = ::std::option::Option::None;
    }

    pub fn has_acknowledged(&self) -> bool {
        self.acknowledged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acknowledged(&mut self, v: i32) {
        self.acknowledged = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "acknowledged",
            |m: &CMsgGCCStrike15_v2_AcknowledgePenalty| { &m.acknowledged },
            |m: &mut CMsgGCCStrike15_v2_AcknowledgePenalty| { &mut m.acknowledged },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_AcknowledgePenalty>(
            "CMsgGCCStrike15_v2_AcknowledgePenalty",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_AcknowledgePenalty {
    const NAME: &'static str = "CMsgGCCStrike15_v2_AcknowledgePenalty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.acknowledged = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.acknowledged {
            my_size += ::protobuf::rt::int32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.acknowledged {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_AcknowledgePenalty {
        CMsgGCCStrike15_v2_AcknowledgePenalty::new()
    }

    fn clear(&mut self) {
        self.acknowledged = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_AcknowledgePenalty {
        static instance: CMsgGCCStrike15_v2_AcknowledgePenalty = CMsgGCCStrike15_v2_AcknowledgePenalty {
            acknowledged: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_AcknowledgePenalty {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_AcknowledgePenalty").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_AcknowledgePenalty {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_AcknowledgePenalty {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin)
pub struct CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    fn default() -> &'a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
        <CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin>(
            "CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
        CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
        static instance: CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_Client2GCStreamUnlock)
pub struct CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCStreamUnlock.ticket)
    pub ticket: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_Client2GCStreamUnlock.os)
    pub os: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_Client2GCStreamUnlock.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    fn default() -> &'a CMsgGCCStrike15_v2_Client2GCStreamUnlock {
        <CMsgGCCStrike15_v2_Client2GCStreamUnlock as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    pub fn new() -> CMsgGCCStrike15_v2_Client2GCStreamUnlock {
        ::std::default::Default::default()
    }

    // optional uint64 ticket = 1;

    pub fn ticket(&self) -> u64 {
        self.ticket.unwrap_or(0)
    }

    pub fn clear_ticket(&mut self) {
        self.ticket = ::std::option::Option::None;
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: u64) {
        self.ticket = ::std::option::Option::Some(v);
    }

    // optional int32 os = 2;

    pub fn os(&self) -> i32 {
        self.os.unwrap_or(0)
    }

    pub fn clear_os(&mut self) {
        self.os = ::std::option::Option::None;
    }

    pub fn has_os(&self) -> bool {
        self.os.is_some()
    }

    // Param is passed by value, moved
    pub fn set_os(&mut self, v: i32) {
        self.os = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "ticket",
            |m: &CMsgGCCStrike15_v2_Client2GCStreamUnlock| { &m.ticket },
            |m: &mut CMsgGCCStrike15_v2_Client2GCStreamUnlock| { &mut m.ticket },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "os",
            |m: &CMsgGCCStrike15_v2_Client2GCStreamUnlock| { &m.os },
            |m: &mut CMsgGCCStrike15_v2_Client2GCStreamUnlock| { &mut m.os },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_Client2GCStreamUnlock>(
            "CMsgGCCStrike15_v2_Client2GCStreamUnlock",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    const NAME: &'static str = "CMsgGCCStrike15_v2_Client2GCStreamUnlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ticket = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.os = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ticket {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.os {
            my_size += ::protobuf::rt::int32_size(2, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.ticket {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.os {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_Client2GCStreamUnlock {
        CMsgGCCStrike15_v2_Client2GCStreamUnlock::new()
    }

    fn clear(&mut self) {
        self.ticket = ::std::option::Option::None;
        self.os = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_Client2GCStreamUnlock {
        static instance: CMsgGCCStrike15_v2_Client2GCStreamUnlock = CMsgGCCStrike15_v2_Client2GCStreamUnlock {
            ticket: ::std::option::Option::None,
            os: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_Client2GCStreamUnlock").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_Client2GCStreamUnlock {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientToGCRequestElevate)
pub struct CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientToGCRequestElevate.stage)
    pub stage: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientToGCRequestElevate.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientToGCRequestElevate {
        <CMsgGCCStrike15_v2_ClientToGCRequestElevate as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    pub fn new() -> CMsgGCCStrike15_v2_ClientToGCRequestElevate {
        ::std::default::Default::default()
    }

    // optional uint32 stage = 1;

    pub fn stage(&self) -> u32 {
        self.stage.unwrap_or(0)
    }

    pub fn clear_stage(&mut self) {
        self.stage = ::std::option::Option::None;
    }

    pub fn has_stage(&self) -> bool {
        self.stage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stage(&mut self, v: u32) {
        self.stage = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "stage",
            |m: &CMsgGCCStrike15_v2_ClientToGCRequestElevate| { &m.stage },
            |m: &mut CMsgGCCStrike15_v2_ClientToGCRequestElevate| { &mut m.stage },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientToGCRequestElevate>(
            "CMsgGCCStrike15_v2_ClientToGCRequestElevate",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientToGCRequestElevate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.stage = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stage {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.stage {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientToGCRequestElevate {
        CMsgGCCStrike15_v2_ClientToGCRequestElevate::new()
    }

    fn clear(&mut self) {
        self.stage = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientToGCRequestElevate {
        static instance: CMsgGCCStrike15_v2_ClientToGCRequestElevate = CMsgGCCStrike15_v2_ClientToGCRequestElevate {
            stage: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientToGCRequestElevate").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientToGCRequestElevate {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_ClientToGCChat)
pub struct CMsgGCCStrike15_v2_ClientToGCChat {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientToGCChat.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_ClientToGCChat.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_ClientToGCChat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_ClientToGCChat {
    fn default() -> &'a CMsgGCCStrike15_v2_ClientToGCChat {
        <CMsgGCCStrike15_v2_ClientToGCChat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_ClientToGCChat {
    pub fn new() -> CMsgGCCStrike15_v2_ClientToGCChat {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "match_id",
            |m: &CMsgGCCStrike15_v2_ClientToGCChat| { &m.match_id },
            |m: &mut CMsgGCCStrike15_v2_ClientToGCChat| { &mut m.match_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CMsgGCCStrike15_v2_ClientToGCChat| { &m.text },
            |m: &mut CMsgGCCStrike15_v2_ClientToGCChat| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_ClientToGCChat>(
            "CMsgGCCStrike15_v2_ClientToGCChat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_ClientToGCChat {
    const NAME: &'static str = "CMsgGCCStrike15_v2_ClientToGCChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_ClientToGCChat {
        CMsgGCCStrike15_v2_ClientToGCChat::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_ClientToGCChat {
        static instance: CMsgGCCStrike15_v2_ClientToGCChat = CMsgGCCStrike15_v2_ClientToGCChat {
            match_id: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_ClientToGCChat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_ClientToGCChat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_ClientToGCChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_ClientToGCChat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:CMsgGCCStrike15_v2_GCToClientChat)
pub struct CMsgGCCStrike15_v2_GCToClientChat {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GCToClientChat.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCCStrike15_v2_GCToClientChat.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCCStrike15_v2_GCToClientChat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCCStrike15_v2_GCToClientChat {
    fn default() -> &'a CMsgGCCStrike15_v2_GCToClientChat {
        <CMsgGCCStrike15_v2_GCToClientChat as ::protobuf::Message>::default_instance()
    }
}

impl CMsgGCCStrike15_v2_GCToClientChat {
    pub fn new() -> CMsgGCCStrike15_v2_GCToClientChat {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "account_id",
            |m: &CMsgGCCStrike15_v2_GCToClientChat| { &m.account_id },
            |m: &mut CMsgGCCStrike15_v2_GCToClientChat| { &mut m.account_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_option_accessor::<_, _>(
            "text",
            |m: &CMsgGCCStrike15_v2_GCToClientChat| { &m.text },
            |m: &mut CMsgGCCStrike15_v2_GCToClientChat| { &mut m.text },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CMsgGCCStrike15_v2_GCToClientChat>(
            "CMsgGCCStrike15_v2_GCToClientChat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CMsgGCCStrike15_v2_GCToClientChat {
    const NAME: &'static str = "CMsgGCCStrike15_v2_GCToClientChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCCStrike15_v2_GCToClientChat {
        CMsgGCCStrike15_v2_GCToClientChat::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCCStrike15_v2_GCToClientChat {
        static instance: CMsgGCCStrike15_v2_GCToClientChat = CMsgGCCStrike15_v2_GCToClientChat {
            account_id: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CMsgGCCStrike15_v2_GCToClientChat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CMsgGCCStrike15_v2_GCToClientChat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CMsgGCCStrike15_v2_GCToClientChat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgGCCStrike15_v2_GCToClientChat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECsgoGCMsg)
pub enum ECsgoGCMsg {
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Base)
    k_EMsgGCCStrike15_v2_Base = 9100,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingStart)
    k_EMsgGCCStrike15_v2_MatchmakingStart = 9101,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingStop)
    k_EMsgGCCStrike15_v2_MatchmakingStop = 9102,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing)
    k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing = 9103,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate)
    k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = 9104,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve)
    k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve = 9105,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse)
    k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse = 9106,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve)
    k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = 9107,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats)
    k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats = 9108,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello)
    k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello = 9109,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello)
    k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello = 9110,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd)
    k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd = 9111,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon)
    k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = 9112,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick)
    k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick = 9113,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm)
    k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm = 9114,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats)
    k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats = 9115,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate)
    k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate = 9116,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate)
    k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = 9117,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty)
    k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty = 9118,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientReportPlayer)
    k_EMsgGCCStrike15_v2_ClientReportPlayer = 9119,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientReportServer)
    k_EMsgGCCStrike15_v2_ClientReportServer = 9120,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientCommendPlayer)
    k_EMsgGCCStrike15_v2_ClientCommendPlayer = 9121,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientReportResponse)
    k_EMsgGCCStrike15_v2_ClientReportResponse = 9122,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery)
    k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery = 9123,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse)
    k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse = 9124,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_WatchInfoUsers)
    k_EMsgGCCStrike15_v2_WatchInfoUsers = 9126,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile)
    k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile = 9127,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_PlayersProfile)
    k_EMsgGCCStrike15_v2_PlayersProfile = 9128,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_SetMyMedalsInfo)
    k_EMsgGCCStrike15_v2_SetMyMedalsInfo = 9129,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate)
    k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = 9131,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment)
    k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = 9132,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus)
    k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = 9133,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GC2ClientTextMsg)
    k_EMsgGCCStrike15_v2_GC2ClientTextMsg = 9134,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Client2GCTextMsg)
    k_EMsgGCCStrike15_v2_Client2GCTextMsg = 9135,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops)
    k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops = 9136,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification)
    k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification = 9137,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2)
    k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2 = 9138,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchList)
    k_EMsgGCCStrike15_v2_MatchList = 9139,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames)
    k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = 9140,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames)
    k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames = 9141,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate)
    k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate = 9142,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo)
    k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo = 9144,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification)
    k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification = 9145,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames)
    k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames = 9146,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo)
    k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo = 9147,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest)
    k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest = 9148,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse)
    k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse = 9149,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo)
    k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo = 9150,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCToGCReloadVersions)
    k_EMsgGCToGCReloadVersions = 9151,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote)
    k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote = 9152,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Server2GCClientValidate)
    k_EMsgGCCStrike15_v2_Server2GCClientValidate = 9153,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser)
    k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = 9154,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure)
    k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure = 9155,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest)
    k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = 9156,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse)
    k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = 9157,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_AccountPrivacySettings)
    k_EMsgGCCStrike15_v2_AccountPrivacySettings = 9158,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_SetMyActivityInfo)
    k_EMsgGCCStrike15_v2_SetMyActivityInfo = 9159,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions)
    k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions = 9160,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions)
    k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions = 9161,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_DraftSummary)
    k_EMsgGCCStrike15_v2_DraftSummary = 9162,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData)
    k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData = 9163,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientRequestJoinServerData)
    k_EMsgGCCStrike15_v2_ClientRequestJoinServerData = 9164,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientRequestNewMission)
    k_EMsgGCCStrike15_v2_ClientRequestNewMission = 9165,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded)
    k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded = 9166,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo)
    k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo = 9167,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGC_GlobalGame_Subscribe)
    k_EMsgGC_GlobalGame_Subscribe = 9168,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGC_GlobalGame_Unsubscribe)
    k_EMsgGC_GlobalGame_Unsubscribe = 9169,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGC_GlobalGame_Play)
    k_EMsgGC_GlobalGame_Play = 9170,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_AcknowledgePenalty)
    k_EMsgGCCStrike15_v2_AcknowledgePenalty = 9171,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin)
    k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = 9172,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GC2ClientGlobalStats)
    k_EMsgGCCStrike15_v2_GC2ClientGlobalStats = 9173,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_Client2GCStreamUnlock)
    k_EMsgGCCStrike15_v2_Client2GCStreamUnlock = 9174,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_FantasyRequestClientData)
    k_EMsgGCCStrike15_v2_FantasyRequestClientData = 9175,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_FantasyUpdateClientData)
    k_EMsgGCCStrike15_v2_FantasyUpdateClientData = 9176,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket)
    k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket = 9177,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientToGCRequestTicket)
    k_EMsgGCCStrike15_v2_ClientToGCRequestTicket = 9178,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_ClientToGCRequestElevate)
    k_EMsgGCCStrike15_v2_ClientToGCRequestElevate = 9179,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GlobalChat)
    k_EMsgGCCStrike15_v2_GlobalChat = 9180,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GlobalChat_Subscribe)
    k_EMsgGCCStrike15_v2_GlobalChat_Subscribe = 9181,
    // @@protoc_insertion_point(enum_value:ECsgoGCMsg.k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe)
    k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe = 9182,
}

impl ::protobuf::Enum for ECsgoGCMsg {
    const NAME: &'static str = "ECsgoGCMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECsgoGCMsg> {
        match value {
            9100 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Base),
            9101 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStart),
            9102 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStop),
            9103 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing),
            9104 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate),
            9105 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve),
            9106 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse),
            9107 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve),
            9108 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats),
            9109 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello),
            9110 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello),
            9111 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd),
            9112 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon),
            9113 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick),
            9114 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm),
            9115 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats),
            9116 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate),
            9117 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate),
            9118 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty),
            9119 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportPlayer),
            9120 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportServer),
            9121 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayer),
            9122 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportResponse),
            9123 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery),
            9124 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse),
            9126 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_WatchInfoUsers),
            9127 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile),
            9128 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayersProfile),
            9129 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetMyMedalsInfo),
            9131 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate),
            9132 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment),
            9133 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus),
            9134 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTextMsg),
            9135 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCTextMsg),
            9136 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops),
            9137 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification),
            9138 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2),
            9139 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchList),
            9140 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames),
            9141 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames),
            9142 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate),
            9144 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo),
            9145 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification),
            9146 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames),
            9147 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo),
            9148 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest),
            9149 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse),
            9150 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo),
            9151 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCToGCReloadVersions),
            9152 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote),
            9153 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCClientValidate),
            9154 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser),
            9155 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure),
            9156 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest),
            9157 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse),
            9158 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_AccountPrivacySettings),
            9159 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetMyActivityInfo),
            9160 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions),
            9161 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions),
            9162 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_DraftSummary),
            9163 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData),
            9164 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinServerData),
            9165 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestNewMission),
            9166 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded),
            9167 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo),
            9168 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGC_GlobalGame_Subscribe),
            9169 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGC_GlobalGame_Unsubscribe),
            9170 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGC_GlobalGame_Play),
            9171 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_AcknowledgePenalty),
            9172 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin),
            9173 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientGlobalStats),
            9174 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCStreamUnlock),
            9175 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyRequestClientData),
            9176 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyUpdateClientData),
            9177 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket),
            9178 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestTicket),
            9179 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestElevate),
            9180 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat),
            9181 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Subscribe),
            9182 => ::std::option::Option::Some(ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECsgoGCMsg] = &[
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Base,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStart,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStop,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportPlayer,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportServer,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayer,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportResponse,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_WatchInfoUsers,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayersProfile,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetMyMedalsInfo,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTextMsg,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCTextMsg,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchList,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo,
        ECsgoGCMsg::k_EMsgGCToGCReloadVersions,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCClientValidate,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_AccountPrivacySettings,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetMyActivityInfo,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_DraftSummary,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinServerData,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestNewMission,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo,
        ECsgoGCMsg::k_EMsgGC_GlobalGame_Subscribe,
        ECsgoGCMsg::k_EMsgGC_GlobalGame_Unsubscribe,
        ECsgoGCMsg::k_EMsgGC_GlobalGame_Play,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_AcknowledgePenalty,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientGlobalStats,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCStreamUnlock,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyRequestClientData,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyUpdateClientData,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestTicket,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestElevate,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Subscribe,
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe,
    ];
}

impl ::protobuf::EnumFull for ECsgoGCMsg {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ECsgoGCMsg").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Base => 0,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStart => 1,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingStop => 2,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing => 3,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate => 4,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve => 5,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse => 6,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve => 7,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats => 8,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello => 9,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello => 10,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd => 11,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon => 12,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick => 13,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm => 14,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats => 15,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate => 16,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate => 17,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty => 18,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportPlayer => 19,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportServer => 20,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayer => 21,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientReportResponse => 22,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery => 23,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse => 24,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_WatchInfoUsers => 25,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile => 26,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayersProfile => 27,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetMyMedalsInfo => 28,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate => 29,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment => 30,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus => 31,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTextMsg => 32,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCTextMsg => 33,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops => 34,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification => 35,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2 => 36,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchList => 37,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames => 38,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames => 39,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate => 40,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo => 41,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification => 42,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames => 43,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo => 44,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest => 45,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse => 46,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo => 47,
            ECsgoGCMsg::k_EMsgGCToGCReloadVersions => 48,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote => 49,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCClientValidate => 50,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser => 51,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure => 52,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest => 53,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse => 54,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_AccountPrivacySettings => 55,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_SetMyActivityInfo => 56,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions => 57,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions => 58,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_DraftSummary => 59,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData => 60,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestJoinServerData => 61,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientRequestNewMission => 62,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded => 63,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo => 64,
            ECsgoGCMsg::k_EMsgGC_GlobalGame_Subscribe => 65,
            ECsgoGCMsg::k_EMsgGC_GlobalGame_Unsubscribe => 66,
            ECsgoGCMsg::k_EMsgGC_GlobalGame_Play => 67,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_AcknowledgePenalty => 68,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin => 69,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GC2ClientGlobalStats => 70,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_Client2GCStreamUnlock => 71,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyRequestClientData => 72,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_FantasyUpdateClientData => 73,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket => 74,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestTicket => 75,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_ClientToGCRequestElevate => 76,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat => 77,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Subscribe => 78,
            ECsgoGCMsg::k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe => 79,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ECsgoGCMsg {
    fn default() -> Self {
        ECsgoGCMsg::k_EMsgGCCStrike15_v2_Base
    }
}

impl ECsgoGCMsg {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ECsgoGCMsg>("ECsgoGCMsg")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1acstrike15_gcmessages.proto\x1a\x13steammessages.proto\"\x8b\x01\n\
    \x0eGameServerPing\x12#\n\rgameserver_id\x18\x01\x20\x01(\x04R\x0cgamese\
    rverId\x12\x12\n\x04ping\x18\x02\x20\x01(\x05R\x04ping\x12\x0e\n\x02ip\
    \x18\x03\x20\x01(\rR\x02ip\x12\x12\n\x04port\x18\x04\x20\x01(\rR\x04port\
    \x12\x1c\n\tinstances\x18\x05\x20\x01(\rR\tinstances\"\x8b\x01\n\x17Deta\
    iledSearchStatistic\x12\x1b\n\tgame_type\x18\x01\x20\x01(\rR\x08gameType\
    \x12&\n\x0fsearch_time_avg\x18\x02\x20\x01(\rR\rsearchTimeAvg\x12+\n\x11\
    players_searching\x18\x04\x20\x01(\rR\x10playersSearching\"\xfd\x01\n\
    \x10TournamentPlayer\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountI\
    d\x12\x1f\n\x0bplayer_nick\x18\x02\x20\x01(\tR\nplayerNick\x12\x1f\n\x0b\
    player_name\x18\x03\x20\x01(\tR\nplayerName\x12\x1d\n\nplayer_dob\x18\
    \x04\x20\x01(\rR\tplayerDob\x12\x1f\n\x0bplayer_flag\x18\x05\x20\x01(\tR\
    \nplayerFlag\x12'\n\x0fplayer_location\x18\x06\x20\x01(\tR\x0eplayerLoca\
    tion\x12\x1f\n\x0bplayer_desc\x18\x07\x20\x01(\tR\nplayerDesc\"\xab\x01\
    \n\x0eTournamentTeam\x12\x17\n\x07team_id\x18\x01\x20\x01(\x05R\x06teamI\
    d\x12\x19\n\x08team_tag\x18\x02\x20\x01(\tR\x07teamTag\x12\x1b\n\tteam_f\
    lag\x18\x03\x20\x01(\tR\x08teamFlag\x12\x1b\n\tteam_name\x18\x04\x20\x01\
    (\tR\x08teamName\x12+\n\x07players\x18\x05\x20\x03(\x0b2\x11.TournamentP\
    layerR\x07players\"\xd7\x02\n\x0fTournamentEvent\x12\x19\n\x08event_id\
    \x18\x01\x20\x01(\x05R\x07eventId\x12\x1b\n\tevent_tag\x18\x02\x20\x01(\
    \tR\x08eventTag\x12\x1d\n\nevent_name\x18\x03\x20\x01(\tR\teventName\x12\
    (\n\x10event_time_start\x18\x04\x20\x01(\rR\x0eeventTimeStart\x12$\n\x0e\
    event_time_end\x18\x05\x20\x01(\rR\x0ceventTimeEnd\x12!\n\x0cevent_publi\
    c\x18\x06\x20\x01(\x05R\x0beventPublic\x12$\n\x0eevent_stage_id\x18\x07\
    \x20\x01(\x05R\x0ceventStageId\x12(\n\x10event_stage_name\x18\x08\x20\
    \x01(\tR\x0eeventStageName\x12*\n\x11active_section_id\x18\t\x20\x01(\rR\
    \x0factiveSectionId\"\xf7\x04\n\x10GlobalStatistics\x12%\n\x0eplayers_on\
    line\x18\x01\x20\x01(\rR\rplayersOnline\x12%\n\x0eservers_online\x18\x02\
    \x20\x01(\rR\rserversOnline\x12+\n\x11players_searching\x18\x03\x20\x01(\
    \rR\x10playersSearching\x12+\n\x11servers_available\x18\x04\x20\x01(\rR\
    \x10serversAvailable\x12'\n\x0fongoing_matches\x18\x05\x20\x01(\rR\x0eon\
    goingMatches\x12&\n\x0fsearch_time_avg\x18\x06\x20\x01(\rR\rsearchTimeAv\
    g\x12E\n\x11search_statistics\x18\x07\x20\x03(\x0b2\x18.DetailedSearchSt\
    atisticR\x10searchStatistics\x12\"\n\rmain_post_url\x18\x08\x20\x01(\tR\
    \x0bmainPostUrl\x124\n\x16required_appid_version\x18\t\x20\x01(\rR\x14re\
    quiredAppidVersion\x12-\n\x12pricesheet_version\x18\n\x20\x01(\rR\x11pri\
    cesheetVersion\x124\n\x16twitch_streams_version\x18\x0b\x20\x01(\rR\x14t\
    witchStreamsVersion\x12:\n\x19active_tournament_eventid\x18\x0c\x20\x01(\
    \rR\x17activeTournamentEventid\x12(\n\x10active_survey_id\x18\r\x20\x01(\
    \rR\x0eactiveSurveyId\"K\n\x1fOperationalStatisticDescription\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05idkey\x18\x02\x20\x01(\
    \rR\x05idkey\"K\n\x1bOperationalStatisticElement\x12\x14\n\x05idkey\x18\
    \x01\x20\x01(\rR\x05idkey\x12\x16\n\x06values\x18\x02\x20\x03(\x05R\x06v\
    alues\"\x91\x01\n\x1bOperationalStatisticsPacket\x12\x1a\n\x08packetid\
    \x18\x01\x20\x01(\x05R\x08packetid\x12\x20\n\x0bmstimestamp\x18\x02\x20\
    \x01(\x05R\x0bmstimestamp\x124\n\x06values\x18\x03\x20\x03(\x0b2\x1c.Ope\
    rationalStatisticElementR\x06values\"\x80\x01\n\x11PlayerRankingInfo\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x17\n\x07rank_id\
    \x18\x02\x20\x01(\rR\x06rankId\x12\x12\n\x04wins\x18\x03\x20\x01(\rR\x04\
    wins\x12\x1f\n\x0brank_change\x18\x04\x20\x01(\x02R\nrankChange\"}\n\x16\
    PlayerCommendationInfo\x12!\n\x0ccmd_friendly\x18\x01\x20\x01(\rR\x0bcmd\
    Friendly\x12!\n\x0ccmd_teaching\x18\x02\x20\x01(\rR\x0bcmdTeaching\x12\
    \x1d\n\ncmd_leader\x18\x04\x20\x01(\rR\tcmdLeader\"\xac\x02\n\x10PlayerM\
    edalsInfo\x12\x1d\n\nmedal_team\x18\x01\x20\x01(\rR\tmedalTeam\x12!\n\
    \x0cmedal_combat\x18\x02\x20\x01(\rR\x0bmedalCombat\x12!\n\x0cmedal_weap\
    on\x18\x03\x20\x01(\rR\x0bmedalWeapon\x12!\n\x0cmedal_global\x18\x04\x20\
    \x01(\rR\x0bmedalGlobal\x12\x1d\n\nmedal_arms\x18\x05\x20\x01(\rR\tmedal\
    Arms\x120\n\x14display_items_defidx\x18\x07\x20\x03(\rR\x12displayItemsD\
    efidx\x12?\n\x1cfeatured_display_item_defidx\x18\x08\x20\x01(\rR\x19feat\
    uredDisplayItemDefidx\"S\n\x0fAccountActivity\x12\x1a\n\x08activity\x18\
    \x01\x20\x01(\rR\x08activity\x12\x12\n\x04mode\x18\x02\x20\x01(\rR\x04mo\
    de\x12\x10\n\x03map\x18\x03\x20\x01(\rR\x03map\"\x91\x01\n\x14Tournament\
    MatchSetup\x12\x19\n\x08event_id\x18\x01\x20\x01(\x05R\x07eventId\x12\
    \x1c\n\nteam_id_ct\x18\x02\x20\x01(\x05R\x08teamIdCt\x12\x1a\n\tteam_id_\
    t\x18\x03\x20\x01(\x05R\x07teamIdT\x12$\n\x0eevent_stage_id\x18\x04\x20\
    \x01(\x05R\x0ceventStageId\"\xb9\x05\n\x0eServerHltvInfo\x12\x1e\n\x0btv\
    _udp_port\x18\x01\x20\x01(\rR\ttvUdpPort\x12\x20\n\x0ctv_watch_key\x18\
    \x02\x20\x01(\x04R\ntvWatchKey\x12\x19\n\x08tv_slots\x18\x03\x20\x01(\rR\
    \x07tvSlots\x12\x1d\n\ntv_clients\x18\x04\x20\x01(\rR\ttvClients\x12\x1d\
    \n\ntv_proxies\x18\x05\x20\x01(\rR\ttvProxies\x12\x17\n\x07tv_time\x18\
    \x06\x20\x01(\rR\x06tvTime\x12\x1b\n\tgame_type\x18\x08\x20\x01(\rR\x08g\
    ameType\x12#\n\rgame_mapgroup\x18\t\x20\x01(\tR\x0cgameMapgroup\x12\x19\
    \n\x08game_map\x18\n\x20\x01(\tR\x07gameMap\x12*\n\x11tv_master_steamid\
    \x18\x0b\x20\x01(\x04R\x0ftvMasterSteamid\x12$\n\x0etv_local_slots\x18\
    \x0c\x20\x01(\rR\x0ctvLocalSlots\x12(\n\x10tv_local_clients\x18\r\x20\
    \x01(\rR\x0etvLocalClients\x12(\n\x10tv_local_proxies\x18\x0e\x20\x01(\r\
    R\x0etvLocalProxies\x12$\n\x0etv_relay_slots\x18\x0f\x20\x01(\rR\x0ctvRe\
    laySlots\x12(\n\x10tv_relay_clients\x18\x10\x20\x01(\rR\x0etvRelayClient\
    s\x12(\n\x10tv_relay_proxies\x18\x11\x20\x01(\rR\x0etvRelayProxies\x12(\
    \n\x10tv_relay_address\x18\x12\x20\x01(\rR\x0etvRelayAddress\x12\"\n\rtv\
    _relay_port\x18\x13\x20\x01(\rR\x0btvRelayPort\x12(\n\x10tv_relay_steami\
    d\x18\x14\x20\x01(\x04R\x0etvRelaySteamid\"q\n\rIpAddressMask\x12\x0c\n\
    \x01a\x18\x01\x20\x01(\rR\x01a\x12\x0c\n\x01b\x18\x02\x20\x01(\rR\x01b\
    \x12\x0c\n\x01c\x18\x03\x20\x01(\rR\x01c\x12\x0c\n\x01d\x18\x04\x20\x01(\
    \rR\x01d\x12\x12\n\x04bits\x18\x05\x20\x01(\rR\x04bits\x12\x14\n\x05toke\
    n\x18\x06\x20\x01(\rR\x05token\"N\n\x0eXpProgressData\x12\x1b\n\txp_poin\
    ts\x18\x01\x20\x01(\rR\x08xpPoints\x12\x1f\n\x0bxp_category\x18\x02\x20\
    \x01(\x05R\nxpCategory\"\x8b\x01\n\x13MatchEndItemUpdates\x12\x17\n\x07i\
    tem_id\x18\x01\x20\x01(\x04R\x06itemId\x12(\n\x10item_attr_defidx\x18\
    \x02\x20\x01(\rR\x0eitemAttrDefidx\x121\n\x15item_attr_delta_value\x18\
    \x03\x20\x01(\rR\x12itemAttrDeltaValue\"\xea\x02\n\x14ScoreLeaderboardDa\
    ta\x12\x19\n\x08quest_id\x18\x01\x20\x01(\x04R\x07questId\x12\x14\n\x05s\
    core\x18\x02\x20\x01(\rR\x05score\x12L\n\x0eaccountentries\x18\x03\x20\
    \x03(\x0b2$.ScoreLeaderboardData.AccountEntriesR\x0eaccountentries\x12?\
    \n\x0cmatchentries\x18\x05\x20\x03(\x0b2\x1b.ScoreLeaderboardData.EntryR\
    \x0cmatchentries\x1a+\n\x05Entry\x12\x10\n\x03tag\x18\x01\x20\x01(\rR\
    \x03tag\x12\x10\n\x03val\x18\x02\x20\x01(\rR\x03val\x1ae\n\x0eAccountEnt\
    ries\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\x125\n\x07entri\
    es\x18\x02\x20\x03(\x0b2\x1b.ScoreLeaderboardData.EntryR\x07entries\"\
    \xe3\x03\n\x0fPlayerQuestData\x12,\n\x12quester_account_id\x18\x01\x20\
    \x01(\rR\x10questerAccountId\x12F\n\x0fquest_item_data\x18\x02\x20\x03(\
    \x0b2\x1e.PlayerQuestData.QuestItemDataR\rquestItemData\x129\n\x10xp_pro\
    gress_data\x18\x03\x20\x03(\x0b2\x0f.XpProgressDataR\x0expProgressData\
    \x12\x1f\n\x0btime_played\x18\x04\x20\x01(\rR\ntimePlayed\x12\x20\n\x0cm\
    m_game_mode\x18\x05\x20\x01(\rR\nmmGameMode\x127\n\x0citem_updates\x18\
    \x06\x20\x03(\x0b2\x14.MatchEndItemUpdatesR\x0bitemUpdates\x1a\xa2\x01\n\
    \rQuestItemData\x12\x19\n\x08quest_id\x18\x01\x20\x01(\x04R\x07questId\
    \x12;\n\x1aquest_normal_points_earned\x18\x02\x20\x01(\x05R\x17questNorm\
    alPointsEarned\x129\n\x19quest_bonus_points_earned\x18\x03\x20\x01(\x05R\
    \x16questBonusPointsEarned\"\xde\x01\n\x1cCMsgGC_ServerQuestUpdateData\
    \x12<\n\x11player_quest_data\x18\x01\x20\x03(\x0b2\x10.PlayerQuestDataR\
    \x0fplayerQuestData\x12\x1f\n\x0bbinary_data\x18\x02\x20\x01(\x0cR\nbina\
    ryData\x12\x20\n\x0cmm_game_mode\x18\x03\x20\x01(\rR\nmmGameMode\x12=\n\
    \x0emissionlbsdata\x18\x04\x20\x01(\x0b2\x15.ScoreLeaderboardDataR\x0emi\
    ssionlbsdata\"\xc4\x01\n0CMsgGCCStrike15_v2_MatchmakingGCOperationalStat\
    s\x12\x1a\n\x08packetid\x18\x01\x20\x01(\x05R\x08packetid\x12<\n\x08name\
    keys\x18\x02\x20\x03(\x0b2\x20.OperationalStatisticDescriptionR\x08namek\
    eys\x126\n\x07packets\x18\x03\x20\x03(\x0b2\x1c.OperationalStatisticsPac\
    ketR\x07packets\"x\n.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\x12\
    \x14\n\x05token\x18\x01\x20\x01(\rR\x05token\x12\x14\n\x05stamp\x18\x02\
    \x20\x01(\rR\x05stamp\x12\x1a\n\x08exchange\x18\x03\x20\x01(\x04R\x08exc\
    hange\"\x9b\x01\n-CMsgGCCStrike15_v2_GC2ServerReservationUpdate\x124\n\
    \x16viewers_external_total\x18\x01\x20\x01(\rR\x14viewersExternalTotal\
    \x124\n\x16viewers_external_steam\x18\x02\x20\x01(\rR\x14viewersExternal\
    Steam\"\xed\x01\n#CMsgGCCStrike15_v2_MatchmakingStart\x12\x1f\n\x0baccou\
    nt_ids\x18\x01\x20\x03(\rR\naccountIds\x12\x1b\n\tgame_type\x18\x02\x20\
    \x01(\rR\x08gameType\x12\x1f\n\x0bticket_data\x18\x03\x20\x01(\tR\nticke\
    tData\x12%\n\x0eclient_version\x18\x04\x20\x01(\rR\rclientVersion\x12@\n\
    \x10tournament_match\x18\x05\x20\x01(\x0b2\x15.TournamentMatchSetupR\x0f\
    tournamentMatch\">\n\"CMsgGCCStrike15_v2_MatchmakingStop\x12\x18\n\x07ab\
    andon\x18\x01\x20\x01(\x05R\x07abandon\"\xb0\x01\n/CMsgGCCStrike15_v2_Ma\
    tchmakingClient2ServerPing\x129\n\x0fgameserverpings\x18\x01\x20\x03(\
    \x0b2\x0f.GameServerPingR\x0fgameserverpings\x12!\n\x0coffset_index\x18\
    \x02\x20\x01(\x05R\x0boffsetIndex\x12\x1f\n\x0bfinal_batch\x18\x03\x20\
    \x01(\x05R\nfinalBatch\"\xb3\x07\n-CMsgGCCStrike15_v2_MatchmakingGC2Clie\
    ntUpdate\x12\x20\n\x0bmatchmaking\x18\x01\x20\x01(\x05R\x0bmatchmaking\
    \x12=\n\x1bwaiting_account_id_sessions\x18\x02\x20\x03(\rR\x18waitingAcc\
    ountIdSessions\x12\x14\n\x05error\x18\x03\x20\x01(\tR\x05error\x12G\n\
    \x20ongoingmatch_account_id_sessions\x18\x06\x20\x03(\rR\x1dongoingmatch\
    AccountIdSessions\x124\n\x0cglobal_stats\x18\x07\x20\x01(\x0b2\x11.Globa\
    lStatisticsR\x0bglobalStats\x12?\n\x1cfailping_account_id_sessions\x18\
    \x08\x20\x03(\rR\x19failpingAccountIdSessions\x12=\n\x1bpenalty_account_\
    id_sessions\x18\t\x20\x03(\rR\x18penaltyAccountIdSessions\x12A\n\x1dfail\
    ready_account_id_sessions\x18\n\x20\x03(\rR\x1afailreadyAccountIdSession\
    s\x12A\n\x1dvacbanned_account_id_sessions\x18\x0b\x20\x03(\rR\x1avacbann\
    edAccountIdSessions\x12B\n\x15server_ipaddress_mask\x18\x0c\x20\x01(\x0b\
    2\x0e.IpAddressMaskR\x13serverIpaddressMask\x12I\n\x05notes\x18\r\x20\
    \x03(\x0b23.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.NoteR\x05notes\
    \x12H\n!penalty_account_id_sessions_green\x18\x0e\x20\x03(\rR\x1dpenalty\
    AccountIdSessionsGreen\x12=\n\x1ainsufficientlevel_sessions\x18\x0f\x20\
    \x03(\rR\x19insufficientlevelSessions\x1an\n\x04Note\x12\x12\n\x04type\
    \x18\x01\x20\x01(\x05R\x04type\x12\x1b\n\tregion_id\x18\x02\x20\x01(\x05\
    R\x08regionId\x12\x19\n\x08region_r\x18\x03\x20\x01(\x02R\x07regionR\x12\
    \x1a\n\x08distance\x18\x04\x20\x01(\x02R\x08distance\"\xd7\x03\n(CDataGC\
    CStrike15_v2_TournamentMatchDraft\x12\x19\n\x08event_id\x18\x01\x20\x01(\
    \x05R\x07eventId\x12$\n\x0eevent_stage_id\x18\x02\x20\x01(\x05R\x0cevent\
    StageId\x12\x1a\n\tteam_id_0\x18\x03\x20\x01(\x05R\x07teamId0\x12\x1a\n\
    \tteam_id_1\x18\x04\x20\x01(\x05R\x07teamId1\x12\x1d\n\nmaps_count\x18\
    \x05\x20\x01(\x05R\tmapsCount\x12!\n\x0cmaps_current\x18\x06\x20\x01(\
    \x05R\x0bmapsCurrent\x12\"\n\rteam_id_start\x18\x07\x20\x01(\x05R\x0btea\
    mIdStart\x12\"\n\rteam_id_veto1\x18\x08\x20\x01(\x05R\x0bteamIdVeto1\x12\
    \"\n\rteam_id_pickn\x18\t\x20\x01(\x05R\x0bteamIdPickn\x12G\n\x06drafts\
    \x18\n\x20\x03(\x0b2/.CDataGCCStrike15_v2_TournamentMatchDraft.EntryR\
    \x06drafts\x1a;\n\x05Entry\x12\x14\n\x05mapid\x18\x01\x20\x01(\x05R\x05m\
    apid\x12\x1c\n\nteam_id_ct\x18\x02\x20\x01(\x05R\x08teamIdCt\"\xbb\x02\n\
    \x11CPreMatchInfoData\x12'\n\x0fpredictions_pct\x18\x01\x20\x01(\x05R\
    \x0epredictionsPct\x12?\n\x05draft\x18\x04\x20\x01(\x0b2).CDataGCCStrike\
    15_v2_TournamentMatchDraftR\x05draft\x122\n\x05stats\x18\x05\x20\x03(\
    \x0b2\x1c.CPreMatchInfoData.TeamStatsR\x05stats\x1a\x87\x01\n\tTeamStats\
    \x12*\n\x11match_info_idxtxt\x18\x01\x20\x01(\x05R\x0fmatchInfoIdxtxt\
    \x12$\n\x0ematch_info_txt\x18\x02\x20\x01(\tR\x0cmatchInfoTxt\x12(\n\x10\
    match_info_teams\x18\x03\x20\x03(\tR\x0ematchInfoTeams\"\xce\x05\n.CMsgG\
    CCStrike15_v2_MatchmakingGC2ServerReserve\x12\x1f\n\x0baccount_ids\x18\
    \x01\x20\x03(\rR\naccountIds\x12\x1b\n\tgame_type\x18\x02\x20\x01(\rR\
    \x08gameType\x12\x19\n\x08match_id\x18\x03\x20\x01(\x04R\x07matchId\x12%\
    \n\x0eserver_version\x18\x04\x20\x01(\rR\rserverVersion\x12.\n\x08rankin\
    gs\x18\x05\x20\x03(\x0b2\x12.PlayerRankingInfoR\x08rankings\x12%\n\x0een\
    cryption_key\x18\x06\x20\x01(\x04R\rencryptionKey\x12,\n\x12encryption_k\
    ey_pub\x18\x07\x20\x01(\x04R\x10encryptionKeyPub\x12\x1b\n\tparty_ids\
    \x18\x08\x20\x03(\rR\x08partyIds\x12,\n\twhitelist\x18\t\x20\x03(\x0b2\
    \x0e.IpAddressMaskR\twhitelist\x12*\n\x11tv_master_steamid\x18\n\x20\x01\
    (\x04R\x0ftvMasterSteamid\x12;\n\x10tournament_event\x18\x0b\x20\x01(\
    \x0b2\x10.TournamentEventR\x0ftournamentEvent\x12:\n\x10tournament_teams\
    \x18\x0c\x20\x03(\x0b2\x0f.TournamentTeamR\x0ftournamentTeams\x12C\n\x1e\
    tournament_casters_account_ids\x18\r\x20\x03(\rR\x1btournamentCastersAcc\
    ountIds\x12(\n\x10tv_relay_steamid\x18\x0e\x20\x01(\x04R\x0etvRelaySteam\
    id\x128\n\x0epre_match_data\x18\x0f\x20\x01(\x0b2\x12.CPreMatchInfoDataR\
    \x0cpreMatchData\"\xa9\x05\n7CMsgGCCStrike15_v2_MatchmakingServerReserva\
    tionResponse\x12$\n\rreservationid\x18\x01\x20\x01(\x04R\rreservationid\
    \x12Q\n\x0breservation\x18\x02\x20\x01(\x0b2/.CMsgGCCStrike15_v2_Matchma\
    kingGC2ServerReserveR\x0breservation\x12\x10\n\x03map\x18\x03\x20\x01(\t\
    R\x03map\x12.\n\x13gc_reservation_sent\x18\x04\x20\x01(\x04R\x11gcReserv\
    ationSent\x12%\n\x0eserver_version\x18\x05\x20\x01(\rR\rserverVersion\
    \x12(\n\x07tv_info\x18\x06\x20\x01(\x0b2\x0f.ServerHltvInfoR\x06tvInfo\
    \x124\n\x16reward_player_accounts\x18\x07\x20\x03(\rR\x14rewardPlayerAcc\
    ounts\x120\n\x14idle_player_accounts\x18\x08\x20\x03(\rR\x12idlePlayerAc\
    counts\x126\n\x18reward_item_attr_def_idx\x18\t\x20\x01(\rR\x14rewardIte\
    mAttrDefIdx\x123\n\x16reward_item_attr_value\x18\n\x20\x01(\rR\x13reward\
    ItemAttrValue\x12<\n\x1breward_item_attr_reward_idx\x18\x0b\x20\x01(\rR\
    \x17rewardItemAttrRewardIdx\x12(\n\x10reward_drop_list\x18\x0c\x20\x01(\
    \rR\x0erewardDropList\x12%\n\x0etournament_tag\x18\r\x20\x01(\tR\rtourna\
    mentTag\"\xfe\x01\n.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\x12\
    \x1a\n\x08serverid\x18\x01\x20\x01(\x04R\x08serverid\x12$\n\rreservation\
    id\x18\x04\x20\x01(\x04R\rreservationid\x12Q\n\x0breservation\x18\x05\
    \x20\x01(\x0b2/.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserveR\x0breser\
    vation\x12\x10\n\x03map\x18\x06\x20\x01(\tR\x03map\x12%\n\x0eserver_addr\
    ess\x18\x07\x20\x01(\tR\rserverAddress\"\xbb\x08\n.CMsgGCCStrike15_v2_Ma\
    tchmakingServerRoundStats\x12$\n\rreservationid\x18\x01\x20\x01(\x04R\rr\
    eservationid\x12Q\n\x0breservation\x18\x02\x20\x01(\x0b2/.CMsgGCCStrike1\
    5_v2_MatchmakingGC2ServerReserveR\x0breservation\x12\x10\n\x03map\x18\
    \x03\x20\x01(\tR\x03map\x12\x14\n\x05round\x18\x04\x20\x01(\x05R\x05roun\
    d\x12\x14\n\x05kills\x18\x05\x20\x03(\x05R\x05kills\x12\x18\n\x07assists\
    \x18\x06\x20\x03(\x05R\x07assists\x12\x16\n\x06deaths\x18\x07\x20\x03(\
    \x05R\x06deaths\x12\x16\n\x06scores\x18\x08\x20\x03(\x05R\x06scores\x12\
    \x14\n\x05pings\x18\t\x20\x03(\x05R\x05pings\x12!\n\x0cround_result\x18\
    \n\x20\x01(\x05R\x0broundResult\x12!\n\x0cmatch_result\x18\x0b\x20\x01(\
    \x05R\x0bmatchResult\x12\x1f\n\x0bteam_scores\x18\x0c\x20\x03(\x05R\ntea\
    mScores\x12I\n\x07confirm\x18\r\x20\x01(\x0b2/.CMsgGCCStrike15_v2_Matchm\
    akingGC2ServerConfirmR\x07confirm\x12+\n\x11reservation_stage\x18\x0e\
    \x20\x01(\x05R\x10reservationStage\x12%\n\x0ematch_duration\x18\x0f\x20\
    \x01(\x05R\rmatchDuration\x12\x1f\n\x0benemy_kills\x18\x10\x20\x03(\x05R\
    \nenemyKills\x12'\n\x0fenemy_headshots\x18\x11\x20\x03(\x05R\x0eenemyHea\
    dshots\x12\x1b\n\tenemy_3ks\x18\x12\x20\x03(\x05R\x08enemy3ks\x12\x1b\n\
    \tenemy_4ks\x18\x13\x20\x03(\x05R\x08enemy4ks\x12\x1b\n\tenemy_5ks\x18\
    \x14\x20\x03(\x05R\x08enemy5ks\x12\x12\n\x04mvps\x18\x15\x20\x03(\x05R\
    \x04mvps\x12)\n\x10spectators_count\x18\x16\x20\x01(\rR\x0fspectatorsCou\
    nt\x12.\n\x13spectators_count_tv\x18\x17\x20\x01(\rR\x11spectatorsCountT\
    v\x120\n\x14spectators_count_lnk\x18\x18\x20\x01(\rR\x12spectatorsCountL\
    nk\x12&\n\x0fenemy_kills_agg\x18\x19\x20\x03(\x05R\renemyKillsAgg\x12U\n\
    \tdrop_info\x18\x1a\x20\x01(\x0b28.CMsgGCCStrike15_v2_MatchmakingServerR\
    oundStats.DropInfoR\x08dropInfo\x1a+\n\x08DropInfo\x12\x1f\n\x0baccount_\
    mvp\x18\x01\x20\x01(\rR\naccountMvp\"\xc5\x03\n,CMsgGCCStrike15_v2_Match\
    makingServerMatchEnd\x12E\n\x05stats\x18\x01\x20\x01(\x0b2/.CMsgGCCStrik\
    e15_v2_MatchmakingServerRoundStatsR\x05stats\x12I\n\x07confirm\x18\x03\
    \x20\x01(\x0b2/.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirmR\x07confi\
    rm\x12\x18\n\x07rematch\x18\x04\x20\x01(\x04R\x07rematch\x12!\n\x0crepla\
    y_token\x18\x05\x20\x01(\rR\x0breplayToken\x12*\n\x11replay_cluster_id\
    \x18\x06\x20\x01(\rR\x0freplayClusterId\x12#\n\raborted_match\x18\x07\
    \x20\x01(\x08R\x0cabortedMatch\x12N\n\x14match_end_quest_data\x18\x08\
    \x20\x01(\x0b2\x1d.CMsgGC_ServerQuestUpdateDataR\x11matchEndQuestData\
    \x12%\n\x0eserver_version\x18\t\x20\x01(\rR\rserverVersion\".\n,CMsgGCCS\
    trike15_v2_MatchmakingClient2GCHello\"\xaa\x07\n,CMsgGCCStrike15_v2_Matc\
    hmakingGC2ClientHello\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccount\
    Id\x12S\n\x0congoingmatch\x18\x02\x20\x01(\x0b2/.CMsgGCCStrike15_v2_Matc\
    hmakingGC2ClientReserveR\x0congoingmatch\x124\n\x0cglobal_stats\x18\x03\
    \x20\x01(\x0b2\x11.GlobalStatisticsR\x0bglobalStats\x12'\n\x0fpenalty_se\
    conds\x18\x04\x20\x01(\rR\x0epenaltySeconds\x12%\n\x0epenalty_reason\x18\
    \x05\x20\x01(\rR\rpenaltyReason\x12\x1d\n\nvac_banned\x18\x06\x20\x01(\
    \x05R\tvacBanned\x12,\n\x07ranking\x18\x07\x20\x01(\x0b2\x12.PlayerRanki\
    ngInfoR\x07ranking\x12;\n\x0ccommendation\x18\x08\x20\x01(\x0b2\x17.Play\
    erCommendationInfoR\x0ccommendation\x12)\n\x06medals\x18\t\x20\x01(\x0b2\
    \x11.PlayerMedalsInfoR\x06medals\x12:\n\x10my_current_event\x18\n\x20\
    \x01(\x0b2\x10.TournamentEventR\x0emyCurrentEvent\x12D\n\x16my_current_e\
    vent_teams\x18\x0b\x20\x03(\x0b2\x0f.TournamentTeamR\x13myCurrentEventTe\
    ams\x127\n\x0fmy_current_team\x18\x0c\x20\x01(\x0b2\x0f.TournamentTeamR\
    \rmyCurrentTeam\x12G\n\x17my_current_event_stages\x18\r\x20\x03(\x0b2\
    \x10.TournamentEventR\x14myCurrentEventStages\x12\x1f\n\x0bsurvey_vote\
    \x18\x0e\x20\x01(\rR\nsurveyVote\x12,\n\x08activity\x18\x0f\x20\x01(\x0b\
    2\x10.AccountActivityR\x08activity\x12!\n\x0cplayer_level\x18\x11\x20\
    \x01(\x05R\x0bplayerLevel\x12\"\n\rplayer_cur_xp\x18\x12\x20\x01(\x05R\
    \x0bplayerCurXp\x121\n\x15player_xp_bonus_flags\x18\x13\x20\x01(\x05R\
    \x12playerXpBonusFlags\"\xce\x01\n)CMsgGCCStrike15_v2_AccountPrivacySett\
    ings\x12N\n\x08settings\x18\x01\x20\x03(\x0b22.CMsgGCCStrike15_v2_Accoun\
    tPrivacySettings.SettingR\x08settings\x1aQ\n\x07Setting\x12!\n\x0csettin\
    g_type\x18\x01\x20\x01(\rR\x0bsettingType\x12#\n\rsetting_value\x18\x02\
    \x20\x01(\rR\x0csettingValue\"\xf9\x01\n.CMsgGCCStrike15_v2_MatchmakingG\
    C2ClientAbandon\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\
    X\n\x0fabandoned_match\x18\x02\x20\x01(\x0b2/.CMsgGCCStrike15_v2_Matchma\
    kingGC2ClientReserveR\x0eabandonedMatch\x12'\n\x0fpenalty_seconds\x18\
    \x03\x20\x01(\rR\x0epenaltySeconds\x12%\n\x0epenalty_reason\x18\x04\x20\
    \x01(\rR\rpenaltyReason\"\xb7\x01\n+CMsgGCCStrike15_v2_MatchmakingServer\
    2GCKick\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12Q\n\x0br\
    eservation\x18\x02\x20\x01(\x0b2/.CMsgGCCStrike15_v2_MatchmakingGC2Serve\
    rReserveR\x0breservation\x12\x16\n\x06reason\x18\x03\x20\x01(\rR\x06reas\
    on\"~\n1CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\x12.\n\x08rank\
    ings\x18\x01\x20\x03(\x0b2\x12.PlayerRankingInfoR\x08rankings\x12\x19\n\
    \x08match_id\x18\x02\x20\x01(\x04R\x07matchId\"Y\n3CMsgGCCStrike15_v2_Ma\
    tchmakingOperator2GCBlogUpdate\x12\"\n\rmain_post_url\x18\x01\x20\x01(\t\
    R\x0bmainPostUrl\"\x86\x01\n3CMsgGCCStrike15_v2_ServerNotificationForUse\
    rPenalty\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x16\n\
    \x06reason\x18\x02\x20\x01(\rR\x06reason\x12\x18\n\x07seconds\x18\x03\
    \x20\x01(\rR\x07seconds\"\xb7\x02\n%CMsgGCCStrike15_v2_ClientReportPlaye\
    r\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x1d\n\nrpt_ai\
    mbot\x18\x02\x20\x01(\rR\trptAimbot\x12!\n\x0crpt_wallhack\x18\x03\x20\
    \x01(\rR\x0brptWallhack\x12#\n\rrpt_speedhack\x18\x04\x20\x01(\rR\x0crpt\
    Speedhack\x12!\n\x0crpt_teamharm\x18\x05\x20\x01(\rR\x0brptTeamharm\x12#\
    \n\rrpt_textabuse\x18\x06\x20\x01(\rR\x0crptTextabuse\x12%\n\x0erpt_voic\
    eabuse\x18\x07\x20\x01(\rR\rrptVoiceabuse\x12\x19\n\x08match_id\x18\x08\
    \x20\x01(\x04R\x07matchId\"\xb7\x01\n&CMsgGCCStrike15_v2_ClientCommendPl\
    ayer\x12\x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x19\n\x08m\
    atch_id\x18\x08\x20\x01(\x04R\x07matchId\x12;\n\x0ccommendation\x18\t\
    \x20\x01(\x0b2\x17.PlayerCommendationInfoR\x0ccommendation\x12\x16\n\x06\
    tokens\x18\n\x20\x01(\rR\x06tokens\"\x8d\x02\n%CMsgGCCStrike15_v2_Client\
    ReportServer\x12!\n\x0crpt_poorperf\x18\x01\x20\x01(\rR\x0brptPoorperf\
    \x12+\n\x11rpt_abusivemodels\x18\x02\x20\x01(\rR\x10rptAbusivemodels\x12\
    \x1f\n\x0brpt_badmotd\x18\x03\x20\x01(\rR\nrptBadmotd\x12)\n\x10rpt_list\
    ingabuse\x18\x04\x20\x01(\rR\x0frptListingabuse\x12-\n\x12rpt_inventorya\
    buse\x18\x05\x20\x01(\rR\x11rptInventoryabuse\x12\x19\n\x08match_id\x18\
    \x08\x20\x01(\x04R\x07matchId\"\xf4\x01\n'CMsgGCCStrike15_v2_ClientRepor\
    tResponse\x12'\n\x0fconfirmation_id\x18\x01\x20\x01(\x04R\x0econfirmatio\
    nId\x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\taccountId\x12\x1b\n\tserv\
    er_ip\x18\x03\x20\x01(\rR\x08serverIp\x12#\n\rresponse_type\x18\x04\x20\
    \x01(\rR\x0cresponseType\x12'\n\x0fresponse_result\x18\x05\x20\x01(\rR\
    \x0eresponseResult\x12\x16\n\x06tokens\x18\x06\x20\x01(\rR\x06tokens\"\
    \xa8\x01\n0CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\x12\x1d\n\nr\
    equest_id\x18\x01\x20\x01(\rR\trequestId\x12\x1f\n\x0baccount_ids\x18\
    \x02\x20\x03(\rR\naccountIds\x12\x1a\n\x08serverid\x18\x03\x20\x01(\x04R\
    \x08serverid\x12\x18\n\x07matchid\x18\x04\x20\x01(\x04R\x07matchid\"\xd3\
    \x03\n\x12WatchableMatchInfo\x12\x1b\n\tserver_ip\x18\x01\x20\x01(\rR\
    \x08serverIp\x12\x17\n\x07tv_port\x18\x02\x20\x01(\rR\x06tvPort\x12#\n\r\
    tv_spectators\x18\x03\x20\x01(\rR\x0ctvSpectators\x12\x17\n\x07tv_time\
    \x18\x04\x20\x01(\rR\x06tvTime\x12*\n\x11tv_watch_password\x18\x05\x20\
    \x01(\x0cR\x0ftvWatchPassword\x12,\n\x12cl_decryptdata_key\x18\x06\x20\
    \x01(\x04R\x10clDecryptdataKey\x123\n\x16cl_decryptdata_key_pub\x18\x07\
    \x20\x01(\x04R\x13clDecryptdataKeyPub\x12\x1b\n\tgame_type\x18\x08\x20\
    \x01(\rR\x08gameType\x12#\n\rgame_mapgroup\x18\t\x20\x01(\tR\x0cgameMapg\
    roup\x12\x19\n\x08game_map\x18\n\x20\x01(\tR\x07gameMap\x12\x1b\n\tserve\
    r_id\x18\x0b\x20\x01(\x04R\x08serverId\x12\x19\n\x08match_id\x18\x0c\x20\
    \x01(\x04R\x07matchId\x12%\n\x0ereservation_id\x18\r\x20\x01(\x04R\rrese\
    rvationId\"\x82\x02\n.CMsgGCCStrike15_v2_ClientRequestJoinFriendData\x12\
    \x18\n\x07version\x18\x01\x20\x01(\rR\x07version\x12\x1d\n\naccount_id\
    \x18\x02\x20\x01(\rR\taccountId\x12\x1d\n\njoin_token\x18\x03\x20\x01(\r\
    R\tjoinToken\x12\x19\n\x08join_ipp\x18\x04\x20\x01(\rR\x07joinIpp\x12A\n\
    \x03res\x18\x05\x20\x01(\x0b2/.CMsgGCCStrike15_v2_MatchmakingGC2ClientRe\
    serveR\x03res\x12\x1a\n\x08errormsg\x18\x06\x20\x01(\tR\x08errormsg\"\
    \x86\x02\n.CMsgGCCStrike15_v2_ClientRequestJoinServerData\x12\x18\n\x07v\
    ersion\x18\x01\x20\x01(\rR\x07version\x12\x1d\n\naccount_id\x18\x02\x20\
    \x01(\rR\taccountId\x12\x1a\n\x08serverid\x18\x03\x20\x01(\x04R\x08serve\
    rid\x12\x1b\n\tserver_ip\x18\x04\x20\x01(\rR\x08serverIp\x12\x1f\n\x0bse\
    rver_port\x18\x05\x20\x01(\rR\nserverPort\x12A\n\x03res\x18\x06\x20\x01(\
    \x0b2/.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserveR\x03res\"l\n*CMsgG\
    CCstrike15_v2_ClientRequestNewMission\x12\x1d\n\nmission_id\x18\x02\x20\
    \x01(\rR\tmissionId\x12\x1f\n\x0bcampaign_id\x18\x03\x20\x01(\rR\ncampai\
    gnId\"\xf5\x01\n,CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\x129\n\x10\
    xp_progress_data\x18\x01\x20\x03(\x0b2\x0f.XpProgressDataR\x0expProgress\
    Data\x12\x1d\n\naccount_id\x18\x02\x20\x01(\rR\taccountId\x12\x1d\n\ncur\
    rent_xp\x18\x03\x20\x01(\rR\tcurrentXp\x12#\n\rcurrent_level\x18\x04\x20\
    \x01(\rR\x0ccurrentLevel\x12'\n\x0fupgraded_defidx\x18\x05\x20\x01(\rR\
    \x0eupgradedDefidx\"\xd7\x01\n!CMsgGCCStrike15_v2_WatchInfoUsers\x12\x1d\
    \n\nrequest_id\x18\x01\x20\x01(\rR\trequestId\x12\x1f\n\x0baccount_ids\
    \x18\x02\x20\x03(\rR\naccountIds\x12G\n\x15watchable_match_infos\x18\x03\
    \x20\x03(\x0b2\x13.WatchableMatchInfoR\x13watchableMatchInfos\x12)\n\x10\
    extended_timeout\x18\x05\x20\x01(\rR\x0fextendedTimeout\"\xe0\x01\n.CMsg\
    GCCStrike15_v2_ClientRequestPlayersProfile\x123\n\x16request_id__depreca\
    ted\x18\x01\x20\x01(\rR\x13requestIdDeprecated\x125\n\x17account_ids__de\
    precated\x18\x02\x20\x03(\rR\x14accountIdsDeprecated\x12\x1d\n\naccount_\
    id\x18\x03\x20\x01(\rR\taccountId\x12#\n\rrequest_level\x18\x04\x20\x01(\
    \rR\x0crequestLevel\"\x9c\x01\n!CMsgGCCStrike15_v2_PlayersProfile\x12\
    \x1d\n\nrequest_id\x18\x01\x20\x01(\rR\trequestId\x12X\n\x10account_prof\
    iles\x18\x02\x20\x03(\x0b2-.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\
    R\x0faccountProfiles\"\xa6\x02\n,CMsgGCCStrike15_v2_PlayerOverwatchCaseU\
    pdate\x12\x16\n\x06caseid\x18\x01\x20\x01(\x04R\x06caseid\x12\x1c\n\tsus\
    pectid\x18\x03\x20\x01(\rR\tsuspectid\x12\x1e\n\nfractionid\x18\x04\x20\
    \x01(\rR\nfractionid\x12\x1d\n\nrpt_aimbot\x18\x05\x20\x01(\rR\trptAimbo\
    t\x12!\n\x0crpt_wallhack\x18\x06\x20\x01(\rR\x0brptWallhack\x12#\n\rrpt_\
    speedhack\x18\x07\x20\x01(\rR\x0crptSpeedhack\x12!\n\x0crpt_teamharm\x18\
    \x08\x20\x01(\rR\x0brptTeamharm\x12\x16\n\x06reason\x18\t\x20\x01(\rR\
    \x06reason\"\x90\x03\n0CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\
    \x12\x16\n\x06caseid\x18\x01\x20\x01(\x04R\x06caseid\x12\x18\n\x07caseur\
    l\x18\x02\x20\x01(\tR\x07caseurl\x12\x18\n\x07verdict\x18\x03\x20\x01(\r\
    R\x07verdict\x12\x1c\n\ttimestamp\x18\x04\x20\x01(\rR\ttimestamp\x12(\n\
    \x0fthrottleseconds\x18\x05\x20\x01(\rR\x0fthrottleseconds\x12\x1c\n\tsu\
    spectid\x18\x06\x20\x01(\rR\tsuspectid\x12\x1e\n\nfractionid\x18\x07\x20\
    \x01(\rR\nfractionid\x12\x1c\n\tnumrounds\x18\x08\x20\x01(\rR\tnumrounds\
    \x12&\n\x0efractionrounds\x18\t\x20\x01(\rR\x0efractionrounds\x12,\n\x11\
    streakconvictions\x18\n\x20\x01(\x05R\x11streakconvictions\x12\x16\n\x06\
    reason\x18\x0b\x20\x01(\rR\x06reason\"b\n,CMsgGCCStrike15_v2_PlayerOverw\
    atchCaseStatus\x12\x16\n\x06caseid\x18\x01\x20\x01(\x04R\x06caseid\x12\
    \x1a\n\x08statusid\x18\x02\x20\x01(\rR\x08statusid\"V\n\x1eCClientHeader\
    OverwatchEvidence\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\
    \x12\x16\n\x06caseid\x18\x02\x20\x01(\x04R\x06caseid\"c\n#CMsgGCCStrike1\
    5_v2_GC2ClientTextMsg\x12\x0e\n\x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\
    \n\x04type\x18\x02\x20\x01(\rR\x04type\x12\x18\n\x07payload\x18\x03\x20\
    \x01(\x0cR\x07payload\"I\n#CMsgGCCStrike15_v2_Client2GCTextMsg\x12\x0e\n\
    \x02id\x18\x01\x20\x01(\rR\x02id\x12\x12\n\x04args\x18\x02\x20\x03(\x0cR\
    \x04args\"\xd5\x01\n)CMsgGCCStrike15_v2_MatchEndRunRewardDrops\x12X\n\ns\
    erverinfo\x18\x03\x20\x01(\x0b28.CMsgGCCStrike15_v2_MatchmakingServerRes\
    ervationResponseR\nserverinfo\x12N\n\x14match_end_quest_data\x18\x04\x20\
    \x01(\x0b2\x1d.CMsgGC_ServerQuestUpdateDataR\x11matchEndQuestData\"\xa8\
    \x05\n\x19CEconItemPreviewDataBlock\x12\x1c\n\taccountid\x18\x01\x20\x01\
    (\rR\taccountid\x12\x16\n\x06itemid\x18\x02\x20\x01(\x04R\x06itemid\x12\
    \x1a\n\x08defindex\x18\x03\x20\x01(\rR\x08defindex\x12\x1e\n\npaintindex\
    \x18\x04\x20\x01(\rR\npaintindex\x12\x16\n\x06rarity\x18\x05\x20\x01(\rR\
    \x06rarity\x12\x18\n\x07quality\x18\x06\x20\x01(\rR\x07quality\x12\x1c\n\
    \tpaintwear\x18\x07\x20\x01(\rR\tpaintwear\x12\x1c\n\tpaintseed\x18\x08\
    \x20\x01(\rR\tpaintseed\x12.\n\x12killeaterscoretype\x18\t\x20\x01(\rR\
    \x12killeaterscoretype\x12&\n\x0ekilleatervalue\x18\n\x20\x01(\rR\x0ekil\
    leatervalue\x12\x1e\n\ncustomname\x18\x0b\x20\x01(\tR\ncustomname\x12>\n\
    \x08stickers\x18\x0c\x20\x03(\x0b2\".CEconItemPreviewDataBlock.StickerR\
    \x08stickers\x12\x1c\n\tinventory\x18\r\x20\x01(\rR\tinventory\x12\x16\n\
    \x06origin\x18\x0e\x20\x01(\rR\x06origin\x12\x18\n\x07questid\x18\x0f\
    \x20\x01(\rR\x07questid\x12\x1e\n\ndropreason\x18\x10\x20\x01(\rR\ndropr\
    eason\x1a\x82\x01\n\x07Sticker\x12\x12\n\x04slot\x18\x01\x20\x01(\rR\x04\
    slot\x12\x1d\n\nsticker_id\x18\x02\x20\x01(\rR\tstickerId\x12\x12\n\x04w\
    ear\x18\x03\x20\x01(\x02R\x04wear\x12\x14\n\x05scale\x18\x04\x20\x01(\
    \x02R\x05scale\x12\x1a\n\x08rotation\x18\x05\x20\x01(\x02R\x08rotation\"\
    l\n2CMsgGCCStrike15_v2_MatchEndRewardDropsNotification\x126\n\x08iteminf\
    o\x18\x06\x20\x01(\x0b2\x1a.CEconItemPreviewDataBlockR\x08iteminfo\"N\n\
    \x14CMsgItemAcknowledged\x126\n\x08iteminfo\x18\x01\x20\x01(\x0b2\x1a.CE\
    conItemPreviewDataBlockR\x08iteminfo\"\x9d\x01\n7CMsgGCCStrike15_v2_Clie\
    nt2GCEconPreviewDataBlockRequest\x12\x17\n\x07param_s\x18\x01\x20\x01(\
    \x04R\x06paramS\x12\x17\n\x07param_a\x18\x02\x20\x01(\x04R\x06paramA\x12\
    \x17\n\x07param_d\x18\x03\x20\x01(\x04R\x06paramD\x12\x17\n\x07param_m\
    \x18\x04\x20\x01(\x04R\x06paramM\"r\n8CMsgGCCStrike15_v2_Client2GCEconPr\
    eviewDataBlockResponse\x126\n\x08iteminfo\x18\x01\x20\x01(\x0b2\x1a.CEco\
    nItemPreviewDataBlockR\x08iteminfo\"\x92\x01\n9CMsgGCCStrike15_v2_Tourna\
    mentMatchRewardDropsNotification\x12\x19\n\x08match_id\x18\x01\x20\x01(\
    \x04R\x07matchId\x12\x1a\n\x08defindex\x18\x02\x20\x01(\rR\x08defindex\
    \x12\x1e\n\naccountids\x18\x03\x20\x03(\rR\naccountids\"5\n3CMsgGCCStrik\
    e15_v2_MatchListRequestCurrentLiveGames\"R\n2CMsgGCCStrike15_v2_MatchLis\
    tRequestLiveGameForUser\x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccoun\
    tid\"R\n2CMsgGCCStrike15_v2_MatchListRequestRecentUserGames\x12\x1c\n\ta\
    ccountid\x18\x01\x20\x01(\rR\taccountid\"N\n2CMsgGCCStrike15_v2_MatchLis\
    tRequestTournamentGames\x12\x18\n\x07eventid\x18\x01\x20\x01(\x05R\x07ev\
    entid\"\x7f\n/CMsgGCCStrike15_v2_MatchListRequestFullGameInfo\x12\x18\n\
    \x07matchid\x18\x01\x20\x01(\x04R\x07matchid\x12\x1c\n\toutcomeid\x18\
    \x02\x20\x01(\x04R\toutcomeid\x12\x14\n\x05token\x18\x03\x20\x01(\rR\x05\
    token\"\xd1\x02\n\x1dCDataGCCStrike15_v2_MatchInfo\x12\x18\n\x07matchid\
    \x18\x01\x20\x01(\x04R\x07matchid\x12\x1c\n\tmatchtime\x18\x02\x20\x01(\
    \rR\tmatchtime\x12C\n\x12watchablematchinfo\x18\x03\x20\x01(\x0b2\x13.Wa\
    tchableMatchInfoR\x12watchablematchinfo\x12\\\n\x11roundstats_legacy\x18\
    \x04\x20\x01(\x0b2/.CMsgGCCStrike15_v2_MatchmakingServerRoundStatsR\x10r\
    oundstatsLegacy\x12U\n\rroundstatsall\x18\x05\x20\x03(\x0b2/.CMsgGCCStri\
    ke15_v2_MatchmakingServerRoundStatsR\rroundstatsall\"z\n'CDataGCCStrike1\
    5_v2_TournamentGroupTeam\x12\x17\n\x07team_id\x18\x01\x20\x01(\x05R\x06t\
    eamId\x12\x14\n\x05score\x18\x02\x20\x01(\x05R\x05score\x12\x20\n\x0bcor\
    rectpick\x18\x03\x20\x01(\x08R\x0bcorrectpick\"\xd1\x03\n#CDataGCCStrike\
    15_v2_TournamentGroup\x12\x18\n\x07groupid\x18\x01\x20\x01(\rR\x07groupi\
    d\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\x12\n\x04desc\x18\
    \x03\x20\x01(\tR\x04desc\x12*\n\x11picks__deprecated\x18\x04\x20\x01(\rR\
    \x0fpicksDeprecated\x12>\n\x05teams\x18\x05\x20\x03(\x0b2(.CDataGCCStrik\
    e15_v2_TournamentGroupTeamR\x05teams\x12\x1b\n\tstage_ids\x18\x06\x20\
    \x03(\x05R\x08stageIds\x12,\n\x11picklockuntiltime\x18\x07\x20\x01(\rR\
    \x11picklockuntiltime\x12$\n\rpickableteams\x18\x08\x20\x01(\rR\rpickabl\
    eteams\x12&\n\x0fpoints_per_pick\x18\t\x20\x01(\rR\rpointsPerPick\x12@\n\
    \x05picks\x18\n\x20\x03(\x0b2*.CDataGCCStrike15_v2_TournamentGroup.Picks\
    R\x05picks\x1a!\n\x05Picks\x12\x18\n\x07pickids\x18\x01\x20\x03(\x05R\
    \x07pickids\"\xab\x01\n%CDataGCCStrike15_v2_TournamentSection\x12\x1c\n\
    \tsectionid\x18\x01\x20\x01(\rR\tsectionid\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\x12\x12\n\x04desc\x18\x03\x20\x01(\tR\x04desc\x12<\n\
    \x06groups\x18\x04\x20\x03(\x0b2$.CDataGCCStrike15_v2_TournamentGroupR\
    \x06groups\"\xe1\x01\n\"CDataGCCStrike15_v2_TournamentInfo\x12B\n\x08sec\
    tions\x18\x01\x20\x03(\x0b2&.CDataGCCStrike15_v2_TournamentSectionR\x08s\
    ections\x12;\n\x10tournament_event\x18\x02\x20\x01(\x0b2\x10.TournamentE\
    ventR\x0ftournamentEvent\x12:\n\x10tournament_teams\x18\x03\x20\x03(\x0b\
    2\x0f.TournamentTeamR\x0ftournamentTeams\"\xb2\x02\n\x1cCMsgGCCStrike15_\
    v2_MatchList\x12\"\n\x0cmsgrequestid\x18\x01\x20\x01(\rR\x0cmsgrequestid\
    \x12\x1c\n\taccountid\x18\x02\x20\x01(\rR\taccountid\x12\x1e\n\nserverti\
    me\x18\x03\x20\x01(\rR\nservertime\x128\n\x07matches\x18\x04\x20\x03(\
    \x0b2\x1e.CDataGCCStrike15_v2_MatchInfoR\x07matches\x12)\n\x07streams\
    \x18\x05\x20\x03(\x0b2\x0f.TournamentTeamR\x07streams\x12K\n\x0etourname\
    ntinfo\x18\x06\x20\x01(\x0b2#.CDataGCCStrike15_v2_TournamentInfoR\x0etou\
    rnamentinfo\"\xb9\x02\n\x1eCMsgGCCStrike15_v2_Predictions\x12\x19\n\x08e\
    vent_id\x18\x01\x20\x01(\rR\x07eventId\x12g\n\x16group_match_team_picks\
    \x18\x02\x20\x03(\x0b22.CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPic\
    kR\x13groupMatchTeamPicks\x1a\x92\x01\n\x12GroupMatchTeamPick\x12\x1c\n\
    \tsectionid\x18\x01\x20\x01(\x05R\tsectionid\x12\x18\n\x07groupid\x18\
    \x02\x20\x01(\x05R\x07groupid\x12\x14\n\x05index\x18\x03\x20\x01(\x05R\
    \x05index\x12\x16\n\x06teamid\x18\x04\x20\x01(\x05R\x06teamid\x12\x16\n\
    \x06itemid\x18\x05\x20\x01(\x04R\x06itemid\"\xb1\x02\n\x1aCMsgGCCStrike1\
    5_v2_Fantasy\x12\x19\n\x08event_id\x18\x01\x20\x01(\rR\x07eventId\x12=\n\
    \x05teams\x18\x02\x20\x03(\x0b2'.CMsgGCCStrike15_v2_Fantasy.FantasyTeamR\
    \x05teams\x1aM\n\x0bFantasySlot\x12\x12\n\x04type\x18\x01\x20\x01(\x05R\
    \x04type\x12\x12\n\x04pick\x18\x02\x20\x01(\x05R\x04pick\x12\x16\n\x06it\
    emid\x18\x03\x20\x01(\x04R\x06itemid\x1aj\n\x0bFantasyTeam\x12\x1c\n\tse\
    ctionid\x18\x01\x20\x01(\x05R\tsectionid\x12=\n\x05slots\x18\x02\x20\x03\
    (\x0b2'.CMsgGCCStrike15_v2_Fantasy.FantasySlotR\x05slots\")\n\x11CAttrib\
    ute_String\x12\x14\n\x05value\x18\x01\x20\x01(\tR\x05value\"\x1a\n\x18CM\
    sgGCToGCReloadVersions\"\xb2\x02\n\x14CMsgCStrike15Welcome\x12&\n\x0fsto\
    re_item_hash\x18\x05\x20\x01(\rR\rstoreItemHash\x128\n\x17timeplayedcons\
    ecutively\x18\x06\x20\x01(\rR\x17timeplayedconsecutively\x12*\n\x11time_\
    first_played\x18\n\x20\x01(\rR\x0ftimeFirstPlayed\x12(\n\x10last_time_pl\
    ayed\x18\x0c\x20\x01(\rR\x0elastTimePlayed\x12&\n\x0flast_ip_address\x18\
    \r\x20\x01(\rR\rlastIpAddress\x12\x1e\n\ngscookieid\x18\x12\x20\x01(\x04\
    R\ngscookieid\x12\x1a\n\x08uniqueid\x18\x13\x20\x01(\x04R\x08uniqueid\"\
    \xd6\x01\n1CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\x12\x1d\n\n\
    value_name\x18\x01\x20\x01(\tR\tvalueName\x12\x1b\n\tvalue_int\x18\x02\
    \x20\x01(\x05R\x08valueInt\x12\x1f\n\x0bserver_addr\x18\x03\x20\x01(\rR\
    \nserverAddr\x12\x1f\n\x0bserver_port\x18\x04\x20\x01(\rR\nserverPort\
    \x12#\n\rchoked_blocks\x18\x05\x20\x03(\tR\x0cchokedBlocks\"\x85\x01\n1C\
    MsgGCCStrike15_v2_ServerVarValueNotificationInfo\x12\x1c\n\taccountid\
    \x18\x01\x20\x01(\rR\taccountid\x12\x1e\n\nviewangles\x18\x02\x20\x03(\r\
    R\nviewangles\x12\x12\n\x04type\x18\x03\x20\x01(\rR\x04type\",\n*CMsgGCC\
    Strike15_v2_GiftsLeaderboardRequest\"\xf5\x02\n+CMsgGCCStrike15_v2_Gifts\
    LeaderboardResponse\x12\x1e\n\nservertime\x18\x01\x20\x01(\rR\nservertim\
    e\x12.\n\x13time_period_seconds\x18\x02\x20\x01(\rR\x11timePeriodSeconds\
    \x12*\n\x11total_gifts_given\x18\x03\x20\x01(\rR\x0ftotalGiftsGiven\x12!\
    \n\x0ctotal_givers\x18\x04\x20\x01(\rR\x0btotalGivers\x12[\n\x07entries\
    \x18\x05\x20\x03(\x0b2A.CMsgGCCStrike15_v2_GiftsLeaderboardResponse.Gift\
    LeaderboardEntryR\x07entries\x1aJ\n\x14GiftLeaderboardEntry\x12\x1c\n\ta\
    ccountid\x18\x01\x20\x01(\rR\taccountid\x12\x14\n\x05gifts\x18\x02\x20\
    \x01(\rR\x05gifts\"\\\n)CMsgGCCStrike15_v2_ClientSubmitSurveyVote\x12\
    \x1b\n\tsurvey_id\x18\x01\x20\x01(\rR\x08surveyId\x12\x12\n\x04vote\x18\
    \x02\x20\x01(\rR\x04vote\"J\n*CMsgGCCStrike15_v2_Server2GCClientValidate\
    \x12\x1c\n\taccountid\x18\x01\x20\x01(\rR\taccountid\"\xfa\x01\n7CMsgGCC\
    Strike15_v2_Server2GCPureServerValidationFailure\x12\x1c\n\taccountid\
    \x18\x01\x20\x01(\rR\taccountid\x12\x12\n\x04path\x18\x02\x20\x01(\tR\
    \x04path\x12\x12\n\x04file\x18\x03\x20\x01(\tR\x04file\x12\x10\n\x03crc\
    \x18\x04\x20\x01(\rR\x03crc\x12\x12\n\x04hash\x18\x05\x20\x01(\x05R\x04h\
    ash\x12\x10\n\x03len\x18\x06\x20\x01(\x05R\x03len\x12\x1f\n\x0bpack_numb\
    er\x18\x07\x20\x01(\x05R\npackNumber\x12\x20\n\x0cpack_file_id\x18\x08\
    \x20\x01(\x05R\npackFileId\"\x97\x01\n*CMsgGCCStrike15_v2_GC2ClientTourn\
    amentInfo\x12\x18\n\x07eventid\x18\x01\x20\x01(\rR\x07eventid\x12\x18\n\
    \x07stageid\x18\x02\x20\x01(\rR\x07stageid\x12\x1b\n\tgame_type\x18\x03\
    \x20\x01(\rR\x08gameType\x12\x18\n\x07teamids\x18\x04\x20\x03(\rR\x07tea\
    mids\"p\n\rCSOEconCoupon\x12\x1e\n\x07entryid\x18\x01\x20\x01(\rR\x07ent\
    ryidB\x04\x80\xa6\x1d\x01\x12\x16\n\x06defidx\x18\x02\x20\x01(\rR\x06def\
    idx\x12'\n\x0fexpiration_date\x18\x03\x20\x01(\x07R\x0eexpirationDate\"\
    \x80\x01\n\x10CSOQuestProgress\x12\x1e\n\x07questid\x18\x01\x20\x01(\rR\
    \x07questidB\x04\x80\xa6\x1d\x01\x12)\n\x10points_remaining\x18\x02\x20\
    \x01(\rR\x0fpointsRemaining\x12!\n\x0cbonus_points\x18\x03\x20\x01(\rR\
    \x0bbonusPoints\"\x9d\x01\n\x14CSOPersonaDataPublic\x12!\n\x0cplayer_lev\
    el\x18\x01\x20\x01(\x05R\x0bplayerLevel\x12;\n\x0ccommendation\x18\x02\
    \x20\x01(\x0b2\x17.PlayerCommendationInfoR\x0ccommendation\x12%\n\x0eele\
    vated_state\x18\x03\x20\x01(\x08R\relevatedState\"5\n\x1bCMsgGC_GlobalGa\
    me_Subscribe\x12\x16\n\x06ticket\x18\x01\x20\x01(\x04R\x06ticket\";\n\
    \x1dCMsgGC_GlobalGame_Unsubscribe\x12\x1a\n\x08timeleft\x18\x01\x20\x01(\
    \x05R\x08timeleft\"p\n\x16CMsgGC_GlobalGame_Play\x12\x16\n\x06ticket\x18\
    \x01\x20\x01(\x04R\x06ticket\x12\x1e\n\ngametimems\x18\x02\x20\x01(\rR\n\
    gametimems\x12\x1e\n\nmsperpoint\x18\x03\x20\x01(\rR\nmsperpoint\"K\n%CM\
    sgGCCStrike15_v2_AcknowledgePenalty\x12\"\n\x0cacknowledged\x18\x01\x20\
    \x01(\x05R\x0cacknowledged\"1\n/CMsgGCCStrike15_v2_Client2GCRequestPrest\
    igeCoin\"R\n(CMsgGCCStrike15_v2_Client2GCStreamUnlock\x12\x16\n\x06ticke\
    t\x18\x01\x20\x01(\x04R\x06ticket\x12\x0e\n\x02os\x18\x02\x20\x01(\x05R\
    \x02os\"C\n+CMsgGCCStrike15_v2_ClientToGCRequestElevate\x12\x14\n\x05sta\
    ge\x18\x01\x20\x01(\rR\x05stage\"R\n!CMsgGCCStrike15_v2_ClientToGCChat\
    \x12\x19\n\x08match_id\x18\x01\x20\x01(\x04R\x07matchId\x12\x12\n\x04tex\
    t\x18\x02\x20\x01(\tR\x04text\"V\n!CMsgGCCStrike15_v2_GCToClientChat\x12\
    \x1d\n\naccount_id\x18\x01\x20\x01(\rR\taccountId\x12\x12\n\x04text\x18\
    \x02\x20\x01(\tR\x04text*\xb9\x20\n\nECsgoGCMsg\x12\x1e\n\x19k_EMsgGCCSt\
    rike15_v2_Base\x10\x8cG\x12*\n%k_EMsgGCCStrike15_v2_MatchmakingStart\x10\
    \x8dG\x12)\n$k_EMsgGCCStrike15_v2_MatchmakingStop\x10\x8eG\x126\n1k_EMsg\
    GCCStrike15_v2_MatchmakingClient2ServerPing\x10\x8fG\x124\n/k_EMsgGCCStr\
    ike15_v2_MatchmakingGC2ClientUpdate\x10\x90G\x125\n0k_EMsgGCCStrike15_v2\
    _MatchmakingGC2ServerReserve\x10\x91G\x12>\n9k_EMsgGCCStrike15_v2_Matchm\
    akingServerReservationResponse\x10\x92G\x125\n0k_EMsgGCCStrike15_v2_Matc\
    hmakingGC2ClientReserve\x10\x93G\x125\n0k_EMsgGCCStrike15_v2_Matchmaking\
    ServerRoundStats\x10\x94G\x123\n.k_EMsgGCCStrike15_v2_MatchmakingClient2\
    GCHello\x10\x95G\x123\n.k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello\
    \x10\x96G\x123\n.k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd\x10\x97G\
    \x125\n0k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\x10\x98G\x122\n\
    -k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick\x10\x99G\x125\n0k_EMsgGCC\
    Strike15_v2_MatchmakingGC2ServerConfirm\x10\x9aG\x127\n2k_EMsgGCCStrike1\
    5_v2_MatchmakingGCOperationalStats\x10\x9bG\x128\n3k_EMsgGCCStrike15_v2_\
    MatchmakingGC2ServerRankUpdate\x10\x9cG\x12:\n5k_EMsgGCCStrike15_v2_Matc\
    hmakingOperator2GCBlogUpdate\x10\x9dG\x12:\n5k_EMsgGCCStrike15_v2_Server\
    NotificationForUserPenalty\x10\x9eG\x12,\n'k_EMsgGCCStrike15_v2_ClientRe\
    portPlayer\x10\x9fG\x12,\n'k_EMsgGCCStrike15_v2_ClientReportServer\x10\
    \xa0G\x12-\n(k_EMsgGCCStrike15_v2_ClientCommendPlayer\x10\xa1G\x12.\n)k_\
    EMsgGCCStrike15_v2_ClientReportResponse\x10\xa2G\x122\n-k_EMsgGCCStrike1\
    5_v2_ClientCommendPlayerQuery\x10\xa3G\x12:\n5k_EMsgGCCStrike15_v2_Clien\
    tCommendPlayerQueryResponse\x10\xa4G\x12(\n#k_EMsgGCCStrike15_v2_WatchIn\
    foUsers\x10\xa6G\x125\n0k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile\
    \x10\xa7G\x12(\n#k_EMsgGCCStrike15_v2_PlayersProfile\x10\xa8G\x12)\n$k_E\
    MsgGCCStrike15_v2_SetMyMedalsInfo\x10\xa9G\x123\n.k_EMsgGCCStrike15_v2_P\
    layerOverwatchCaseUpdate\x10\xabG\x127\n2k_EMsgGCCStrike15_v2_PlayerOver\
    watchCaseAssignment\x10\xacG\x123\n.k_EMsgGCCStrike15_v2_PlayerOverwatch\
    CaseStatus\x10\xadG\x12*\n%k_EMsgGCCStrike15_v2_GC2ClientTextMsg\x10\xae\
    G\x12*\n%k_EMsgGCCStrike15_v2_Client2GCTextMsg\x10\xafG\x120\n+k_EMsgGCC\
    Strike15_v2_MatchEndRunRewardDrops\x10\xb0G\x129\n4k_EMsgGCCStrike15_v2_\
    MatchEndRewardDropsNotification\x10\xb1G\x128\n3k_EMsgGCCStrike15_v2_Cli\
    entRequestWatchInfoFriends2\x10\xb2G\x12#\n\x1ek_EMsgGCCStrike15_v2_Matc\
    hList\x10\xb3G\x12:\n5k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGa\
    mes\x10\xb4G\x129\n4k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames\
    \x10\xb5G\x124\n/k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate\x10\xb6\
    G\x128\n3k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo\x10\xb8G\
    \x12@\n;k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\x10\
    \xb9G\x129\n4k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames\x10\
    \xbaG\x126\n1k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo\x10\xbbG\
    \x121\n,k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest\x10\xbcG\x122\n-k_E\
    MsgGCCStrike15_v2_GiftsLeaderboardResponse\x10\xbdG\x128\n3k_EMsgGCCStri\
    ke15_v2_ServerVarValueNotificationInfo\x10\xbeG\x12\x1f\n\x1ak_EMsgGCToG\
    CReloadVersions\x10\xbfG\x120\n+k_EMsgGCCStrike15_v2_ClientSubmitSurveyV\
    ote\x10\xc0G\x121\n,k_EMsgGCCStrike15_v2_Server2GCClientValidate\x10\xc1\
    G\x129\n4k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\x10\xc2G\
    \x12>\n9k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\x10\
    \xc3G\x12>\n9k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\
    \x10\xc4G\x12?\n:k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRespo\
    nse\x10\xc5G\x120\n+k_EMsgGCCStrike15_v2_AccountPrivacySettings\x10\xc6G\
    \x12+\n&k_EMsgGCCStrike15_v2_SetMyActivityInfo\x10\xc7G\x12?\n:k_EMsgGCC\
    Strike15_v2_MatchListRequestTournamentPredictions\x10\xc8G\x12>\n9k_EMsg\
    GCCStrike15_v2_MatchListUploadTournamentPredictions\x10\xc9G\x12&\n!k_EM\
    sgGCCStrike15_v2_DraftSummary\x10\xcaG\x125\n0k_EMsgGCCStrike15_v2_Clien\
    tRequestJoinFriendData\x10\xcbG\x125\n0k_EMsgGCCStrike15_v2_ClientReques\
    tJoinServerData\x10\xccG\x121\n,k_EMsgGCCStrike15_v2_ClientRequestNewMis\
    sion\x10\xcdG\x123\n.k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded\x10\
    \xceG\x121\n,k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo\x10\xcfG\x12\"\
    \n\x1dk_EMsgGC_GlobalGame_Subscribe\x10\xd0G\x12$\n\x1fk_EMsgGC_GlobalGa\
    me_Unsubscribe\x10\xd1G\x12\x1d\n\x18k_EMsgGC_GlobalGame_Play\x10\xd2G\
    \x12,\n'k_EMsgGCCStrike15_v2_AcknowledgePenalty\x10\xd3G\x126\n1k_EMsgGC\
    CStrike15_v2_Client2GCRequestPrestigeCoin\x10\xd4G\x12.\n)k_EMsgGCCStrik\
    e15_v2_GC2ClientGlobalStats\x10\xd5G\x12/\n*k_EMsgGCCStrike15_v2_Client2\
    GCStreamUnlock\x10\xd6G\x122\n-k_EMsgGCCStrike15_v2_FantasyRequestClient\
    Data\x10\xd7G\x121\n,k_EMsgGCCStrike15_v2_FantasyUpdateClientData\x10\
    \xd8G\x127\n2k_EMsgGCCStrike15_v2_GCToClientSteamdatagramTicket\x10\xd9G\
    \x121\n,k_EMsgGCCStrike15_v2_ClientToGCRequestTicket\x10\xdaG\x122\n-k_E\
    MsgGCCStrike15_v2_ClientToGCRequestElevate\x10\xdbG\x12$\n\x1fk_EMsgGCCS\
    trike15_v2_GlobalChat\x10\xdcG\x12.\n)k_EMsgGCCStrike15_v2_GlobalChat_Su\
    bscribe\x10\xddG\x120\n+k_EMsgGCCStrike15_v2_GlobalChat_Unsubscribe\x10\
    \xdeGB\x05H\x01\x80\x01\0J\xc6\xe1\x02\n\x07\x12\x05\0\0\xc1\x07\x01\n\t\
    \n\x02\x03\0\x12\x03\0\0\x1d\n\x08\n\x01\x08\x12\x03\x02\0\x1c\n\t\n\x02\
    \x08\t\x12\x03\x02\0\x1c\n\x08\n\x01\x08\x12\x03\x03\0#\n\t\n\x02\x08\
    \x10\x12\x03\x03\0#\n\n\n\x02\x05\0\x12\x04\x05\0V\x01\n\n\n\x03\x05\0\
    \x01\x12\x03\x05\x05\x0f\n\x0b\n\x04\x05\0\x02\0\x12\x03\x06\x08)\n\x0c\
    \n\x05\x05\0\x02\0\x01\x12\x03\x06\x08!\n\x0c\n\x05\x05\0\x02\0\x02\x12\
    \x03\x06$(\n\x0b\n\x04\x05\0\x02\x01\x12\x03\x07\x085\n\x0c\n\x05\x05\0\
    \x02\x01\x01\x12\x03\x07\x08-\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03\x070\
    4\n\x0b\n\x04\x05\0\x02\x02\x12\x03\x08\x084\n\x0c\n\x05\x05\0\x02\x02\
    \x01\x12\x03\x08\x08,\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\x08/3\n\x0b\
    \n\x04\x05\0\x02\x03\x12\x03\t\x08A\n\x0c\n\x05\x05\0\x02\x03\x01\x12\
    \x03\t\x089\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03\t<@\n\x0b\n\x04\x05\0\
    \x02\x04\x12\x03\n\x08?\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03\n\x087\n\
    \x0c\n\x05\x05\0\x02\x04\x02\x12\x03\n:>\n\x0b\n\x04\x05\0\x02\x05\x12\
    \x03\x0b\x08@\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03\x0b\x088\n\x0c\n\x05\
    \x05\0\x02\x05\x02\x12\x03\x0b;?\n\x0b\n\x04\x05\0\x02\x06\x12\x03\x0c\
    \x08I\n\x0c\n\x05\x05\0\x02\x06\x01\x12\x03\x0c\x08A\n\x0c\n\x05\x05\0\
    \x02\x06\x02\x12\x03\x0cDH\n\x0b\n\x04\x05\0\x02\x07\x12\x03\r\x08@\n\
    \x0c\n\x05\x05\0\x02\x07\x01\x12\x03\r\x088\n\x0c\n\x05\x05\0\x02\x07\
    \x02\x12\x03\r;?\n\x0b\n\x04\x05\0\x02\x08\x12\x03\x0e\x08@\n\x0c\n\x05\
    \x05\0\x02\x08\x01\x12\x03\x0e\x088\n\x0c\n\x05\x05\0\x02\x08\x02\x12\
    \x03\x0e;?\n\x0b\n\x04\x05\0\x02\t\x12\x03\x0f\x08>\n\x0c\n\x05\x05\0\
    \x02\t\x01\x12\x03\x0f\x086\n\x0c\n\x05\x05\0\x02\t\x02\x12\x03\x0f9=\n\
    \x0b\n\x04\x05\0\x02\n\x12\x03\x10\x08>\n\x0c\n\x05\x05\0\x02\n\x01\x12\
    \x03\x10\x086\n\x0c\n\x05\x05\0\x02\n\x02\x12\x03\x109=\n\x0b\n\x04\x05\
    \0\x02\x0b\x12\x03\x11\x08>\n\x0c\n\x05\x05\0\x02\x0b\x01\x12\x03\x11\
    \x086\n\x0c\n\x05\x05\0\x02\x0b\x02\x12\x03\x119=\n\x0b\n\x04\x05\0\x02\
    \x0c\x12\x03\x12\x08@\n\x0c\n\x05\x05\0\x02\x0c\x01\x12\x03\x12\x088\n\
    \x0c\n\x05\x05\0\x02\x0c\x02\x12\x03\x12;?\n\x0b\n\x04\x05\0\x02\r\x12\
    \x03\x13\x08=\n\x0c\n\x05\x05\0\x02\r\x01\x12\x03\x13\x085\n\x0c\n\x05\
    \x05\0\x02\r\x02\x12\x03\x138<\n\x0b\n\x04\x05\0\x02\x0e\x12\x03\x14\x08\
    @\n\x0c\n\x05\x05\0\x02\x0e\x01\x12\x03\x14\x088\n\x0c\n\x05\x05\0\x02\
    \x0e\x02\x12\x03\x14;?\n\x0b\n\x04\x05\0\x02\x0f\x12\x03\x15\x08B\n\x0c\
    \n\x05\x05\0\x02\x0f\x01\x12\x03\x15\x08:\n\x0c\n\x05\x05\0\x02\x0f\x02\
    \x12\x03\x15=A\n\x0b\n\x04\x05\0\x02\x10\x12\x03\x16\x08C\n\x0c\n\x05\
    \x05\0\x02\x10\x01\x12\x03\x16\x08;\n\x0c\n\x05\x05\0\x02\x10\x02\x12\
    \x03\x16>B\n\x0b\n\x04\x05\0\x02\x11\x12\x03\x17\x08E\n\x0c\n\x05\x05\0\
    \x02\x11\x01\x12\x03\x17\x08=\n\x0c\n\x05\x05\0\x02\x11\x02\x12\x03\x17@\
    D\n\x0b\n\x04\x05\0\x02\x12\x12\x03\x18\x08E\n\x0c\n\x05\x05\0\x02\x12\
    \x01\x12\x03\x18\x08=\n\x0c\n\x05\x05\0\x02\x12\x02\x12\x03\x18@D\n\x0b\
    \n\x04\x05\0\x02\x13\x12\x03\x19\x087\n\x0c\n\x05\x05\0\x02\x13\x01\x12\
    \x03\x19\x08/\n\x0c\n\x05\x05\0\x02\x13\x02\x12\x03\x1926\n\x0b\n\x04\
    \x05\0\x02\x14\x12\x03\x1a\x087\n\x0c\n\x05\x05\0\x02\x14\x01\x12\x03\
    \x1a\x08/\n\x0c\n\x05\x05\0\x02\x14\x02\x12\x03\x1a26\n\x0b\n\x04\x05\0\
    \x02\x15\x12\x03\x1b\x088\n\x0c\n\x05\x05\0\x02\x15\x01\x12\x03\x1b\x080\
    \n\x0c\n\x05\x05\0\x02\x15\x02\x12\x03\x1b37\n\x0b\n\x04\x05\0\x02\x16\
    \x12\x03\x1c\x089\n\x0c\n\x05\x05\0\x02\x16\x01\x12\x03\x1c\x081\n\x0c\n\
    \x05\x05\0\x02\x16\x02\x12\x03\x1c48\n\x0b\n\x04\x05\0\x02\x17\x12\x03\
    \x1d\x08=\n\x0c\n\x05\x05\0\x02\x17\x01\x12\x03\x1d\x085\n\x0c\n\x05\x05\
    \0\x02\x17\x02\x12\x03\x1d8<\n\x0b\n\x04\x05\0\x02\x18\x12\x03\x1e\x08E\
    \n\x0c\n\x05\x05\0\x02\x18\x01\x12\x03\x1e\x08=\n\x0c\n\x05\x05\0\x02\
    \x18\x02\x12\x03\x1e@D\n\x0b\n\x04\x05\0\x02\x19\x12\x03\x1f\x083\n\x0c\
    \n\x05\x05\0\x02\x19\x01\x12\x03\x1f\x08+\n\x0c\n\x05\x05\0\x02\x19\x02\
    \x12\x03\x1f.2\n\x0b\n\x04\x05\0\x02\x1a\x12\x03\x20\x08@\n\x0c\n\x05\
    \x05\0\x02\x1a\x01\x12\x03\x20\x088\n\x0c\n\x05\x05\0\x02\x1a\x02\x12\
    \x03\x20;?\n\x0b\n\x04\x05\0\x02\x1b\x12\x03!\x083\n\x0c\n\x05\x05\0\x02\
    \x1b\x01\x12\x03!\x08+\n\x0c\n\x05\x05\0\x02\x1b\x02\x12\x03!.2\n\x0b\n\
    \x04\x05\0\x02\x1c\x12\x03\"\x084\n\x0c\n\x05\x05\0\x02\x1c\x01\x12\x03\
    \"\x08,\n\x0c\n\x05\x05\0\x02\x1c\x02\x12\x03\"/3\n\x0b\n\x04\x05\0\x02\
    \x1d\x12\x03#\x08>\n\x0c\n\x05\x05\0\x02\x1d\x01\x12\x03#\x086\n\x0c\n\
    \x05\x05\0\x02\x1d\x02\x12\x03#9=\n\x0b\n\x04\x05\0\x02\x1e\x12\x03$\x08\
    B\n\x0c\n\x05\x05\0\x02\x1e\x01\x12\x03$\x08:\n\x0c\n\x05\x05\0\x02\x1e\
    \x02\x12\x03$=A\n\x0b\n\x04\x05\0\x02\x1f\x12\x03%\x08>\n\x0c\n\x05\x05\
    \0\x02\x1f\x01\x12\x03%\x086\n\x0c\n\x05\x05\0\x02\x1f\x02\x12\x03%9=\n\
    \x0b\n\x04\x05\0\x02\x20\x12\x03&\x085\n\x0c\n\x05\x05\0\x02\x20\x01\x12\
    \x03&\x08-\n\x0c\n\x05\x05\0\x02\x20\x02\x12\x03&04\n\x0b\n\x04\x05\0\
    \x02!\x12\x03'\x085\n\x0c\n\x05\x05\0\x02!\x01\x12\x03'\x08-\n\x0c\n\x05\
    \x05\0\x02!\x02\x12\x03'04\n\x0b\n\x04\x05\0\x02\"\x12\x03(\x08;\n\x0c\n\
    \x05\x05\0\x02\"\x01\x12\x03(\x083\n\x0c\n\x05\x05\0\x02\"\x02\x12\x03(6\
    :\n\x0b\n\x04\x05\0\x02#\x12\x03)\x08D\n\x0c\n\x05\x05\0\x02#\x01\x12\
    \x03)\x08<\n\x0c\n\x05\x05\0\x02#\x02\x12\x03)?C\n\x0b\n\x04\x05\0\x02$\
    \x12\x03*\x08C\n\x0c\n\x05\x05\0\x02$\x01\x12\x03*\x08;\n\x0c\n\x05\x05\
    \0\x02$\x02\x12\x03*>B\n\x0b\n\x04\x05\0\x02%\x12\x03+\x08.\n\x0c\n\x05\
    \x05\0\x02%\x01\x12\x03+\x08&\n\x0c\n\x05\x05\0\x02%\x02\x12\x03+)-\n\
    \x0b\n\x04\x05\0\x02&\x12\x03,\x08E\n\x0c\n\x05\x05\0\x02&\x01\x12\x03,\
    \x08=\n\x0c\n\x05\x05\0\x02&\x02\x12\x03,@D\n\x0b\n\x04\x05\0\x02'\x12\
    \x03-\x08D\n\x0c\n\x05\x05\0\x02'\x01\x12\x03-\x08<\n\x0c\n\x05\x05\0\
    \x02'\x02\x12\x03-?C\n\x0b\n\x04\x05\0\x02(\x12\x03.\x08?\n\x0c\n\x05\
    \x05\0\x02(\x01\x12\x03.\x087\n\x0c\n\x05\x05\0\x02(\x02\x12\x03.:>\n\
    \x0b\n\x04\x05\0\x02)\x12\x03/\x08C\n\x0c\n\x05\x05\0\x02)\x01\x12\x03/\
    \x08;\n\x0c\n\x05\x05\0\x02)\x02\x12\x03/>B\n\x0b\n\x04\x05\0\x02*\x12\
    \x030\x08K\n\x0c\n\x05\x05\0\x02*\x01\x12\x030\x08C\n\x0c\n\x05\x05\0\
    \x02*\x02\x12\x030FJ\n\x0b\n\x04\x05\0\x02+\x12\x031\x08D\n\x0c\n\x05\
    \x05\0\x02+\x01\x12\x031\x08<\n\x0c\n\x05\x05\0\x02+\x02\x12\x031?C\n\
    \x0b\n\x04\x05\0\x02,\x12\x032\x08A\n\x0c\n\x05\x05\0\x02,\x01\x12\x032\
    \x089\n\x0c\n\x05\x05\0\x02,\x02\x12\x032<@\n\x0b\n\x04\x05\0\x02-\x12\
    \x033\x08<\n\x0c\n\x05\x05\0\x02-\x01\x12\x033\x084\n\x0c\n\x05\x05\0\
    \x02-\x02\x12\x0337;\n\x0b\n\x04\x05\0\x02.\x12\x034\x08=\n\x0c\n\x05\
    \x05\0\x02.\x01\x12\x034\x085\n\x0c\n\x05\x05\0\x02.\x02\x12\x0348<\n\
    \x0b\n\x04\x05\0\x02/\x12\x035\x08C\n\x0c\n\x05\x05\0\x02/\x01\x12\x035\
    \x08;\n\x0c\n\x05\x05\0\x02/\x02\x12\x035>B\n\x0b\n\x04\x05\0\x020\x12\
    \x036\x08*\n\x0c\n\x05\x05\0\x020\x01\x12\x036\x08\"\n\x0c\n\x05\x05\0\
    \x020\x02\x12\x036%)\n\x0b\n\x04\x05\0\x021\x12\x037\x08;\n\x0c\n\x05\
    \x05\0\x021\x01\x12\x037\x083\n\x0c\n\x05\x05\0\x021\x02\x12\x0376:\n\
    \x0b\n\x04\x05\0\x022\x12\x038\x08<\n\x0c\n\x05\x05\0\x022\x01\x12\x038\
    \x084\n\x0c\n\x05\x05\0\x022\x02\x12\x0387;\n\x0b\n\x04\x05\0\x023\x12\
    \x039\x08D\n\x0c\n\x05\x05\0\x023\x01\x12\x039\x08<\n\x0c\n\x05\x05\0\
    \x023\x02\x12\x039?C\n\x0b\n\x04\x05\0\x024\x12\x03:\x08I\n\x0c\n\x05\
    \x05\0\x024\x01\x12\x03:\x08A\n\x0c\n\x05\x05\0\x024\x02\x12\x03:DH\n\
    \x0b\n\x04\x05\0\x025\x12\x03;\x08I\n\x0c\n\x05\x05\0\x025\x01\x12\x03;\
    \x08A\n\x0c\n\x05\x05\0\x025\x02\x12\x03;DH\n\x0b\n\x04\x05\0\x026\x12\
    \x03<\x08J\n\x0c\n\x05\x05\0\x026\x01\x12\x03<\x08B\n\x0c\n\x05\x05\0\
    \x026\x02\x12\x03<EI\n\x0b\n\x04\x05\0\x027\x12\x03=\x08;\n\x0c\n\x05\
    \x05\0\x027\x01\x12\x03=\x083\n\x0c\n\x05\x05\0\x027\x02\x12\x03=6:\n\
    \x0b\n\x04\x05\0\x028\x12\x03>\x086\n\x0c\n\x05\x05\0\x028\x01\x12\x03>\
    \x08.\n\x0c\n\x05\x05\0\x028\x02\x12\x03>15\n\x0b\n\x04\x05\0\x029\x12\
    \x03?\x08J\n\x0c\n\x05\x05\0\x029\x01\x12\x03?\x08B\n\x0c\n\x05\x05\0\
    \x029\x02\x12\x03?EI\n\x0b\n\x04\x05\0\x02:\x12\x03@\x08I\n\x0c\n\x05\
    \x05\0\x02:\x01\x12\x03@\x08A\n\x0c\n\x05\x05\0\x02:\x02\x12\x03@DH\n\
    \x0b\n\x04\x05\0\x02;\x12\x03A\x081\n\x0c\n\x05\x05\0\x02;\x01\x12\x03A\
    \x08)\n\x0c\n\x05\x05\0\x02;\x02\x12\x03A,0\n\x0b\n\x04\x05\0\x02<\x12\
    \x03B\x08@\n\x0c\n\x05\x05\0\x02<\x01\x12\x03B\x088\n\x0c\n\x05\x05\0\
    \x02<\x02\x12\x03B;?\n\x0b\n\x04\x05\0\x02=\x12\x03C\x08@\n\x0c\n\x05\
    \x05\0\x02=\x01\x12\x03C\x088\n\x0c\n\x05\x05\0\x02=\x02\x12\x03C;?\n\
    \x0b\n\x04\x05\0\x02>\x12\x03D\x08<\n\x0c\n\x05\x05\0\x02>\x01\x12\x03D\
    \x084\n\x0c\n\x05\x05\0\x02>\x02\x12\x03D7;\n\x0b\n\x04\x05\0\x02?\x12\
    \x03E\x08>\n\x0c\n\x05\x05\0\x02?\x01\x12\x03E\x086\n\x0c\n\x05\x05\0\
    \x02?\x02\x12\x03E9=\n\x0b\n\x04\x05\0\x02@\x12\x03F\x08<\n\x0c\n\x05\
    \x05\0\x02@\x01\x12\x03F\x084\n\x0c\n\x05\x05\0\x02@\x02\x12\x03F7;\n\
    \x0b\n\x04\x05\0\x02A\x12\x03G\x08-\n\x0c\n\x05\x05\0\x02A\x01\x12\x03G\
    \x08%\n\x0c\n\x05\x05\0\x02A\x02\x12\x03G(,\n\x0b\n\x04\x05\0\x02B\x12\
    \x03H\x08/\n\x0c\n\x05\x05\0\x02B\x01\x12\x03H\x08'\n\x0c\n\x05\x05\0\
    \x02B\x02\x12\x03H*.\n\x0b\n\x04\x05\0\x02C\x12\x03I\x08(\n\x0c\n\x05\
    \x05\0\x02C\x01\x12\x03I\x08\x20\n\x0c\n\x05\x05\0\x02C\x02\x12\x03I#'\n\
    \x0b\n\x04\x05\0\x02D\x12\x03J\x087\n\x0c\n\x05\x05\0\x02D\x01\x12\x03J\
    \x08/\n\x0c\n\x05\x05\0\x02D\x02\x12\x03J26\n\x0b\n\x04\x05\0\x02E\x12\
    \x03K\x08A\n\x0c\n\x05\x05\0\x02E\x01\x12\x03K\x089\n\x0c\n\x05\x05\0\
    \x02E\x02\x12\x03K<@\n\x0b\n\x04\x05\0\x02F\x12\x03L\x089\n\x0c\n\x05\
    \x05\0\x02F\x01\x12\x03L\x081\n\x0c\n\x05\x05\0\x02F\x02\x12\x03L48\n\
    \x0b\n\x04\x05\0\x02G\x12\x03M\x08:\n\x0c\n\x05\x05\0\x02G\x01\x12\x03M\
    \x082\n\x0c\n\x05\x05\0\x02G\x02\x12\x03M59\n\x0b\n\x04\x05\0\x02H\x12\
    \x03N\x08=\n\x0c\n\x05\x05\0\x02H\x01\x12\x03N\x085\n\x0c\n\x05\x05\0\
    \x02H\x02\x12\x03N8<\n\x0b\n\x04\x05\0\x02I\x12\x03O\x08<\n\x0c\n\x05\
    \x05\0\x02I\x01\x12\x03O\x084\n\x0c\n\x05\x05\0\x02I\x02\x12\x03O7;\n\
    \x0b\n\x04\x05\0\x02J\x12\x03P\x08B\n\x0c\n\x05\x05\0\x02J\x01\x12\x03P\
    \x08:\n\x0c\n\x05\x05\0\x02J\x02\x12\x03P=A\n\x0b\n\x04\x05\0\x02K\x12\
    \x03Q\x08<\n\x0c\n\x05\x05\0\x02K\x01\x12\x03Q\x084\n\x0c\n\x05\x05\0\
    \x02K\x02\x12\x03Q7;\n\x0b\n\x04\x05\0\x02L\x12\x03R\x08=\n\x0c\n\x05\
    \x05\0\x02L\x01\x12\x03R\x085\n\x0c\n\x05\x05\0\x02L\x02\x12\x03R8<\n\
    \x0b\n\x04\x05\0\x02M\x12\x03S\x08/\n\x0c\n\x05\x05\0\x02M\x01\x12\x03S\
    \x08'\n\x0c\n\x05\x05\0\x02M\x02\x12\x03S*.\n\x0b\n\x04\x05\0\x02N\x12\
    \x03T\x089\n\x0c\n\x05\x05\0\x02N\x01\x12\x03T\x081\n\x0c\n\x05\x05\0\
    \x02N\x02\x12\x03T48\n\x0b\n\x04\x05\0\x02O\x12\x03U\x08;\n\x0c\n\x05\
    \x05\0\x02O\x01\x12\x03U\x083\n\x0c\n\x05\x05\0\x02O\x02\x12\x03U6:\n\n\
    \n\x02\x04\0\x12\x04X\0^\x01\n\n\n\x03\x04\0\x01\x12\x03X\x08\x16\n\x0b\
    \n\x04\x04\0\x02\0\x12\x03Y\x08*\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03Y\
    \x08\x10\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03Y\x11\x17\n\x0c\n\x05\x04\0\
    \x02\0\x01\x12\x03Y\x18%\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03Y()\n\x0b\n\
    \x04\x04\0\x02\x01\x12\x03Z\x08\x20\n\x0c\n\x05\x04\0\x02\x01\x04\x12\
    \x03Z\x08\x10\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03Z\x11\x16\n\x0c\n\x05\
    \x04\0\x02\x01\x01\x12\x03Z\x17\x1b\n\x0c\n\x05\x04\0\x02\x01\x03\x12\
    \x03Z\x1e\x1f\n\x0b\n\x04\x04\0\x02\x02\x12\x03[\x08\x1f\n\x0c\n\x05\x04\
    \0\x02\x02\x04\x12\x03[\x08\x10\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x03[\
    \x11\x17\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03[\x18\x1a\n\x0c\n\x05\x04\
    \0\x02\x02\x03\x12\x03[\x1d\x1e\n\x0b\n\x04\x04\0\x02\x03\x12\x03\\\x08!\
    \n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03\\\x08\x10\n\x0c\n\x05\x04\0\x02\
    \x03\x05\x12\x03\\\x11\x17\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03\\\x18\
    \x1c\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03\\\x1f\x20\n\x0b\n\x04\x04\0\
    \x02\x04\x12\x03]\x08&\n\x0c\n\x05\x04\0\x02\x04\x04\x12\x03]\x08\x10\n\
    \x0c\n\x05\x04\0\x02\x04\x05\x12\x03]\x11\x17\n\x0c\n\x05\x04\0\x02\x04\
    \x01\x12\x03]\x18!\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03]$%\n\n\n\x02\
    \x04\x01\x12\x04`\0d\x01\n\n\n\x03\x04\x01\x01\x12\x03`\x08\x1f\n\x0b\n\
    \x04\x04\x01\x02\0\x12\x03a\x08&\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03a\
    \x08\x10\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03a\x11\x17\n\x0c\n\x05\x04\
    \x01\x02\0\x01\x12\x03a\x18!\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03a$%\n\
    \x0b\n\x04\x04\x01\x02\x01\x12\x03b\x08,\n\x0c\n\x05\x04\x01\x02\x01\x04\
    \x12\x03b\x08\x10\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03b\x11\x17\n\x0c\
    \n\x05\x04\x01\x02\x01\x01\x12\x03b\x18'\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x03b*+\n\x0b\n\x04\x04\x01\x02\x02\x12\x03c\x08.\n\x0c\n\x05\x04\
    \x01\x02\x02\x04\x12\x03c\x08\x10\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\
    \x03c\x11\x17\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03c\x18)\n\x0c\n\x05\
    \x04\x01\x02\x02\x03\x12\x03c,-\n\n\n\x02\x04\x02\x12\x04f\0n\x01\n\n\n\
    \x03\x04\x02\x01\x12\x03f\x08\x18\n\x0b\n\x04\x04\x02\x02\0\x12\x03g\x08\
    '\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03g\x08\x10\n\x0c\n\x05\x04\x02\x02\
    \0\x05\x12\x03g\x11\x17\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03g\x18\"\n\
    \x0c\n\x05\x04\x02\x02\0\x03\x12\x03g%&\n\x0b\n\x04\x04\x02\x02\x01\x12\
    \x03h\x08(\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03h\x08\x10\n\x0c\n\x05\
    \x04\x02\x02\x01\x05\x12\x03h\x11\x17\n\x0c\n\x05\x04\x02\x02\x01\x01\
    \x12\x03h\x18#\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03h&'\n\x0b\n\x04\
    \x04\x02\x02\x02\x12\x03i\x08(\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03i\
    \x08\x10\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\x03i\x11\x17\n\x0c\n\x05\
    \x04\x02\x02\x02\x01\x12\x03i\x18#\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\
    \x03i&'\n\x0b\n\x04\x04\x02\x02\x03\x12\x03j\x08'\n\x0c\n\x05\x04\x02\
    \x02\x03\x04\x12\x03j\x08\x10\n\x0c\n\x05\x04\x02\x02\x03\x05\x12\x03j\
    \x11\x17\n\x0c\n\x05\x04\x02\x02\x03\x01\x12\x03j\x18\"\n\x0c\n\x05\x04\
    \x02\x02\x03\x03\x12\x03j%&\n\x0b\n\x04\x04\x02\x02\x04\x12\x03k\x08(\n\
    \x0c\n\x05\x04\x02\x02\x04\x04\x12\x03k\x08\x10\n\x0c\n\x05\x04\x02\x02\
    \x04\x05\x12\x03k\x11\x17\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03k\x18#\
    \n\x0c\n\x05\x04\x02\x02\x04\x03\x12\x03k&'\n\x0b\n\x04\x04\x02\x02\x05\
    \x12\x03l\x08,\n\x0c\n\x05\x04\x02\x02\x05\x04\x12\x03l\x08\x10\n\x0c\n\
    \x05\x04\x02\x02\x05\x05\x12\x03l\x11\x17\n\x0c\n\x05\x04\x02\x02\x05\
    \x01\x12\x03l\x18'\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03l*+\n\x0b\n\
    \x04\x04\x02\x02\x06\x12\x03m\x08(\n\x0c\n\x05\x04\x02\x02\x06\x04\x12\
    \x03m\x08\x10\n\x0c\n\x05\x04\x02\x02\x06\x05\x12\x03m\x11\x17\n\x0c\n\
    \x05\x04\x02\x02\x06\x01\x12\x03m\x18#\n\x0c\n\x05\x04\x02\x02\x06\x03\
    \x12\x03m&'\n\n\n\x02\x04\x03\x12\x04p\0v\x01\n\n\n\x03\x04\x03\x01\x12\
    \x03p\x08\x16\n\x0b\n\x04\x04\x03\x02\0\x12\x03q\x08#\n\x0c\n\x05\x04\
    \x03\x02\0\x04\x12\x03q\x08\x10\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03q\
    \x11\x16\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03q\x17\x1e\n\x0c\n\x05\x04\
    \x03\x02\0\x03\x12\x03q!\"\n\x0b\n\x04\x04\x03\x02\x01\x12\x03r\x08%\n\
    \x0c\n\x05\x04\x03\x02\x01\x04\x12\x03r\x08\x10\n\x0c\n\x05\x04\x03\x02\
    \x01\x05\x12\x03r\x11\x17\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03r\x18\
    \x20\n\x0c\n\x05\x04\x03\x02\x01\x03\x12\x03r#$\n\x0b\n\x04\x04\x03\x02\
    \x02\x12\x03s\x08&\n\x0c\n\x05\x04\x03\x02\x02\x04\x12\x03s\x08\x10\n\
    \x0c\n\x05\x04\x03\x02\x02\x05\x12\x03s\x11\x17\n\x0c\n\x05\x04\x03\x02\
    \x02\x01\x12\x03s\x18!\n\x0c\n\x05\x04\x03\x02\x02\x03\x12\x03s$%\n\x0b\
    \n\x04\x04\x03\x02\x03\x12\x03t\x08&\n\x0c\n\x05\x04\x03\x02\x03\x04\x12\
    \x03t\x08\x10\n\x0c\n\x05\x04\x03\x02\x03\x05\x12\x03t\x11\x17\n\x0c\n\
    \x05\x04\x03\x02\x03\x01\x12\x03t\x18!\n\x0c\n\x05\x04\x03\x02\x03\x03\
    \x12\x03t$%\n\x0b\n\x04\x04\x03\x02\x04\x12\x03u\x08/\n\x0c\n\x05\x04\
    \x03\x02\x04\x04\x12\x03u\x08\x10\n\x0c\n\x05\x04\x03\x02\x04\x06\x12\
    \x03u\x11\"\n\x0c\n\x05\x04\x03\x02\x04\x01\x12\x03u#*\n\x0c\n\x05\x04\
    \x03\x02\x04\x03\x12\x03u-.\n\x0b\n\x02\x04\x04\x12\x05x\0\x82\x01\x01\n\
    \n\n\x03\x04\x04\x01\x12\x03x\x08\x17\n\x0b\n\x04\x04\x04\x02\0\x12\x03y\
    \x08$\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03y\x08\x10\n\x0c\n\x05\x04\x04\
    \x02\0\x05\x12\x03y\x11\x16\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03y\x17\
    \x1f\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03y\"#\n\x0b\n\x04\x04\x04\x02\
    \x01\x12\x03z\x08&\n\x0c\n\x05\x04\x04\x02\x01\x04\x12\x03z\x08\x10\n\
    \x0c\n\x05\x04\x04\x02\x01\x05\x12\x03z\x11\x17\n\x0c\n\x05\x04\x04\x02\
    \x01\x01\x12\x03z\x18!\n\x0c\n\x05\x04\x04\x02\x01\x03\x12\x03z$%\n\x0b\
    \n\x04\x04\x04\x02\x02\x12\x03{\x08'\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\
    \x03{\x08\x10\n\x0c\n\x05\x04\x04\x02\x02\x05\x12\x03{\x11\x17\n\x0c\n\
    \x05\x04\x04\x02\x02\x01\x12\x03{\x18\"\n\x0c\n\x05\x04\x04\x02\x02\x03\
    \x12\x03{%&\n\x0b\n\x04\x04\x04\x02\x03\x12\x03|\x08-\n\x0c\n\x05\x04\
    \x04\x02\x03\x04\x12\x03|\x08\x10\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\
    \x03|\x11\x17\n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03|\x18(\n\x0c\n\x05\
    \x04\x04\x02\x03\x03\x12\x03|+,\n\x0b\n\x04\x04\x04\x02\x04\x12\x03}\x08\
    +\n\x0c\n\x05\x04\x04\x02\x04\x04\x12\x03}\x08\x10\n\x0c\n\x05\x04\x04\
    \x02\x04\x05\x12\x03}\x11\x17\n\x0c\n\x05\x04\x04\x02\x04\x01\x12\x03}\
    \x18&\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03})*\n\x0b\n\x04\x04\x04\x02\
    \x05\x12\x03~\x08(\n\x0c\n\x05\x04\x04\x02\x05\x04\x12\x03~\x08\x10\n\
    \x0c\n\x05\x04\x04\x02\x05\x05\x12\x03~\x11\x16\n\x0c\n\x05\x04\x04\x02\
    \x05\x01\x12\x03~\x17#\n\x0c\n\x05\x04\x04\x02\x05\x03\x12\x03~&'\n\x0b\
    \n\x04\x04\x04\x02\x06\x12\x03\x7f\x08*\n\x0c\n\x05\x04\x04\x02\x06\x04\
    \x12\x03\x7f\x08\x10\n\x0c\n\x05\x04\x04\x02\x06\x05\x12\x03\x7f\x11\x16\
    \n\x0c\n\x05\x04\x04\x02\x06\x01\x12\x03\x7f\x17%\n\x0c\n\x05\x04\x04\
    \x02\x06\x03\x12\x03\x7f()\n\x0c\n\x04\x04\x04\x02\x07\x12\x04\x80\x01\
    \x08-\n\r\n\x05\x04\x04\x02\x07\x04\x12\x04\x80\x01\x08\x10\n\r\n\x05\
    \x04\x04\x02\x07\x05\x12\x04\x80\x01\x11\x17\n\r\n\x05\x04\x04\x02\x07\
    \x01\x12\x04\x80\x01\x18(\n\r\n\x05\x04\x04\x02\x07\x03\x12\x04\x80\x01+\
    ,\n\x0c\n\x04\x04\x04\x02\x08\x12\x04\x81\x01\x08.\n\r\n\x05\x04\x04\x02\
    \x08\x04\x12\x04\x81\x01\x08\x10\n\r\n\x05\x04\x04\x02\x08\x05\x12\x04\
    \x81\x01\x11\x17\n\r\n\x05\x04\x04\x02\x08\x01\x12\x04\x81\x01\x18)\n\r\
    \n\x05\x04\x04\x02\x08\x03\x12\x04\x81\x01,-\n\x0c\n\x02\x04\x05\x12\x06\
    \x84\x01\0\x92\x01\x01\n\x0b\n\x03\x04\x05\x01\x12\x04\x84\x01\x08\x18\n\
    \x0c\n\x04\x04\x05\x02\0\x12\x04\x85\x01\x08+\n\r\n\x05\x04\x05\x02\0\
    \x04\x12\x04\x85\x01\x08\x10\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\x85\x01\
    \x11\x17\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\x85\x01\x18&\n\r\n\x05\x04\
    \x05\x02\0\x03\x12\x04\x85\x01)*\n\x0c\n\x04\x04\x05\x02\x01\x12\x04\x86\
    \x01\x08+\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04\x86\x01\x08\x10\n\r\n\
    \x05\x04\x05\x02\x01\x05\x12\x04\x86\x01\x11\x17\n\r\n\x05\x04\x05\x02\
    \x01\x01\x12\x04\x86\x01\x18&\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\x86\
    \x01)*\n\x0c\n\x04\x04\x05\x02\x02\x12\x04\x87\x01\x08.\n\r\n\x05\x04\
    \x05\x02\x02\x04\x12\x04\x87\x01\x08\x10\n\r\n\x05\x04\x05\x02\x02\x05\
    \x12\x04\x87\x01\x11\x17\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\x87\x01\
    \x18)\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\x87\x01,-\n\x0c\n\x04\x04\
    \x05\x02\x03\x12\x04\x88\x01\x08.\n\r\n\x05\x04\x05\x02\x03\x04\x12\x04\
    \x88\x01\x08\x10\n\r\n\x05\x04\x05\x02\x03\x05\x12\x04\x88\x01\x11\x17\n\
    \r\n\x05\x04\x05\x02\x03\x01\x12\x04\x88\x01\x18)\n\r\n\x05\x04\x05\x02\
    \x03\x03\x12\x04\x88\x01,-\n\x0c\n\x04\x04\x05\x02\x04\x12\x04\x89\x01\
    \x08,\n\r\n\x05\x04\x05\x02\x04\x04\x12\x04\x89\x01\x08\x10\n\r\n\x05\
    \x04\x05\x02\x04\x05\x12\x04\x89\x01\x11\x17\n\r\n\x05\x04\x05\x02\x04\
    \x01\x12\x04\x89\x01\x18'\n\r\n\x05\x04\x05\x02\x04\x03\x12\x04\x89\x01*\
    +\n\x0c\n\x04\x04\x05\x02\x05\x12\x04\x8a\x01\x08,\n\r\n\x05\x04\x05\x02\
    \x05\x04\x12\x04\x8a\x01\x08\x10\n\r\n\x05\x04\x05\x02\x05\x05\x12\x04\
    \x8a\x01\x11\x17\n\r\n\x05\x04\x05\x02\x05\x01\x12\x04\x8a\x01\x18'\n\r\
    \n\x05\x04\x05\x02\x05\x03\x12\x04\x8a\x01*+\n\x0c\n\x04\x04\x05\x02\x06\
    \x12\x04\x8b\x01\x08@\n\r\n\x05\x04\x05\x02\x06\x04\x12\x04\x8b\x01\x08\
    \x10\n\r\n\x05\x04\x05\x02\x06\x06\x12\x04\x8b\x01\x11)\n\r\n\x05\x04\
    \x05\x02\x06\x01\x12\x04\x8b\x01*;\n\r\n\x05\x04\x05\x02\x06\x03\x12\x04\
    \x8b\x01>?\n\x0c\n\x04\x04\x05\x02\x07\x12\x04\x8c\x01\x08*\n\r\n\x05\
    \x04\x05\x02\x07\x04\x12\x04\x8c\x01\x08\x10\n\r\n\x05\x04\x05\x02\x07\
    \x05\x12\x04\x8c\x01\x11\x17\n\r\n\x05\x04\x05\x02\x07\x01\x12\x04\x8c\
    \x01\x18%\n\r\n\x05\x04\x05\x02\x07\x03\x12\x04\x8c\x01()\n\x0c\n\x04\
    \x04\x05\x02\x08\x12\x04\x8d\x01\x083\n\r\n\x05\x04\x05\x02\x08\x04\x12\
    \x04\x8d\x01\x08\x10\n\r\n\x05\x04\x05\x02\x08\x05\x12\x04\x8d\x01\x11\
    \x17\n\r\n\x05\x04\x05\x02\x08\x01\x12\x04\x8d\x01\x18.\n\r\n\x05\x04\
    \x05\x02\x08\x03\x12\x04\x8d\x0112\n\x0c\n\x04\x04\x05\x02\t\x12\x04\x8e\
    \x01\x080\n\r\n\x05\x04\x05\x02\t\x04\x12\x04\x8e\x01\x08\x10\n\r\n\x05\
    \x04\x05\x02\t\x05\x12\x04\x8e\x01\x11\x17\n\r\n\x05\x04\x05\x02\t\x01\
    \x12\x04\x8e\x01\x18*\n\r\n\x05\x04\x05\x02\t\x03\x12\x04\x8e\x01-/\n\
    \x0c\n\x04\x04\x05\x02\n\x12\x04\x8f\x01\x084\n\r\n\x05\x04\x05\x02\n\
    \x04\x12\x04\x8f\x01\x08\x10\n\r\n\x05\x04\x05\x02\n\x05\x12\x04\x8f\x01\
    \x11\x17\n\r\n\x05\x04\x05\x02\n\x01\x12\x04\x8f\x01\x18.\n\r\n\x05\x04\
    \x05\x02\n\x03\x12\x04\x8f\x0113\n\x0c\n\x04\x04\x05\x02\x0b\x12\x04\x90\
    \x01\x087\n\r\n\x05\x04\x05\x02\x0b\x04\x12\x04\x90\x01\x08\x10\n\r\n\
    \x05\x04\x05\x02\x0b\x05\x12\x04\x90\x01\x11\x17\n\r\n\x05\x04\x05\x02\
    \x0b\x01\x12\x04\x90\x01\x181\n\r\n\x05\x04\x05\x02\x0b\x03\x12\x04\x90\
    \x0146\n\x0c\n\x04\x04\x05\x02\x0c\x12\x04\x91\x01\x08.\n\r\n\x05\x04\
    \x05\x02\x0c\x04\x12\x04\x91\x01\x08\x10\n\r\n\x05\x04\x05\x02\x0c\x05\
    \x12\x04\x91\x01\x11\x17\n\r\n\x05\x04\x05\x02\x0c\x01\x12\x04\x91\x01\
    \x18(\n\r\n\x05\x04\x05\x02\x0c\x03\x12\x04\x91\x01+-\n\x0c\n\x02\x04\
    \x06\x12\x06\x94\x01\0\x97\x01\x01\n\x0b\n\x03\x04\x06\x01\x12\x04\x94\
    \x01\x08'\n\x0c\n\x04\x04\x06\x02\0\x12\x04\x95\x01\x08!\n\r\n\x05\x04\
    \x06\x02\0\x04\x12\x04\x95\x01\x08\x10\n\r\n\x05\x04\x06\x02\0\x05\x12\
    \x04\x95\x01\x11\x17\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\x95\x01\x18\x1c\
    \n\r\n\x05\x04\x06\x02\0\x03\x12\x04\x95\x01\x1f\x20\n\x0c\n\x04\x04\x06\
    \x02\x01\x12\x04\x96\x01\x08\"\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\x96\
    \x01\x08\x10\n\r\n\x05\x04\x06\x02\x01\x05\x12\x04\x96\x01\x11\x17\n\r\n\
    \x05\x04\x06\x02\x01\x01\x12\x04\x96\x01\x18\x1d\n\r\n\x05\x04\x06\x02\
    \x01\x03\x12\x04\x96\x01\x20!\n\x0c\n\x02\x04\x07\x12\x06\x99\x01\0\x9c\
    \x01\x01\n\x0b\n\x03\x04\x07\x01\x12\x04\x99\x01\x08#\n\x0c\n\x04\x04\
    \x07\x02\0\x12\x04\x9a\x01\x08\"\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\x9a\
    \x01\x08\x10\n\r\n\x05\x04\x07\x02\0\x05\x12\x04\x9a\x01\x11\x17\n\r\n\
    \x05\x04\x07\x02\0\x01\x12\x04\x9a\x01\x18\x1d\n\r\n\x05\x04\x07\x02\0\
    \x03\x12\x04\x9a\x01\x20!\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\x9b\x01\
    \x08\"\n\r\n\x05\x04\x07\x02\x01\x04\x12\x04\x9b\x01\x08\x10\n\r\n\x05\
    \x04\x07\x02\x01\x05\x12\x04\x9b\x01\x11\x16\n\r\n\x05\x04\x07\x02\x01\
    \x01\x12\x04\x9b\x01\x17\x1d\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\x9b\
    \x01\x20!\n\x0c\n\x02\x04\x08\x12\x06\x9e\x01\0\xa2\x01\x01\n\x0b\n\x03\
    \x04\x08\x01\x12\x04\x9e\x01\x08#\n\x0c\n\x04\x04\x08\x02\0\x12\x04\x9f\
    \x01\x08$\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\x9f\x01\x08\x10\n\r\n\x05\
    \x04\x08\x02\0\x05\x12\x04\x9f\x01\x11\x16\n\r\n\x05\x04\x08\x02\0\x01\
    \x12\x04\x9f\x01\x17\x1f\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x9f\x01\"#\
    \n\x0c\n\x04\x04\x08\x02\x01\x12\x04\xa0\x01\x08'\n\r\n\x05\x04\x08\x02\
    \x01\x04\x12\x04\xa0\x01\x08\x10\n\r\n\x05\x04\x08\x02\x01\x05\x12\x04\
    \xa0\x01\x11\x16\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xa0\x01\x17\"\n\r\
    \n\x05\x04\x08\x02\x01\x03\x12\x04\xa0\x01%&\n\x0c\n\x04\x04\x08\x02\x02\
    \x12\x04\xa1\x01\x089\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\xa1\x01\x08\
    \x10\n\r\n\x05\x04\x08\x02\x02\x06\x12\x04\xa1\x01\x11-\n\r\n\x05\x04\
    \x08\x02\x02\x01\x12\x04\xa1\x01.4\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\
    \xa1\x0178\n\x0c\n\x02\x04\t\x12\x06\xa4\x01\0\xa9\x01\x01\n\x0b\n\x03\
    \x04\t\x01\x12\x04\xa4\x01\x08\x19\n\x0c\n\x04\x04\t\x02\0\x12\x04\xa5\
    \x01\x08'\n\r\n\x05\x04\t\x02\0\x04\x12\x04\xa5\x01\x08\x10\n\r\n\x05\
    \x04\t\x02\0\x05\x12\x04\xa5\x01\x11\x17\n\r\n\x05\x04\t\x02\0\x01\x12\
    \x04\xa5\x01\x18\"\n\r\n\x05\x04\t\x02\0\x03\x12\x04\xa5\x01%&\n\x0c\n\
    \x04\x04\t\x02\x01\x12\x04\xa6\x01\x08$\n\r\n\x05\x04\t\x02\x01\x04\x12\
    \x04\xa6\x01\x08\x10\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\xa6\x01\x11\x17\
    \n\r\n\x05\x04\t\x02\x01\x01\x12\x04\xa6\x01\x18\x1f\n\r\n\x05\x04\t\x02\
    \x01\x03\x12\x04\xa6\x01\"#\n\x0c\n\x04\x04\t\x02\x02\x12\x04\xa7\x01\
    \x08!\n\r\n\x05\x04\t\x02\x02\x04\x12\x04\xa7\x01\x08\x10\n\r\n\x05\x04\
    \t\x02\x02\x05\x12\x04\xa7\x01\x11\x17\n\r\n\x05\x04\t\x02\x02\x01\x12\
    \x04\xa7\x01\x18\x1c\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xa7\x01\x1f\x20\
    \n\x0c\n\x04\x04\t\x02\x03\x12\x04\xa8\x01\x08'\n\r\n\x05\x04\t\x02\x03\
    \x04\x12\x04\xa8\x01\x08\x10\n\r\n\x05\x04\t\x02\x03\x05\x12\x04\xa8\x01\
    \x11\x16\n\r\n\x05\x04\t\x02\x03\x01\x12\x04\xa8\x01\x17\"\n\r\n\x05\x04\
    \t\x02\x03\x03\x12\x04\xa8\x01%&\n\x0c\n\x02\x04\n\x12\x06\xab\x01\0\xaf\
    \x01\x01\n\x0b\n\x03\x04\n\x01\x12\x04\xab\x01\x08\x1e\n\x0c\n\x04\x04\n\
    \x02\0\x12\x04\xac\x01\x08)\n\r\n\x05\x04\n\x02\0\x04\x12\x04\xac\x01\
    \x08\x10\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xac\x01\x11\x17\n\r\n\x05\x04\
    \n\x02\0\x01\x12\x04\xac\x01\x18$\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xac\
    \x01'(\n\x0c\n\x04\x04\n\x02\x01\x12\x04\xad\x01\x08)\n\r\n\x05\x04\n\
    \x02\x01\x04\x12\x04\xad\x01\x08\x10\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\
    \xad\x01\x11\x17\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xad\x01\x18$\n\r\n\
    \x05\x04\n\x02\x01\x03\x12\x04\xad\x01'(\n\x0c\n\x04\x04\n\x02\x02\x12\
    \x04\xae\x01\x08'\n\r\n\x05\x04\n\x02\x02\x04\x12\x04\xae\x01\x08\x10\n\
    \r\n\x05\x04\n\x02\x02\x05\x12\x04\xae\x01\x11\x17\n\r\n\x05\x04\n\x02\
    \x02\x01\x12\x04\xae\x01\x18\"\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xae\
    \x01%&\n\x0c\n\x02\x04\x0b\x12\x06\xb1\x01\0\xb9\x01\x01\n\x0b\n\x03\x04\
    \x0b\x01\x12\x04\xb1\x01\x08\x18\n\x0c\n\x04\x04\x0b\x02\0\x12\x04\xb2\
    \x01\x08'\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xb2\x01\x08\x10\n\r\n\x05\
    \x04\x0b\x02\0\x05\x12\x04\xb2\x01\x11\x17\n\r\n\x05\x04\x0b\x02\0\x01\
    \x12\x04\xb2\x01\x18\"\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xb2\x01%&\n\
    \x0c\n\x04\x04\x0b\x02\x01\x12\x04\xb3\x01\x08)\n\r\n\x05\x04\x0b\x02\
    \x01\x04\x12\x04\xb3\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\
    \xb3\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xb3\x01\x18$\n\r\
    \n\x05\x04\x0b\x02\x01\x03\x12\x04\xb3\x01'(\n\x0c\n\x04\x04\x0b\x02\x02\
    \x12\x04\xb4\x01\x08)\n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\xb4\x01\x08\
    \x10\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\xb4\x01\x11\x17\n\r\n\x05\x04\
    \x0b\x02\x02\x01\x12\x04\xb4\x01\x18$\n\r\n\x05\x04\x0b\x02\x02\x03\x12\
    \x04\xb4\x01'(\n\x0c\n\x04\x04\x0b\x02\x03\x12\x04\xb5\x01\x08)\n\r\n\
    \x05\x04\x0b\x02\x03\x04\x12\x04\xb5\x01\x08\x10\n\r\n\x05\x04\x0b\x02\
    \x03\x05\x12\x04\xb5\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\
    \xb5\x01\x18$\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\xb5\x01'(\n\x0c\n\
    \x04\x04\x0b\x02\x04\x12\x04\xb6\x01\x08'\n\r\n\x05\x04\x0b\x02\x04\x04\
    \x12\x04\xb6\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x04\x05\x12\x04\xb6\x01\
    \x11\x17\n\r\n\x05\x04\x0b\x02\x04\x01\x12\x04\xb6\x01\x18\"\n\r\n\x05\
    \x04\x0b\x02\x04\x03\x12\x04\xb6\x01%&\n\x0c\n\x04\x04\x0b\x02\x05\x12\
    \x04\xb7\x01\x081\n\r\n\x05\x04\x0b\x02\x05\x04\x12\x04\xb7\x01\x08\x10\
    \n\r\n\x05\x04\x0b\x02\x05\x05\x12\x04\xb7\x01\x11\x17\n\r\n\x05\x04\x0b\
    \x02\x05\x01\x12\x04\xb7\x01\x18,\n\r\n\x05\x04\x0b\x02\x05\x03\x12\x04\
    \xb7\x01/0\n\x0c\n\x04\x04\x0b\x02\x06\x12\x04\xb8\x01\x089\n\r\n\x05\
    \x04\x0b\x02\x06\x04\x12\x04\xb8\x01\x08\x10\n\r\n\x05\x04\x0b\x02\x06\
    \x05\x12\x04\xb8\x01\x11\x17\n\r\n\x05\x04\x0b\x02\x06\x01\x12\x04\xb8\
    \x01\x184\n\r\n\x05\x04\x0b\x02\x06\x03\x12\x04\xb8\x0178\n\x0c\n\x02\
    \x04\x0c\x12\x06\xbb\x01\0\xbf\x01\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\
    \xbb\x01\x08\x17\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\xbc\x01\x08%\n\r\n\
    \x05\x04\x0c\x02\0\x04\x12\x04\xbc\x01\x08\x10\n\r\n\x05\x04\x0c\x02\0\
    \x05\x12\x04\xbc\x01\x11\x17\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xbc\x01\
    \x18\x20\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xbc\x01#$\n\x0c\n\x04\x04\
    \x0c\x02\x01\x12\x04\xbd\x01\x08!\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\
    \xbd\x01\x08\x10\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xbd\x01\x11\x17\n\
    \r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xbd\x01\x18\x1c\n\r\n\x05\x04\x0c\
    \x02\x01\x03\x12\x04\xbd\x01\x1f\x20\n\x0c\n\x04\x04\x0c\x02\x02\x12\x04\
    \xbe\x01\x08\x20\n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\xbe\x01\x08\x10\n\
    \r\n\x05\x04\x0c\x02\x02\x05\x12\x04\xbe\x01\x11\x17\n\r\n\x05\x04\x0c\
    \x02\x02\x01\x12\x04\xbe\x01\x18\x1b\n\r\n\x05\x04\x0c\x02\x02\x03\x12\
    \x04\xbe\x01\x1e\x1f\n\x0c\n\x02\x04\r\x12\x06\xc1\x01\0\xc6\x01\x01\n\
    \x0b\n\x03\x04\r\x01\x12\x04\xc1\x01\x08\x1c\n\x0c\n\x04\x04\r\x02\0\x12\
    \x04\xc2\x01\x08$\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xc2\x01\x08\x10\n\r\
    \n\x05\x04\r\x02\0\x05\x12\x04\xc2\x01\x11\x16\n\r\n\x05\x04\r\x02\0\x01\
    \x12\x04\xc2\x01\x17\x1f\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xc2\x01\"#\n\
    \x0c\n\x04\x04\r\x02\x01\x12\x04\xc3\x01\x08&\n\r\n\x05\x04\r\x02\x01\
    \x04\x12\x04\xc3\x01\x08\x10\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xc3\x01\
    \x11\x16\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xc3\x01\x17!\n\r\n\x05\x04\
    \r\x02\x01\x03\x12\x04\xc3\x01$%\n\x0c\n\x04\x04\r\x02\x02\x12\x04\xc4\
    \x01\x08%\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xc4\x01\x08\x10\n\r\n\x05\
    \x04\r\x02\x02\x05\x12\x04\xc4\x01\x11\x16\n\r\n\x05\x04\r\x02\x02\x01\
    \x12\x04\xc4\x01\x17\x20\n\r\n\x05\x04\r\x02\x02\x03\x12\x04\xc4\x01#$\n\
    \x0c\n\x04\x04\r\x02\x03\x12\x04\xc5\x01\x08*\n\r\n\x05\x04\r\x02\x03\
    \x04\x12\x04\xc5\x01\x08\x10\n\r\n\x05\x04\r\x02\x03\x05\x12\x04\xc5\x01\
    \x11\x16\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\xc5\x01\x17%\n\r\n\x05\x04\
    \r\x02\x03\x03\x12\x04\xc5\x01()\n\x0c\n\x02\x04\x0e\x12\x06\xc8\x01\0\
    \xdc\x01\x01\n\x0b\n\x03\x04\x0e\x01\x12\x04\xc8\x01\x08\x16\n\x0c\n\x04\
    \x04\x0e\x02\0\x12\x04\xc9\x01\x08(\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\
    \xc9\x01\x08\x10\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xc9\x01\x11\x17\n\r\
    \n\x05\x04\x0e\x02\0\x01\x12\x04\xc9\x01\x18#\n\r\n\x05\x04\x0e\x02\0\
    \x03\x12\x04\xc9\x01&'\n\x0c\n\x04\x04\x0e\x02\x01\x12\x04\xca\x01\x08)\
    \n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\xca\x01\x08\x10\n\r\n\x05\x04\x0e\
    \x02\x01\x05\x12\x04\xca\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x01\x01\x12\
    \x04\xca\x01\x18$\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xca\x01'(\n\x0c\
    \n\x04\x04\x0e\x02\x02\x12\x04\xcb\x01\x08%\n\r\n\x05\x04\x0e\x02\x02\
    \x04\x12\x04\xcb\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x02\x05\x12\x04\xcb\
    \x01\x11\x17\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\xcb\x01\x18\x20\n\r\n\
    \x05\x04\x0e\x02\x02\x03\x12\x04\xcb\x01#$\n\x0c\n\x04\x04\x0e\x02\x03\
    \x12\x04\xcc\x01\x08'\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\xcc\x01\x08\
    \x10\n\r\n\x05\x04\x0e\x02\x03\x05\x12\x04\xcc\x01\x11\x17\n\r\n\x05\x04\
    \x0e\x02\x03\x01\x12\x04\xcc\x01\x18\"\n\r\n\x05\x04\x0e\x02\x03\x03\x12\
    \x04\xcc\x01%&\n\x0c\n\x04\x04\x0e\x02\x04\x12\x04\xcd\x01\x08'\n\r\n\
    \x05\x04\x0e\x02\x04\x04\x12\x04\xcd\x01\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x04\x05\x12\x04\xcd\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x04\x01\x12\x04\
    \xcd\x01\x18\"\n\r\n\x05\x04\x0e\x02\x04\x03\x12\x04\xcd\x01%&\n\x0c\n\
    \x04\x04\x0e\x02\x05\x12\x04\xce\x01\x08$\n\r\n\x05\x04\x0e\x02\x05\x04\
    \x12\x04\xce\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x05\x05\x12\x04\xce\x01\
    \x11\x17\n\r\n\x05\x04\x0e\x02\x05\x01\x12\x04\xce\x01\x18\x1f\n\r\n\x05\
    \x04\x0e\x02\x05\x03\x12\x04\xce\x01\"#\n\x0c\n\x04\x04\x0e\x02\x06\x12\
    \x04\xcf\x01\x08&\n\r\n\x05\x04\x0e\x02\x06\x04\x12\x04\xcf\x01\x08\x10\
    \n\r\n\x05\x04\x0e\x02\x06\x05\x12\x04\xcf\x01\x11\x17\n\r\n\x05\x04\x0e\
    \x02\x06\x01\x12\x04\xcf\x01\x18!\n\r\n\x05\x04\x0e\x02\x06\x03\x12\x04\
    \xcf\x01$%\n\x0c\n\x04\x04\x0e\x02\x07\x12\x04\xd0\x01\x08*\n\r\n\x05\
    \x04\x0e\x02\x07\x04\x12\x04\xd0\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x07\
    \x05\x12\x04\xd0\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x07\x01\x12\x04\xd0\
    \x01\x18%\n\r\n\x05\x04\x0e\x02\x07\x03\x12\x04\xd0\x01()\n\x0c\n\x04\
    \x04\x0e\x02\x08\x12\x04\xd1\x01\x08&\n\r\n\x05\x04\x0e\x02\x08\x04\x12\
    \x04\xd1\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x08\x05\x12\x04\xd1\x01\x11\
    \x17\n\r\n\x05\x04\x0e\x02\x08\x01\x12\x04\xd1\x01\x18\x20\n\r\n\x05\x04\
    \x0e\x02\x08\x03\x12\x04\xd1\x01#%\n\x0c\n\x04\x04\x0e\x02\t\x12\x04\xd2\
    \x01\x08/\n\r\n\x05\x04\x0e\x02\t\x04\x12\x04\xd2\x01\x08\x10\n\r\n\x05\
    \x04\x0e\x02\t\x05\x12\x04\xd2\x01\x11\x17\n\r\n\x05\x04\x0e\x02\t\x01\
    \x12\x04\xd2\x01\x18)\n\r\n\x05\x04\x0e\x02\t\x03\x12\x04\xd2\x01,.\n\
    \x0c\n\x04\x04\x0e\x02\n\x12\x04\xd3\x01\x08,\n\r\n\x05\x04\x0e\x02\n\
    \x04\x12\x04\xd3\x01\x08\x10\n\r\n\x05\x04\x0e\x02\n\x05\x12\x04\xd3\x01\
    \x11\x17\n\r\n\x05\x04\x0e\x02\n\x01\x12\x04\xd3\x01\x18&\n\r\n\x05\x04\
    \x0e\x02\n\x03\x12\x04\xd3\x01)+\n\x0c\n\x04\x04\x0e\x02\x0b\x12\x04\xd4\
    \x01\x08.\n\r\n\x05\x04\x0e\x02\x0b\x04\x12\x04\xd4\x01\x08\x10\n\r\n\
    \x05\x04\x0e\x02\x0b\x05\x12\x04\xd4\x01\x11\x17\n\r\n\x05\x04\x0e\x02\
    \x0b\x01\x12\x04\xd4\x01\x18(\n\r\n\x05\x04\x0e\x02\x0b\x03\x12\x04\xd4\
    \x01+-\n\x0c\n\x04\x04\x0e\x02\x0c\x12\x04\xd5\x01\x08.\n\r\n\x05\x04\
    \x0e\x02\x0c\x04\x12\x04\xd5\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x0c\x05\
    \x12\x04\xd5\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x0c\x01\x12\x04\xd5\x01\
    \x18(\n\r\n\x05\x04\x0e\x02\x0c\x03\x12\x04\xd5\x01+-\n\x0c\n\x04\x04\
    \x0e\x02\r\x12\x04\xd6\x01\x08,\n\r\n\x05\x04\x0e\x02\r\x04\x12\x04\xd6\
    \x01\x08\x10\n\r\n\x05\x04\x0e\x02\r\x05\x12\x04\xd6\x01\x11\x17\n\r\n\
    \x05\x04\x0e\x02\r\x01\x12\x04\xd6\x01\x18&\n\r\n\x05\x04\x0e\x02\r\x03\
    \x12\x04\xd6\x01)+\n\x0c\n\x04\x04\x0e\x02\x0e\x12\x04\xd7\x01\x08.\n\r\
    \n\x05\x04\x0e\x02\x0e\x04\x12\x04\xd7\x01\x08\x10\n\r\n\x05\x04\x0e\x02\
    \x0e\x05\x12\x04\xd7\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x0e\x01\x12\x04\
    \xd7\x01\x18(\n\r\n\x05\x04\x0e\x02\x0e\x03\x12\x04\xd7\x01+-\n\x0c\n\
    \x04\x04\x0e\x02\x0f\x12\x04\xd8\x01\x08.\n\r\n\x05\x04\x0e\x02\x0f\x04\
    \x12\x04\xd8\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x0f\x05\x12\x04\xd8\x01\
    \x11\x17\n\r\n\x05\x04\x0e\x02\x0f\x01\x12\x04\xd8\x01\x18(\n\r\n\x05\
    \x04\x0e\x02\x0f\x03\x12\x04\xd8\x01+-\n\x0c\n\x04\x04\x0e\x02\x10\x12\
    \x04\xd9\x01\x08.\n\r\n\x05\x04\x0e\x02\x10\x04\x12\x04\xd9\x01\x08\x10\
    \n\r\n\x05\x04\x0e\x02\x10\x05\x12\x04\xd9\x01\x11\x17\n\r\n\x05\x04\x0e\
    \x02\x10\x01\x12\x04\xd9\x01\x18(\n\r\n\x05\x04\x0e\x02\x10\x03\x12\x04\
    \xd9\x01+-\n\x0c\n\x04\x04\x0e\x02\x11\x12\x04\xda\x01\x08+\n\r\n\x05\
    \x04\x0e\x02\x11\x04\x12\x04\xda\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x11\
    \x05\x12\x04\xda\x01\x11\x17\n\r\n\x05\x04\x0e\x02\x11\x01\x12\x04\xda\
    \x01\x18%\n\r\n\x05\x04\x0e\x02\x11\x03\x12\x04\xda\x01(*\n\x0c\n\x04\
    \x04\x0e\x02\x12\x12\x04\xdb\x01\x08.\n\r\n\x05\x04\x0e\x02\x12\x04\x12\
    \x04\xdb\x01\x08\x10\n\r\n\x05\x04\x0e\x02\x12\x05\x12\x04\xdb\x01\x11\
    \x17\n\r\n\x05\x04\x0e\x02\x12\x01\x12\x04\xdb\x01\x18(\n\r\n\x05\x04\
    \x0e\x02\x12\x03\x12\x04\xdb\x01+-\n\x0c\n\x02\x04\x0f\x12\x06\xde\x01\0\
    \xe5\x01\x01\n\x0b\n\x03\x04\x0f\x01\x12\x04\xde\x01\x08\x15\n\x0c\n\x04\
    \x04\x0f\x02\0\x12\x04\xdf\x01\x08\x1e\n\r\n\x05\x04\x0f\x02\0\x04\x12\
    \x04\xdf\x01\x08\x10\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\xdf\x01\x11\x17\
    \n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xdf\x01\x18\x19\n\r\n\x05\x04\x0f\
    \x02\0\x03\x12\x04\xdf\x01\x1c\x1d\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\
    \xe0\x01\x08\x1e\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xe0\x01\x08\x10\n\
    \r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xe0\x01\x11\x17\n\r\n\x05\x04\x0f\
    \x02\x01\x01\x12\x04\xe0\x01\x18\x19\n\r\n\x05\x04\x0f\x02\x01\x03\x12\
    \x04\xe0\x01\x1c\x1d\n\x0c\n\x04\x04\x0f\x02\x02\x12\x04\xe1\x01\x08\x1e\
    \n\r\n\x05\x04\x0f\x02\x02\x04\x12\x04\xe1\x01\x08\x10\n\r\n\x05\x04\x0f\
    \x02\x02\x05\x12\x04\xe1\x01\x11\x17\n\r\n\x05\x04\x0f\x02\x02\x01\x12\
    \x04\xe1\x01\x18\x19\n\r\n\x05\x04\x0f\x02\x02\x03\x12\x04\xe1\x01\x1c\
    \x1d\n\x0c\n\x04\x04\x0f\x02\x03\x12\x04\xe2\x01\x08\x1e\n\r\n\x05\x04\
    \x0f\x02\x03\x04\x12\x04\xe2\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x03\x05\
    \x12\x04\xe2\x01\x11\x17\n\r\n\x05\x04\x0f\x02\x03\x01\x12\x04\xe2\x01\
    \x18\x19\n\r\n\x05\x04\x0f\x02\x03\x03\x12\x04\xe2\x01\x1c\x1d\n\x0c\n\
    \x04\x04\x0f\x02\x04\x12\x04\xe3\x01\x08!\n\r\n\x05\x04\x0f\x02\x04\x04\
    \x12\x04\xe3\x01\x08\x10\n\r\n\x05\x04\x0f\x02\x04\x05\x12\x04\xe3\x01\
    \x11\x17\n\r\n\x05\x04\x0f\x02\x04\x01\x12\x04\xe3\x01\x18\x1c\n\r\n\x05\
    \x04\x0f\x02\x04\x03\x12\x04\xe3\x01\x1f\x20\n\x0c\n\x04\x04\x0f\x02\x05\
    \x12\x04\xe4\x01\x08\"\n\r\n\x05\x04\x0f\x02\x05\x04\x12\x04\xe4\x01\x08\
    \x10\n\r\n\x05\x04\x0f\x02\x05\x05\x12\x04\xe4\x01\x11\x17\n\r\n\x05\x04\
    \x0f\x02\x05\x01\x12\x04\xe4\x01\x18\x1d\n\r\n\x05\x04\x0f\x02\x05\x03\
    \x12\x04\xe4\x01\x20!\n\x0c\n\x02\x04\x10\x12\x06\xe7\x01\0\xea\x01\x01\
    \n\x0b\n\x03\x04\x10\x01\x12\x04\xe7\x01\x08\x16\n\x0c\n\x04\x04\x10\x02\
    \0\x12\x04\xe8\x01\x08&\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xe8\x01\x08\
    \x10\n\r\n\x05\x04\x10\x02\0\x05\x12\x04\xe8\x01\x11\x17\n\r\n\x05\x04\
    \x10\x02\0\x01\x12\x04\xe8\x01\x18!\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\
    \xe8\x01$%\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xe9\x01\x08'\n\r\n\x05\
    \x04\x10\x02\x01\x04\x12\x04\xe9\x01\x08\x10\n\r\n\x05\x04\x10\x02\x01\
    \x05\x12\x04\xe9\x01\x11\x16\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xe9\
    \x01\x17\"\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xe9\x01%&\n\x0c\n\x02\
    \x04\x11\x12\x06\xec\x01\0\xf0\x01\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\
    \xec\x01\x08\x1b\n\x0c\n\x04\x04\x11\x02\0\x12\x04\xed\x01\x08$\n\r\n\
    \x05\x04\x11\x02\0\x04\x12\x04\xed\x01\x08\x10\n\r\n\x05\x04\x11\x02\0\
    \x05\x12\x04\xed\x01\x11\x17\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xed\x01\
    \x18\x1f\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xed\x01\"#\n\x0c\n\x04\x04\
    \x11\x02\x01\x12\x04\xee\x01\x08-\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\
    \xee\x01\x08\x10\n\r\n\x05\x04\x11\x02\x01\x05\x12\x04\xee\x01\x11\x17\n\
    \r\n\x05\x04\x11\x02\x01\x01\x12\x04\xee\x01\x18(\n\r\n\x05\x04\x11\x02\
    \x01\x03\x12\x04\xee\x01+,\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\xef\x01\
    \x082\n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\xef\x01\x08\x10\n\r\n\x05\
    \x04\x11\x02\x02\x05\x12\x04\xef\x01\x11\x17\n\r\n\x05\x04\x11\x02\x02\
    \x01\x12\x04\xef\x01\x18-\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xef\x010\
    1\n\x0c\n\x02\x04\x12\x12\x06\xf2\x01\0\x81\x02\x01\n\x0b\n\x03\x04\x12\
    \x01\x12\x04\xf2\x01\x08\x1c\n\x0e\n\x04\x04\x12\x03\0\x12\x06\xf3\x01\
    \x08\xf6\x01\t\n\r\n\x05\x04\x12\x03\0\x01\x12\x04\xf3\x01\x10\x15\n\x0e\
    \n\x06\x04\x12\x03\0\x02\0\x12\x04\xf4\x01\x10(\n\x0f\n\x07\x04\x12\x03\
    \0\x02\0\x04\x12\x04\xf4\x01\x10\x18\n\x0f\n\x07\x04\x12\x03\0\x02\0\x05\
    \x12\x04\xf4\x01\x19\x1f\n\x0f\n\x07\x04\x12\x03\0\x02\0\x01\x12\x04\xf4\
    \x01\x20#\n\x0f\n\x07\x04\x12\x03\0\x02\0\x03\x12\x04\xf4\x01&'\n\x0e\n\
    \x06\x04\x12\x03\0\x02\x01\x12\x04\xf5\x01\x10(\n\x0f\n\x07\x04\x12\x03\
    \0\x02\x01\x04\x12\x04\xf5\x01\x10\x18\n\x0f\n\x07\x04\x12\x03\0\x02\x01\
    \x05\x12\x04\xf5\x01\x19\x1f\n\x0f\n\x07\x04\x12\x03\0\x02\x01\x01\x12\
    \x04\xf5\x01\x20#\n\x0f\n\x07\x04\x12\x03\0\x02\x01\x03\x12\x04\xf5\x01&\
    '\n\x0e\n\x04\x04\x12\x03\x01\x12\x06\xf8\x01\x08\xfb\x01\t\n\r\n\x05\
    \x04\x12\x03\x01\x01\x12\x04\xf8\x01\x10\x1e\n\x0e\n\x06\x04\x12\x03\x01\
    \x02\0\x12\x04\xf9\x01\x10.\n\x0f\n\x07\x04\x12\x03\x01\x02\0\x04\x12\
    \x04\xf9\x01\x10\x18\n\x0f\n\x07\x04\x12\x03\x01\x02\0\x05\x12\x04\xf9\
    \x01\x19\x1f\n\x0f\n\x07\x04\x12\x03\x01\x02\0\x01\x12\x04\xf9\x01\x20)\
    \n\x0f\n\x07\x04\x12\x03\x01\x02\0\x03\x12\x04\xf9\x01,-\n\x0e\n\x06\x04\
    \x12\x03\x01\x02\x01\x12\x04\xfa\x01\x10A\n\x0f\n\x07\x04\x12\x03\x01\
    \x02\x01\x04\x12\x04\xfa\x01\x10\x18\n\x0f\n\x07\x04\x12\x03\x01\x02\x01\
    \x06\x12\x04\xfa\x01\x194\n\x0f\n\x07\x04\x12\x03\x01\x02\x01\x01\x12\
    \x04\xfa\x015<\n\x0f\n\x07\x04\x12\x03\x01\x02\x01\x03\x12\x04\xfa\x01?@\
    \n\x0c\n\x04\x04\x12\x02\0\x12\x04\xfd\x01\x08%\n\r\n\x05\x04\x12\x02\0\
    \x04\x12\x04\xfd\x01\x08\x10\n\r\n\x05\x04\x12\x02\0\x05\x12\x04\xfd\x01\
    \x11\x17\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xfd\x01\x18\x20\n\r\n\x05\
    \x04\x12\x02\0\x03\x12\x04\xfd\x01#$\n\x0c\n\x04\x04\x12\x02\x01\x12\x04\
    \xfe\x01\x08\"\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\xfe\x01\x08\x10\n\r\
    \n\x05\x04\x12\x02\x01\x05\x12\x04\xfe\x01\x11\x17\n\r\n\x05\x04\x12\x02\
    \x01\x01\x12\x04\xfe\x01\x18\x1d\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\
    \xfe\x01\x20!\n\x0c\n\x04\x04\x12\x02\x02\x12\x04\xff\x01\x08I\n\r\n\x05\
    \x04\x12\x02\x02\x04\x12\x04\xff\x01\x08\x10\n\r\n\x05\x04\x12\x02\x02\
    \x06\x12\x04\xff\x01\x115\n\r\n\x05\x04\x12\x02\x02\x01\x12\x04\xff\x016\
    D\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xff\x01GH\n\x0c\n\x04\x04\x12\
    \x02\x03\x12\x04\x80\x02\x08>\n\r\n\x05\x04\x12\x02\x03\x04\x12\x04\x80\
    \x02\x08\x10\n\r\n\x05\x04\x12\x02\x03\x06\x12\x04\x80\x02\x11,\n\r\n\
    \x05\x04\x12\x02\x03\x01\x12\x04\x80\x02-9\n\r\n\x05\x04\x12\x02\x03\x03\
    \x12\x04\x80\x02<=\n\x0c\n\x02\x04\x13\x12\x06\x83\x02\0\x90\x02\x01\n\
    \x0b\n\x03\x04\x13\x01\x12\x04\x83\x02\x08\x17\n\x0e\n\x04\x04\x13\x03\0\
    \x12\x06\x84\x02\x08\x88\x02\t\n\r\n\x05\x04\x13\x03\0\x01\x12\x04\x84\
    \x02\x10\x1d\n\x0e\n\x06\x04\x13\x03\0\x02\0\x12\x04\x85\x02\x10-\n\x0f\
    \n\x07\x04\x13\x03\0\x02\0\x04\x12\x04\x85\x02\x10\x18\n\x0f\n\x07\x04\
    \x13\x03\0\x02\0\x05\x12\x04\x85\x02\x19\x1f\n\x0f\n\x07\x04\x13\x03\0\
    \x02\0\x01\x12\x04\x85\x02\x20(\n\x0f\n\x07\x04\x13\x03\0\x02\0\x03\x12\
    \x04\x85\x02+,\n\x0e\n\x06\x04\x13\x03\0\x02\x01\x12\x04\x86\x02\x10>\n\
    \x0f\n\x07\x04\x13\x03\0\x02\x01\x04\x12\x04\x86\x02\x10\x18\n\x0f\n\x07\
    \x04\x13\x03\0\x02\x01\x05\x12\x04\x86\x02\x19\x1e\n\x0f\n\x07\x04\x13\
    \x03\0\x02\x01\x01\x12\x04\x86\x02\x1f9\n\x0f\n\x07\x04\x13\x03\0\x02\
    \x01\x03\x12\x04\x86\x02<=\n\x0e\n\x06\x04\x13\x03\0\x02\x02\x12\x04\x87\
    \x02\x10=\n\x0f\n\x07\x04\x13\x03\0\x02\x02\x04\x12\x04\x87\x02\x10\x18\
    \n\x0f\n\x07\x04\x13\x03\0\x02\x02\x05\x12\x04\x87\x02\x19\x1e\n\x0f\n\
    \x07\x04\x13\x03\0\x02\x02\x01\x12\x04\x87\x02\x1f8\n\x0f\n\x07\x04\x13\
    \x03\0\x02\x02\x03\x12\x04\x87\x02;<\n\x0c\n\x04\x04\x13\x02\0\x12\x04\
    \x8a\x02\x08/\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\x8a\x02\x08\x10\n\r\n\
    \x05\x04\x13\x02\0\x05\x12\x04\x8a\x02\x11\x17\n\r\n\x05\x04\x13\x02\0\
    \x01\x12\x04\x8a\x02\x18*\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\x8a\x02-.\
    \n\x0c\n\x04\x04\x13\x02\x01\x12\x04\x8b\x02\x08D\n\r\n\x05\x04\x13\x02\
    \x01\x04\x12\x04\x8b\x02\x08\x10\n\r\n\x05\x04\x13\x02\x01\x06\x12\x04\
    \x8b\x02\x11/\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\x8b\x020?\n\r\n\x05\
    \x04\x13\x02\x01\x03\x12\x04\x8b\x02BC\n\x0c\n\x04\x04\x13\x02\x02\x12\
    \x04\x8c\x02\x086\n\r\n\x05\x04\x13\x02\x02\x04\x12\x04\x8c\x02\x08\x10\
    \n\r\n\x05\x04\x13\x02\x02\x06\x12\x04\x8c\x02\x11\x20\n\r\n\x05\x04\x13\
    \x02\x02\x01\x12\x04\x8c\x02!1\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\x8c\
    \x0245\n\x0c\n\x04\x04\x13\x02\x03\x12\x04\x8d\x02\x08(\n\r\n\x05\x04\
    \x13\x02\x03\x04\x12\x04\x8d\x02\x08\x10\n\r\n\x05\x04\x13\x02\x03\x05\
    \x12\x04\x8d\x02\x11\x17\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\x8d\x02\
    \x18#\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\x8d\x02&'\n\x0c\n\x04\x04\
    \x13\x02\x04\x12\x04\x8e\x02\x08)\n\r\n\x05\x04\x13\x02\x04\x04\x12\x04\
    \x8e\x02\x08\x10\n\r\n\x05\x04\x13\x02\x04\x05\x12\x04\x8e\x02\x11\x17\n\
    \r\n\x05\x04\x13\x02\x04\x01\x12\x04\x8e\x02\x18$\n\r\n\x05\x04\x13\x02\
    \x04\x03\x12\x04\x8e\x02'(\n\x0c\n\x04\x04\x13\x02\x05\x12\x04\x8f\x02\
    \x087\n\r\n\x05\x04\x13\x02\x05\x04\x12\x04\x8f\x02\x08\x10\n\r\n\x05\
    \x04\x13\x02\x05\x06\x12\x04\x8f\x02\x11%\n\r\n\x05\x04\x13\x02\x05\x01\
    \x12\x04\x8f\x02&2\n\r\n\x05\x04\x13\x02\x05\x03\x12\x04\x8f\x0256\n\x0c\
    \n\x02\x04\x14\x12\x06\x92\x02\0\x97\x02\x01\n\x0b\n\x03\x04\x14\x01\x12\
    \x04\x92\x02\x08$\n\x0c\n\x04\x04\x14\x02\0\x12\x04\x93\x02\x088\n\r\n\
    \x05\x04\x14\x02\0\x04\x12\x04\x93\x02\x08\x10\n\r\n\x05\x04\x14\x02\0\
    \x06\x12\x04\x93\x02\x11!\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\x93\x02\"3\
    \n\r\n\x05\x04\x14\x02\0\x03\x12\x04\x93\x0267\n\x0c\n\x04\x04\x14\x02\
    \x01\x12\x04\x94\x02\x08'\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\x94\x02\
    \x08\x10\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\x94\x02\x11\x16\n\r\n\x05\
    \x04\x14\x02\x01\x01\x12\x04\x94\x02\x17\"\n\r\n\x05\x04\x14\x02\x01\x03\
    \x12\x04\x94\x02%&\n\x0c\n\x04\x04\x14\x02\x02\x12\x04\x95\x02\x08)\n\r\
    \n\x05\x04\x14\x02\x02\x04\x12\x04\x95\x02\x08\x10\n\r\n\x05\x04\x14\x02\
    \x02\x05\x12\x04\x95\x02\x11\x17\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\
    \x95\x02\x18$\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\x95\x02'(\n\x0c\n\
    \x04\x04\x14\x02\x03\x12\x04\x96\x02\x08:\n\r\n\x05\x04\x14\x02\x03\x04\
    \x12\x04\x96\x02\x08\x10\n\r\n\x05\x04\x14\x02\x03\x06\x12\x04\x96\x02\
    \x11&\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\x96\x02'5\n\r\n\x05\x04\x14\
    \x02\x03\x03\x12\x04\x96\x0289\n\x0c\n\x02\x04\x15\x12\x06\x99\x02\0\x9d\
    \x02\x01\n\x0b\n\x03\x04\x15\x01\x12\x04\x99\x02\x088\n\x0c\n\x04\x04\
    \x15\x02\0\x12\x04\x9a\x02\x08$\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\x9a\
    \x02\x08\x10\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\x9a\x02\x11\x16\n\r\n\
    \x05\x04\x15\x02\0\x01\x12\x04\x9a\x02\x17\x1f\n\r\n\x05\x04\x15\x02\0\
    \x03\x12\x04\x9a\x02\"#\n\x0c\n\x04\x04\x15\x02\x01\x12\x04\x9b\x02\x08?\
    \n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\x9b\x02\x08\x10\n\r\n\x05\x04\x15\
    \x02\x01\x06\x12\x04\x9b\x02\x111\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\
    \x9b\x022:\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\x9b\x02=>\n\x0c\n\x04\
    \x04\x15\x02\x02\x12\x04\x9c\x02\x08:\n\r\n\x05\x04\x15\x02\x02\x04\x12\
    \x04\x9c\x02\x08\x10\n\r\n\x05\x04\x15\x02\x02\x06\x12\x04\x9c\x02\x11-\
    \n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\x9c\x02.5\n\r\n\x05\x04\x15\x02\
    \x02\x03\x12\x04\x9c\x0289\n\x0c\n\x02\x04\x16\x12\x06\x9f\x02\0\xa3\x02\
    \x01\n\x0b\n\x03\x04\x16\x01\x12\x04\x9f\x02\x086\n\x0c\n\x04\x04\x16\
    \x02\0\x12\x04\xa0\x02\x08\"\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\xa0\x02\
    \x08\x10\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\xa0\x02\x11\x17\n\r\n\x05\
    \x04\x16\x02\0\x01\x12\x04\xa0\x02\x18\x1d\n\r\n\x05\x04\x16\x02\0\x03\
    \x12\x04\xa0\x02\x20!\n\x0c\n\x04\x04\x16\x02\x01\x12\x04\xa1\x02\x08\"\
    \n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\xa1\x02\x08\x10\n\r\n\x05\x04\x16\
    \x02\x01\x05\x12\x04\xa1\x02\x11\x17\n\r\n\x05\x04\x16\x02\x01\x01\x12\
    \x04\xa1\x02\x18\x1d\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xa1\x02\x20!\
    \n\x0c\n\x04\x04\x16\x02\x02\x12\x04\xa2\x02\x08%\n\r\n\x05\x04\x16\x02\
    \x02\x04\x12\x04\xa2\x02\x08\x10\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\
    \xa2\x02\x11\x17\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\xa2\x02\x18\x20\n\
    \r\n\x05\x04\x16\x02\x02\x03\x12\x04\xa2\x02#$\n\x0c\n\x02\x04\x17\x12\
    \x06\xa5\x02\0\xa8\x02\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\xa5\x02\x085\
    \n\x0c\n\x04\x04\x17\x02\0\x12\x04\xa6\x02\x083\n\r\n\x05\x04\x17\x02\0\
    \x04\x12\x04\xa6\x02\x08\x10\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xa6\x02\
    \x11\x17\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xa6\x02\x18.\n\r\n\x05\x04\
    \x17\x02\0\x03\x12\x04\xa6\x0212\n\x0c\n\x04\x04\x17\x02\x01\x12\x04\xa7\
    \x02\x083\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xa7\x02\x08\x10\n\r\n\
    \x05\x04\x17\x02\x01\x05\x12\x04\xa7\x02\x11\x17\n\r\n\x05\x04\x17\x02\
    \x01\x01\x12\x04\xa7\x02\x18.\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xa7\
    \x0212\n\x0c\n\x02\x04\x18\x12\x06\xaa\x02\0\xb0\x02\x01\n\x0b\n\x03\x04\
    \x18\x01\x12\x04\xaa\x02\x08+\n\x0c\n\x04\x04\x18\x02\0\x12\x04\xab\x02\
    \x08(\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\xab\x02\x08\x10\n\r\n\x05\x04\
    \x18\x02\0\x05\x12\x04\xab\x02\x11\x17\n\r\n\x05\x04\x18\x02\0\x01\x12\
    \x04\xab\x02\x18#\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xab\x02&'\n\x0c\n\
    \x04\x04\x18\x02\x01\x12\x04\xac\x02\x08&\n\r\n\x05\x04\x18\x02\x01\x04\
    \x12\x04\xac\x02\x08\x10\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xac\x02\
    \x11\x17\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xac\x02\x18!\n\r\n\x05\
    \x04\x18\x02\x01\x03\x12\x04\xac\x02$%\n\x0c\n\x04\x04\x18\x02\x02\x12\
    \x04\xad\x02\x08(\n\r\n\x05\x04\x18\x02\x02\x04\x12\x04\xad\x02\x08\x10\
    \n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\xad\x02\x11\x17\n\r\n\x05\x04\x18\
    \x02\x02\x01\x12\x04\xad\x02\x18#\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\
    \xad\x02&'\n\x0c\n\x04\x04\x18\x02\x03\x12\x04\xae\x02\x08+\n\r\n\x05\
    \x04\x18\x02\x03\x04\x12\x04\xae\x02\x08\x10\n\r\n\x05\x04\x18\x02\x03\
    \x05\x12\x04\xae\x02\x11\x17\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\xae\
    \x02\x18&\n\r\n\x05\x04\x18\x02\x03\x03\x12\x04\xae\x02)*\n\x0c\n\x04\
    \x04\x18\x02\x04\x12\x04\xaf\x02\x08<\n\r\n\x05\x04\x18\x02\x04\x04\x12\
    \x04\xaf\x02\x08\x10\n\r\n\x05\x04\x18\x02\x04\x06\x12\x04\xaf\x02\x11&\
    \n\r\n\x05\x04\x18\x02\x04\x01\x12\x04\xaf\x02'7\n\r\n\x05\x04\x18\x02\
    \x04\x03\x12\x04\xaf\x02:;\n\x0c\n\x02\x04\x19\x12\x06\xb2\x02\0\xb4\x02\
    \x01\n\x0b\n\x03\x04\x19\x01\x12\x04\xb2\x02\x08*\n\x0c\n\x04\x04\x19\
    \x02\0\x12\x04\xb3\x02\x08#\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xb3\x02\
    \x08\x10\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xb3\x02\x11\x16\n\r\n\x05\
    \x04\x19\x02\0\x01\x12\x04\xb3\x02\x17\x1e\n\r\n\x05\x04\x19\x02\0\x03\
    \x12\x04\xb3\x02!\"\n\x0c\n\x02\x04\x1a\x12\x06\xb6\x02\0\xba\x02\x01\n\
    \x0b\n\x03\x04\x1a\x01\x12\x04\xb6\x02\x087\n\x0c\n\x04\x04\x1a\x02\0\
    \x12\x04\xb7\x02\x085\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\xb7\x02\x08\
    \x10\n\r\n\x05\x04\x1a\x02\0\x06\x12\x04\xb7\x02\x11\x20\n\r\n\x05\x04\
    \x1a\x02\0\x01\x12\x04\xb7\x02!0\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xb7\
    \x0234\n\x0c\n\x04\x04\x1a\x02\x01\x12\x04\xb8\x02\x08(\n\r\n\x05\x04\
    \x1a\x02\x01\x04\x12\x04\xb8\x02\x08\x10\n\r\n\x05\x04\x1a\x02\x01\x05\
    \x12\x04\xb8\x02\x11\x16\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\xb8\x02\
    \x17#\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xb8\x02&'\n\x0c\n\x04\x04\
    \x1a\x02\x02\x12\x04\xb9\x02\x08'\n\r\n\x05\x04\x1a\x02\x02\x04\x12\x04\
    \xb9\x02\x08\x10\n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\xb9\x02\x11\x16\n\
    \r\n\x05\x04\x1a\x02\x02\x01\x12\x04\xb9\x02\x17\"\n\r\n\x05\x04\x1a\x02\
    \x02\x03\x12\x04\xb9\x02%&\n\x0c\n\x02\x04\x1b\x12\x06\xbc\x02\0\xd1\x02\
    \x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\xbc\x02\x085\n\x0e\n\x04\x04\x1b\
    \x03\0\x12\x06\xbd\x02\x08\xc2\x02\t\n\r\n\x05\x04\x1b\x03\0\x01\x12\x04\
    \xbd\x02\x10\x14\n\x0e\n\x06\x04\x1b\x03\0\x02\0\x12\x04\xbe\x02\x10(\n\
    \x0f\n\x07\x04\x1b\x03\0\x02\0\x04\x12\x04\xbe\x02\x10\x18\n\x0f\n\x07\
    \x04\x1b\x03\0\x02\0\x05\x12\x04\xbe\x02\x19\x1e\n\x0f\n\x07\x04\x1b\x03\
    \0\x02\0\x01\x12\x04\xbe\x02\x1f#\n\x0f\n\x07\x04\x1b\x03\0\x02\0\x03\
    \x12\x04\xbe\x02&'\n\x0e\n\x06\x04\x1b\x03\0\x02\x01\x12\x04\xbf\x02\x10\
    -\n\x0f\n\x07\x04\x1b\x03\0\x02\x01\x04\x12\x04\xbf\x02\x10\x18\n\x0f\n\
    \x07\x04\x1b\x03\0\x02\x01\x05\x12\x04\xbf\x02\x19\x1e\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\x01\x01\x12\x04\xbf\x02\x1f(\n\x0f\n\x07\x04\x1b\x03\0\
    \x02\x01\x03\x12\x04\xbf\x02+,\n\x0e\n\x06\x04\x1b\x03\0\x02\x02\x12\x04\
    \xc0\x02\x10,\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\x04\x12\x04\xc0\x02\x10\
    \x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x02\x05\x12\x04\xc0\x02\x19\x1e\n\x0f\
    \n\x07\x04\x1b\x03\0\x02\x02\x01\x12\x04\xc0\x02\x1f'\n\x0f\n\x07\x04\
    \x1b\x03\0\x02\x02\x03\x12\x04\xc0\x02*+\n\x0e\n\x06\x04\x1b\x03\0\x02\
    \x03\x12\x04\xc1\x02\x10,\n\x0f\n\x07\x04\x1b\x03\0\x02\x03\x04\x12\x04\
    \xc1\x02\x10\x18\n\x0f\n\x07\x04\x1b\x03\0\x02\x03\x05\x12\x04\xc1\x02\
    \x19\x1e\n\x0f\n\x07\x04\x1b\x03\0\x02\x03\x01\x12\x04\xc1\x02\x1f'\n\
    \x0f\n\x07\x04\x1b\x03\0\x02\x03\x03\x12\x04\xc1\x02*+\n\x0c\n\x04\x04\
    \x1b\x02\0\x12\x04\xc4\x02\x08'\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xc4\
    \x02\x08\x10\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\xc4\x02\x11\x16\n\r\n\
    \x05\x04\x1b\x02\0\x01\x12\x04\xc4\x02\x17\"\n\r\n\x05\x04\x1b\x02\0\x03\
    \x12\x04\xc4\x02%&\n\x0c\n\x04\x04\x1b\x02\x01\x12\x04\xc5\x02\x088\n\r\
    \n\x05\x04\x1b\x02\x01\x04\x12\x04\xc5\x02\x08\x10\n\r\n\x05\x04\x1b\x02\
    \x01\x05\x12\x04\xc5\x02\x11\x17\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\
    \xc5\x02\x183\n\r\n\x05\x04\x1b\x02\x01\x03\x12\x04\xc5\x0267\n\x0c\n\
    \x04\x04\x1b\x02\x02\x12\x04\xc6\x02\x08\"\n\r\n\x05\x04\x1b\x02\x02\x04\
    \x12\x04\xc6\x02\x08\x10\n\r\n\x05\x04\x1b\x02\x02\x05\x12\x04\xc6\x02\
    \x11\x17\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xc6\x02\x18\x1d\n\r\n\x05\
    \x04\x1b\x02\x02\x03\x12\x04\xc6\x02\x20!\n\x0c\n\x04\x04\x1b\x02\x03\
    \x12\x04\xc7\x02\x08=\n\r\n\x05\x04\x1b\x02\x03\x04\x12\x04\xc7\x02\x08\
    \x10\n\r\n\x05\x04\x1b\x02\x03\x05\x12\x04\xc7\x02\x11\x17\n\r\n\x05\x04\
    \x1b\x02\x03\x01\x12\x04\xc7\x02\x188\n\r\n\x05\x04\x1b\x02\x03\x03\x12\
    \x04\xc7\x02;<\n\x0c\n\x04\x04\x1b\x02\x04\x12\x04\xc8\x02\x084\n\r\n\
    \x05\x04\x1b\x02\x04\x04\x12\x04\xc8\x02\x08\x10\n\r\n\x05\x04\x1b\x02\
    \x04\x06\x12\x04\xc8\x02\x11\"\n\r\n\x05\x04\x1b\x02\x04\x01\x12\x04\xc8\
    \x02#/\n\r\n\x05\x04\x1b\x02\x04\x03\x12\x04\xc8\x0223\n\x0c\n\x04\x04\
    \x1b\x02\x05\x12\x04\xc9\x02\x089\n\r\n\x05\x04\x1b\x02\x05\x04\x12\x04\
    \xc9\x02\x08\x10\n\r\n\x05\x04\x1b\x02\x05\x05\x12\x04\xc9\x02\x11\x17\n\
    \r\n\x05\x04\x1b\x02\x05\x01\x12\x04\xc9\x02\x184\n\r\n\x05\x04\x1b\x02\
    \x05\x03\x12\x04\xc9\x0278\n\x0c\n\x04\x04\x1b\x02\x06\x12\x04\xca\x02\
    \x088\n\r\n\x05\x04\x1b\x02\x06\x04\x12\x04\xca\x02\x08\x10\n\r\n\x05\
    \x04\x1b\x02\x06\x05\x12\x04\xca\x02\x11\x17\n\r\n\x05\x04\x1b\x02\x06\
    \x01\x12\x04\xca\x02\x183\n\r\n\x05\x04\x1b\x02\x06\x03\x12\x04\xca\x026\
    7\n\x0c\n\x04\x04\x1b\x02\x07\x12\x04\xcb\x02\x08;\n\r\n\x05\x04\x1b\x02\
    \x07\x04\x12\x04\xcb\x02\x08\x10\n\r\n\x05\x04\x1b\x02\x07\x05\x12\x04\
    \xcb\x02\x11\x17\n\r\n\x05\x04\x1b\x02\x07\x01\x12\x04\xcb\x02\x185\n\r\
    \n\x05\x04\x1b\x02\x07\x03\x12\x04\xcb\x028:\n\x0c\n\x04\x04\x1b\x02\x08\
    \x12\x04\xcc\x02\x08;\n\r\n\x05\x04\x1b\x02\x08\x04\x12\x04\xcc\x02\x08\
    \x10\n\r\n\x05\x04\x1b\x02\x08\x05\x12\x04\xcc\x02\x11\x17\n\r\n\x05\x04\
    \x1b\x02\x08\x01\x12\x04\xcc\x02\x185\n\r\n\x05\x04\x1b\x02\x08\x03\x12\
    \x04\xcc\x028:\n\x0c\n\x04\x04\x1b\x02\t\x12\x04\xcd\x02\x08;\n\r\n\x05\
    \x04\x1b\x02\t\x04\x12\x04\xcd\x02\x08\x10\n\r\n\x05\x04\x1b\x02\t\x06\
    \x12\x04\xcd\x02\x11\x1f\n\r\n\x05\x04\x1b\x02\t\x01\x12\x04\xcd\x02\x20\
    5\n\r\n\x05\x04\x1b\x02\t\x03\x12\x04\xcd\x028:\n\x0c\n\x04\x04\x1b\x02\
    \n\x12\x04\xce\x02\x08P\n\r\n\x05\x04\x1b\x02\n\x04\x12\x04\xce\x02\x08\
    \x10\n\r\n\x05\x04\x1b\x02\n\x06\x12\x04\xce\x02\x11D\n\r\n\x05\x04\x1b\
    \x02\n\x01\x12\x04\xce\x02EJ\n\r\n\x05\x04\x1b\x02\n\x03\x12\x04\xce\x02\
    MO\n\x0c\n\x04\x04\x1b\x02\x0b\x12\x04\xcf\x02\x08?\n\r\n\x05\x04\x1b\
    \x02\x0b\x04\x12\x04\xcf\x02\x08\x10\n\r\n\x05\x04\x1b\x02\x0b\x05\x12\
    \x04\xcf\x02\x11\x17\n\r\n\x05\x04\x1b\x02\x0b\x01\x12\x04\xcf\x02\x189\
    \n\r\n\x05\x04\x1b\x02\x0b\x03\x12\x04\xcf\x02<>\n\x0c\n\x04\x04\x1b\x02\
    \x0c\x12\x04\xd0\x02\x088\n\r\n\x05\x04\x1b\x02\x0c\x04\x12\x04\xd0\x02\
    \x08\x10\n\r\n\x05\x04\x1b\x02\x0c\x05\x12\x04\xd0\x02\x11\x17\n\r\n\x05\
    \x04\x1b\x02\x0c\x01\x12\x04\xd0\x02\x182\n\r\n\x05\x04\x1b\x02\x0c\x03\
    \x12\x04\xd0\x0257\n\x0c\n\x02\x04\x1c\x12\x06\xd3\x02\0\xe3\x02\x01\n\
    \x0b\n\x03\x04\x1c\x01\x12\x04\xd3\x02\x080\n\x0e\n\x04\x04\x1c\x03\0\
    \x12\x06\xd4\x02\x08\xd7\x02\t\n\r\n\x05\x04\x1c\x03\0\x01\x12\x04\xd4\
    \x02\x10\x15\n\x0e\n\x06\x04\x1c\x03\0\x02\0\x12\x04\xd5\x02\x10)\n\x0f\
    \n\x07\x04\x1c\x03\0\x02\0\x04\x12\x04\xd5\x02\x10\x18\n\x0f\n\x07\x04\
    \x1c\x03\0\x02\0\x05\x12\x04\xd5\x02\x19\x1e\n\x0f\n\x07\x04\x1c\x03\0\
    \x02\0\x01\x12\x04\xd5\x02\x1f$\n\x0f\n\x07\x04\x1c\x03\0\x02\0\x03\x12\
    \x04\xd5\x02'(\n\x0e\n\x06\x04\x1c\x03\0\x02\x01\x12\x04\xd6\x02\x10.\n\
    \x0f\n\x07\x04\x1c\x03\0\x02\x01\x04\x12\x04\xd6\x02\x10\x18\n\x0f\n\x07\
    \x04\x1c\x03\0\x02\x01\x05\x12\x04\xd6\x02\x19\x1e\n\x0f\n\x07\x04\x1c\
    \x03\0\x02\x01\x01\x12\x04\xd6\x02\x1f)\n\x0f\n\x07\x04\x1c\x03\0\x02\
    \x01\x03\x12\x04\xd6\x02,-\n\x0c\n\x04\x04\x1c\x02\0\x12\x04\xd9\x02\x08\
    $\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\xd9\x02\x08\x10\n\r\n\x05\x04\x1c\
    \x02\0\x05\x12\x04\xd9\x02\x11\x16\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\
    \xd9\x02\x17\x1f\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xd9\x02\"#\n\x0c\n\
    \x04\x04\x1c\x02\x01\x12\x04\xda\x02\x08*\n\r\n\x05\x04\x1c\x02\x01\x04\
    \x12\x04\xda\x02\x08\x10\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\xda\x02\
    \x11\x16\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xda\x02\x17%\n\r\n\x05\
    \x04\x1c\x02\x01\x03\x12\x04\xda\x02()\n\x0c\n\x04\x04\x1c\x02\x02\x12\
    \x04\xdb\x02\x08%\n\r\n\x05\x04\x1c\x02\x02\x04\x12\x04\xdb\x02\x08\x10\
    \n\r\n\x05\x04\x1c\x02\x02\x05\x12\x04\xdb\x02\x11\x16\n\r\n\x05\x04\x1c\
    \x02\x02\x01\x12\x04\xdb\x02\x17\x20\n\r\n\x05\x04\x1c\x02\x02\x03\x12\
    \x04\xdb\x02#$\n\x0c\n\x04\x04\x1c\x02\x03\x12\x04\xdc\x02\x08%\n\r\n\
    \x05\x04\x1c\x02\x03\x04\x12\x04\xdc\x02\x08\x10\n\r\n\x05\x04\x1c\x02\
    \x03\x05\x12\x04\xdc\x02\x11\x16\n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\
    \xdc\x02\x17\x20\n\r\n\x05\x04\x1c\x02\x03\x03\x12\x04\xdc\x02#$\n\x0c\n\
    \x04\x04\x1c\x02\x04\x12\x04\xdd\x02\x08&\n\r\n\x05\x04\x1c\x02\x04\x04\
    \x12\x04\xdd\x02\x08\x10\n\r\n\x05\x04\x1c\x02\x04\x05\x12\x04\xdd\x02\
    \x11\x16\n\r\n\x05\x04\x1c\x02\x04\x01\x12\x04\xdd\x02\x17!\n\r\n\x05\
    \x04\x1c\x02\x04\x03\x12\x04\xdd\x02$%\n\x0c\n\x04\x04\x1c\x02\x05\x12\
    \x04\xde\x02\x08(\n\r\n\x05\x04\x1c\x02\x05\x04\x12\x04\xde\x02\x08\x10\
    \n\r\n\x05\x04\x1c\x02\x05\x05\x12\x04\xde\x02\x11\x16\n\r\n\x05\x04\x1c\
    \x02\x05\x01\x12\x04\xde\x02\x17#\n\r\n\x05\x04\x1c\x02\x05\x03\x12\x04\
    \xde\x02&'\n\x0c\n\x04\x04\x1c\x02\x06\x12\x04\xdf\x02\x08)\n\r\n\x05\
    \x04\x1c\x02\x06\x04\x12\x04\xdf\x02\x08\x10\n\r\n\x05\x04\x1c\x02\x06\
    \x05\x12\x04\xdf\x02\x11\x16\n\r\n\x05\x04\x1c\x02\x06\x01\x12\x04\xdf\
    \x02\x17$\n\r\n\x05\x04\x1c\x02\x06\x03\x12\x04\xdf\x02'(\n\x0c\n\x04\
    \x04\x1c\x02\x07\x12\x04\xe0\x02\x08)\n\r\n\x05\x04\x1c\x02\x07\x04\x12\
    \x04\xe0\x02\x08\x10\n\r\n\x05\x04\x1c\x02\x07\x05\x12\x04\xe0\x02\x11\
    \x16\n\r\n\x05\x04\x1c\x02\x07\x01\x12\x04\xe0\x02\x17$\n\r\n\x05\x04\
    \x1c\x02\x07\x03\x12\x04\xe0\x02'(\n\x0c\n\x04\x04\x1c\x02\x08\x12\x04\
    \xe1\x02\x08)\n\r\n\x05\x04\x1c\x02\x08\x04\x12\x04\xe1\x02\x08\x10\n\r\
    \n\x05\x04\x1c\x02\x08\x05\x12\x04\xe1\x02\x11\x16\n\r\n\x05\x04\x1c\x02\
    \x08\x01\x12\x04\xe1\x02\x17$\n\r\n\x05\x04\x1c\x02\x08\x03\x12\x04\xe1\
    \x02'(\n\x0c\n\x04\x04\x1c\x02\t\x12\x04\xe2\x02\x08M\n\r\n\x05\x04\x1c\
    \x02\t\x04\x12\x04\xe2\x02\x08\x10\n\r\n\x05\x04\x1c\x02\t\x06\x12\x04\
    \xe2\x02\x11@\n\r\n\x05\x04\x1c\x02\t\x01\x12\x04\xe2\x02AG\n\r\n\x05\
    \x04\x1c\x02\t\x03\x12\x04\xe2\x02JL\n\x0c\n\x02\x04\x1d\x12\x06\xe5\x02\
    \0\xef\x02\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\xe5\x02\x08\x19\n\x0e\n\
    \x04\x04\x1d\x03\0\x12\x06\xe6\x02\x08\xea\x02\t\n\r\n\x05\x04\x1d\x03\0\
    \x01\x12\x04\xe6\x02\x10\x19\n\x0e\n\x06\x04\x1d\x03\0\x02\0\x12\x04\xe7\
    \x02\x105\n\x0f\n\x07\x04\x1d\x03\0\x02\0\x04\x12\x04\xe7\x02\x10\x18\n\
    \x0f\n\x07\x04\x1d\x03\0\x02\0\x05\x12\x04\xe7\x02\x19\x1e\n\x0f\n\x07\
    \x04\x1d\x03\0\x02\0\x01\x12\x04\xe7\x02\x1f0\n\x0f\n\x07\x04\x1d\x03\0\
    \x02\0\x03\x12\x04\xe7\x0234\n\x0e\n\x06\x04\x1d\x03\0\x02\x01\x12\x04\
    \xe8\x02\x103\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x04\x12\x04\xe8\x02\x10\
    \x18\n\x0f\n\x07\x04\x1d\x03\0\x02\x01\x05\x12\x04\xe8\x02\x19\x1f\n\x0f\
    \n\x07\x04\x1d\x03\0\x02\x01\x01\x12\x04\xe8\x02\x20.\n\x0f\n\x07\x04\
    \x1d\x03\0\x02\x01\x03\x12\x04\xe8\x0212\n\x0e\n\x06\x04\x1d\x03\0\x02\
    \x02\x12\x04\xe9\x02\x105\n\x0f\n\x07\x04\x1d\x03\0\x02\x02\x04\x12\x04\
    \xe9\x02\x10\x18\n\x0f\n\x07\x04\x1d\x03\0\x02\x02\x05\x12\x04\xe9\x02\
    \x19\x1f\n\x0f\n\x07\x04\x1d\x03\0\x02\x02\x01\x12\x04\xe9\x02\x200\n\
    \x0f\n\x07\x04\x1d\x03\0\x02\x02\x03\x12\x04\xe9\x0234\n\x0c\n\x04\x04\
    \x1d\x02\0\x12\x04\xec\x02\x08+\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\xec\
    \x02\x08\x10\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xec\x02\x11\x16\n\r\n\
    \x05\x04\x1d\x02\0\x01\x12\x04\xec\x02\x17&\n\r\n\x05\x04\x1d\x02\0\x03\
    \x12\x04\xec\x02)*\n\x0c\n\x04\x04\x1d\x02\x01\x12\x04\xed\x02\x08E\n\r\
    \n\x05\x04\x1d\x02\x01\x04\x12\x04\xed\x02\x08\x10\n\r\n\x05\x04\x1d\x02\
    \x01\x06\x12\x04\xed\x02\x11:\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xed\
    \x02;@\n\r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xed\x02CD\n\x0c\n\x04\x04\
    \x1d\x02\x02\x12\x04\xee\x02\x088\n\r\n\x05\x04\x1d\x02\x02\x04\x12\x04\
    \xee\x02\x08\x10\n\r\n\x05\x04\x1d\x02\x02\x06\x12\x04\xee\x02\x11-\n\r\
    \n\x05\x04\x1d\x02\x02\x01\x12\x04\xee\x02.3\n\r\n\x05\x04\x1d\x02\x02\
    \x03\x12\x04\xee\x0267\n\x0c\n\x02\x04\x1e\x12\x06\xf1\x02\0\x81\x03\x01\
    \n\x0b\n\x03\x04\x1e\x01\x12\x04\xf1\x02\x086\n\x0c\n\x04\x04\x1e\x02\0\
    \x12\x04\xf2\x02\x08(\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xf2\x02\x08\
    \x10\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xf2\x02\x11\x17\n\r\n\x05\x04\
    \x1e\x02\0\x01\x12\x04\xf2\x02\x18#\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\
    \xf2\x02&'\n\x0c\n\x04\x04\x1e\x02\x01\x12\x04\xf3\x02\x08&\n\r\n\x05\
    \x04\x1e\x02\x01\x04\x12\x04\xf3\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x01\
    \x05\x12\x04\xf3\x02\x11\x17\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xf3\
    \x02\x18!\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xf3\x02$%\n\x0c\n\x04\
    \x04\x1e\x02\x02\x12\x04\xf4\x02\x08%\n\r\n\x05\x04\x1e\x02\x02\x04\x12\
    \x04\xf4\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x02\x05\x12\x04\xf4\x02\x11\
    \x17\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\xf4\x02\x18\x20\n\r\n\x05\x04\
    \x1e\x02\x02\x03\x12\x04\xf4\x02#$\n\x0c\n\x04\x04\x1e\x02\x03\x12\x04\
    \xf5\x02\x08+\n\r\n\x05\x04\x1e\x02\x03\x04\x12\x04\xf5\x02\x08\x10\n\r\
    \n\x05\x04\x1e\x02\x03\x05\x12\x04\xf5\x02\x11\x17\n\r\n\x05\x04\x1e\x02\
    \x03\x01\x12\x04\xf5\x02\x18&\n\r\n\x05\x04\x1e\x02\x03\x03\x12\x04\xf5\
    \x02)*\n\x0c\n\x04\x04\x1e\x02\x04\x12\x04\xf6\x02\x081\n\r\n\x05\x04\
    \x1e\x02\x04\x04\x12\x04\xf6\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x04\x06\
    \x12\x04\xf6\x02\x11#\n\r\n\x05\x04\x1e\x02\x04\x01\x12\x04\xf6\x02$,\n\
    \r\n\x05\x04\x1e\x02\x04\x03\x12\x04\xf6\x02/0\n\x0c\n\x04\x04\x1e\x02\
    \x05\x12\x04\xf7\x02\x08+\n\r\n\x05\x04\x1e\x02\x05\x04\x12\x04\xf7\x02\
    \x08\x10\n\r\n\x05\x04\x1e\x02\x05\x05\x12\x04\xf7\x02\x11\x17\n\r\n\x05\
    \x04\x1e\x02\x05\x01\x12\x04\xf7\x02\x18&\n\r\n\x05\x04\x1e\x02\x05\x03\
    \x12\x04\xf7\x02)*\n\x0c\n\x04\x04\x1e\x02\x06\x12\x04\xf8\x02\x08/\n\r\
    \n\x05\x04\x1e\x02\x06\x04\x12\x04\xf8\x02\x08\x10\n\r\n\x05\x04\x1e\x02\
    \x06\x05\x12\x04\xf8\x02\x11\x17\n\r\n\x05\x04\x1e\x02\x06\x01\x12\x04\
    \xf8\x02\x18*\n\r\n\x05\x04\x1e\x02\x06\x03\x12\x04\xf8\x02-.\n\x0c\n\
    \x04\x04\x1e\x02\x07\x12\x04\xf9\x02\x08&\n\r\n\x05\x04\x1e\x02\x07\x04\
    \x12\x04\xf9\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x07\x05\x12\x04\xf9\x02\
    \x11\x17\n\r\n\x05\x04\x1e\x02\x07\x01\x12\x04\xf9\x02\x18!\n\r\n\x05\
    \x04\x1e\x02\x07\x03\x12\x04\xf9\x02$%\n\x0c\n\x04\x04\x1e\x02\x08\x12\
    \x04\xfa\x02\x08.\n\r\n\x05\x04\x1e\x02\x08\x04\x12\x04\xfa\x02\x08\x10\
    \n\r\n\x05\x04\x1e\x02\x08\x06\x12\x04\xfa\x02\x11\x1f\n\r\n\x05\x04\x1e\
    \x02\x08\x01\x12\x04\xfa\x02\x20)\n\r\n\x05\x04\x1e\x02\x08\x03\x12\x04\
    \xfa\x02,-\n\x0c\n\x04\x04\x1e\x02\t\x12\x04\xfb\x02\x08/\n\r\n\x05\x04\
    \x1e\x02\t\x04\x12\x04\xfb\x02\x08\x10\n\r\n\x05\x04\x1e\x02\t\x05\x12\
    \x04\xfb\x02\x11\x17\n\r\n\x05\x04\x1e\x02\t\x01\x12\x04\xfb\x02\x18)\n\
    \r\n\x05\x04\x1e\x02\t\x03\x12\x04\xfb\x02,.\n\x0c\n\x04\x04\x1e\x02\n\
    \x12\x04\xfc\x02\x088\n\r\n\x05\x04\x1e\x02\n\x04\x12\x04\xfc\x02\x08\
    \x10\n\r\n\x05\x04\x1e\x02\n\x06\x12\x04\xfc\x02\x11!\n\r\n\x05\x04\x1e\
    \x02\n\x01\x12\x04\xfc\x02\"2\n\r\n\x05\x04\x1e\x02\n\x03\x12\x04\xfc\
    \x0257\n\x0c\n\x04\x04\x1e\x02\x0b\x12\x04\xfd\x02\x087\n\r\n\x05\x04\
    \x1e\x02\x0b\x04\x12\x04\xfd\x02\x08\x10\n\r\n\x05\x04\x1e\x02\x0b\x06\
    \x12\x04\xfd\x02\x11\x20\n\r\n\x05\x04\x1e\x02\x0b\x01\x12\x04\xfd\x02!1\
    \n\r\n\x05\x04\x1e\x02\x0b\x03\x12\x04\xfd\x0246\n\x0c\n\x04\x04\x1e\x02\
    \x0c\x12\x04\xfe\x02\x08<\n\r\n\x05\x04\x1e\x02\x0c\x04\x12\x04\xfe\x02\
    \x08\x10\n\r\n\x05\x04\x1e\x02\x0c\x05\x12\x04\xfe\x02\x11\x17\n\r\n\x05\
    \x04\x1e\x02\x0c\x01\x12\x04\xfe\x02\x186\n\r\n\x05\x04\x1e\x02\x0c\x03\
    \x12\x04\xfe\x029;\n\x0c\n\x04\x04\x1e\x02\r\x12\x04\xff\x02\x08.\n\r\n\
    \x05\x04\x1e\x02\r\x04\x12\x04\xff\x02\x08\x10\n\r\n\x05\x04\x1e\x02\r\
    \x05\x12\x04\xff\x02\x11\x17\n\r\n\x05\x04\x1e\x02\r\x01\x12\x04\xff\x02\
    \x18(\n\r\n\x05\x04\x1e\x02\r\x03\x12\x04\xff\x02+-\n\x0c\n\x04\x04\x1e\
    \x02\x0e\x12\x04\x80\x03\x088\n\r\n\x05\x04\x1e\x02\x0e\x04\x12\x04\x80\
    \x03\x08\x10\n\r\n\x05\x04\x1e\x02\x0e\x06\x12\x04\x80\x03\x11#\n\r\n\
    \x05\x04\x1e\x02\x0e\x01\x12\x04\x80\x03$2\n\r\n\x05\x04\x1e\x02\x0e\x03\
    \x12\x04\x80\x0357\n\x0c\n\x02\x04\x1f\x12\x06\x83\x03\0\x91\x03\x01\n\
    \x0b\n\x03\x04\x1f\x01\x12\x04\x83\x03\x08?\n\x0c\n\x04\x04\x1f\x02\0\
    \x12\x04\x84\x03\x08*\n\r\n\x05\x04\x1f\x02\0\x04\x12\x04\x84\x03\x08\
    \x10\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\x84\x03\x11\x17\n\r\n\x05\x04\
    \x1f\x02\0\x01\x12\x04\x84\x03\x18%\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\
    \x84\x03()\n\x0c\n\x04\x04\x1f\x02\x01\x12\x04\x85\x03\x08Q\n\r\n\x05\
    \x04\x1f\x02\x01\x04\x12\x04\x85\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x01\
    \x06\x12\x04\x85\x03\x11@\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\x85\x03A\
    L\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\x85\x03OP\n\x0c\n\x04\x04\x1f\
    \x02\x02\x12\x04\x86\x03\x08\x20\n\r\n\x05\x04\x1f\x02\x02\x04\x12\x04\
    \x86\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x02\x05\x12\x04\x86\x03\x11\x17\n\
    \r\n\x05\x04\x1f\x02\x02\x01\x12\x04\x86\x03\x18\x1b\n\r\n\x05\x04\x1f\
    \x02\x02\x03\x12\x04\x86\x03\x1e\x1f\n\x0c\n\x04\x04\x1f\x02\x03\x12\x04\
    \x87\x03\x080\n\r\n\x05\x04\x1f\x02\x03\x04\x12\x04\x87\x03\x08\x10\n\r\
    \n\x05\x04\x1f\x02\x03\x05\x12\x04\x87\x03\x11\x17\n\r\n\x05\x04\x1f\x02\
    \x03\x01\x12\x04\x87\x03\x18+\n\r\n\x05\x04\x1f\x02\x03\x03\x12\x04\x87\
    \x03./\n\x0c\n\x04\x04\x1f\x02\x04\x12\x04\x88\x03\x08+\n\r\n\x05\x04\
    \x1f\x02\x04\x04\x12\x04\x88\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x04\x05\
    \x12\x04\x88\x03\x11\x17\n\r\n\x05\x04\x1f\x02\x04\x01\x12\x04\x88\x03\
    \x18&\n\r\n\x05\x04\x1f\x02\x04\x03\x12\x04\x88\x03)*\n\x0c\n\x04\x04\
    \x1f\x02\x05\x12\x04\x89\x03\x08-\n\r\n\x05\x04\x1f\x02\x05\x04\x12\x04\
    \x89\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x05\x06\x12\x04\x89\x03\x11\x20\n\
    \r\n\x05\x04\x1f\x02\x05\x01\x12\x04\x89\x03!(\n\r\n\x05\x04\x1f\x02\x05\
    \x03\x12\x04\x89\x03+,\n\x0c\n\x04\x04\x1f\x02\x06\x12\x04\x8a\x03\x083\
    \n\r\n\x05\x04\x1f\x02\x06\x04\x12\x04\x8a\x03\x08\x10\n\r\n\x05\x04\x1f\
    \x02\x06\x05\x12\x04\x8a\x03\x11\x17\n\r\n\x05\x04\x1f\x02\x06\x01\x12\
    \x04\x8a\x03\x18.\n\r\n\x05\x04\x1f\x02\x06\x03\x12\x04\x8a\x0312\n\x0c\
    \n\x04\x04\x1f\x02\x07\x12\x04\x8b\x03\x081\n\r\n\x05\x04\x1f\x02\x07\
    \x04\x12\x04\x8b\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x07\x05\x12\x04\x8b\
    \x03\x11\x17\n\r\n\x05\x04\x1f\x02\x07\x01\x12\x04\x8b\x03\x18,\n\r\n\
    \x05\x04\x1f\x02\x07\x03\x12\x04\x8b\x03/0\n\x0c\n\x04\x04\x1f\x02\x08\
    \x12\x04\x8c\x03\x085\n\r\n\x05\x04\x1f\x02\x08\x04\x12\x04\x8c\x03\x08\
    \x10\n\r\n\x05\x04\x1f\x02\x08\x05\x12\x04\x8c\x03\x11\x17\n\r\n\x05\x04\
    \x1f\x02\x08\x01\x12\x04\x8c\x03\x180\n\r\n\x05\x04\x1f\x02\x08\x03\x12\
    \x04\x8c\x0334\n\x0c\n\x04\x04\x1f\x02\t\x12\x04\x8d\x03\x084\n\r\n\x05\
    \x04\x1f\x02\t\x04\x12\x04\x8d\x03\x08\x10\n\r\n\x05\x04\x1f\x02\t\x05\
    \x12\x04\x8d\x03\x11\x17\n\r\n\x05\x04\x1f\x02\t\x01\x12\x04\x8d\x03\x18\
    .\n\r\n\x05\x04\x1f\x02\t\x03\x12\x04\x8d\x0313\n\x0c\n\x04\x04\x1f\x02\
    \n\x12\x04\x8e\x03\x089\n\r\n\x05\x04\x1f\x02\n\x04\x12\x04\x8e\x03\x08\
    \x10\n\r\n\x05\x04\x1f\x02\n\x05\x12\x04\x8e\x03\x11\x17\n\r\n\x05\x04\
    \x1f\x02\n\x01\x12\x04\x8e\x03\x183\n\r\n\x05\x04\x1f\x02\n\x03\x12\x04\
    \x8e\x0368\n\x0c\n\x04\x04\x1f\x02\x0b\x12\x04\x8f\x03\x08.\n\r\n\x05\
    \x04\x1f\x02\x0b\x04\x12\x04\x8f\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x0b\
    \x05\x12\x04\x8f\x03\x11\x17\n\r\n\x05\x04\x1f\x02\x0b\x01\x12\x04\x8f\
    \x03\x18(\n\r\n\x05\x04\x1f\x02\x0b\x03\x12\x04\x8f\x03+-\n\x0c\n\x04\
    \x04\x1f\x02\x0c\x12\x04\x90\x03\x08,\n\r\n\x05\x04\x1f\x02\x0c\x04\x12\
    \x04\x90\x03\x08\x10\n\r\n\x05\x04\x1f\x02\x0c\x05\x12\x04\x90\x03\x11\
    \x17\n\r\n\x05\x04\x1f\x02\x0c\x01\x12\x04\x90\x03\x18&\n\r\n\x05\x04\
    \x1f\x02\x0c\x03\x12\x04\x90\x03)+\n\x0c\n\x02\x04\x20\x12\x06\x93\x03\0\
    \x99\x03\x01\n\x0b\n\x03\x04\x20\x01\x12\x04\x93\x03\x086\n\x0c\n\x04\
    \x04\x20\x02\0\x12\x04\x94\x03\x08%\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\
    \x94\x03\x08\x10\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\x94\x03\x11\x17\n\r\
    \n\x05\x04\x20\x02\0\x01\x12\x04\x94\x03\x18\x20\n\r\n\x05\x04\x20\x02\0\
    \x03\x12\x04\x94\x03#$\n\x0c\n\x04\x04\x20\x02\x01\x12\x04\x95\x03\x08*\
    \n\r\n\x05\x04\x20\x02\x01\x04\x12\x04\x95\x03\x08\x10\n\r\n\x05\x04\x20\
    \x02\x01\x05\x12\x04\x95\x03\x11\x17\n\r\n\x05\x04\x20\x02\x01\x01\x12\
    \x04\x95\x03\x18%\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\x95\x03()\n\x0c\
    \n\x04\x04\x20\x02\x02\x12\x04\x96\x03\x08Q\n\r\n\x05\x04\x20\x02\x02\
    \x04\x12\x04\x96\x03\x08\x10\n\r\n\x05\x04\x20\x02\x02\x06\x12\x04\x96\
    \x03\x11@\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\x96\x03AL\n\r\n\x05\x04\
    \x20\x02\x02\x03\x12\x04\x96\x03OP\n\x0c\n\x04\x04\x20\x02\x03\x12\x04\
    \x97\x03\x08\x20\n\r\n\x05\x04\x20\x02\x03\x04\x12\x04\x97\x03\x08\x10\n\
    \r\n\x05\x04\x20\x02\x03\x05\x12\x04\x97\x03\x11\x17\n\r\n\x05\x04\x20\
    \x02\x03\x01\x12\x04\x97\x03\x18\x1b\n\r\n\x05\x04\x20\x02\x03\x03\x12\
    \x04\x97\x03\x1e\x1f\n\x0c\n\x04\x04\x20\x02\x04\x12\x04\x98\x03\x08+\n\
    \r\n\x05\x04\x20\x02\x04\x04\x12\x04\x98\x03\x08\x10\n\r\n\x05\x04\x20\
    \x02\x04\x05\x12\x04\x98\x03\x11\x17\n\r\n\x05\x04\x20\x02\x04\x01\x12\
    \x04\x98\x03\x18&\n\r\n\x05\x04\x20\x02\x04\x03\x12\x04\x98\x03)*\n\x0c\
    \n\x02\x04!\x12\x06\x9b\x03\0\xba\x03\x01\n\x0b\n\x03\x04!\x01\x12\x04\
    \x9b\x03\x086\n\x0e\n\x04\x04!\x03\0\x12\x06\x9c\x03\x08\x9e\x03\t\n\r\n\
    \x05\x04!\x03\0\x01\x12\x04\x9c\x03\x10\x18\n\x0e\n\x06\x04!\x03\0\x02\0\
    \x12\x04\x9d\x03\x100\n\x0f\n\x07\x04!\x03\0\x02\0\x04\x12\x04\x9d\x03\
    \x10\x18\n\x0f\n\x07\x04!\x03\0\x02\0\x05\x12\x04\x9d\x03\x19\x1f\n\x0f\
    \n\x07\x04!\x03\0\x02\0\x01\x12\x04\x9d\x03\x20+\n\x0f\n\x07\x04!\x03\0\
    \x02\0\x03\x12\x04\x9d\x03./\n\x0c\n\x04\x04!\x02\0\x12\x04\xa0\x03\x08*\
    \n\r\n\x05\x04!\x02\0\x04\x12\x04\xa0\x03\x08\x10\n\r\n\x05\x04!\x02\0\
    \x05\x12\x04\xa0\x03\x11\x17\n\r\n\x05\x04!\x02\0\x01\x12\x04\xa0\x03\
    \x18%\n\r\n\x05\x04!\x02\0\x03\x12\x04\xa0\x03()\n\x0c\n\x04\x04!\x02\
    \x01\x12\x04\xa1\x03\x08Q\n\r\n\x05\x04!\x02\x01\x04\x12\x04\xa1\x03\x08\
    \x10\n\r\n\x05\x04!\x02\x01\x06\x12\x04\xa1\x03\x11@\n\r\n\x05\x04!\x02\
    \x01\x01\x12\x04\xa1\x03AL\n\r\n\x05\x04!\x02\x01\x03\x12\x04\xa1\x03OP\
    \n\x0c\n\x04\x04!\x02\x02\x12\x04\xa2\x03\x08\x20\n\r\n\x05\x04!\x02\x02\
    \x04\x12\x04\xa2\x03\x08\x10\n\r\n\x05\x04!\x02\x02\x05\x12\x04\xa2\x03\
    \x11\x17\n\r\n\x05\x04!\x02\x02\x01\x12\x04\xa2\x03\x18\x1b\n\r\n\x05\
    \x04!\x02\x02\x03\x12\x04\xa2\x03\x1e\x1f\n\x0c\n\x04\x04!\x02\x03\x12\
    \x04\xa3\x03\x08!\n\r\n\x05\x04!\x02\x03\x04\x12\x04\xa3\x03\x08\x10\n\r\
    \n\x05\x04!\x02\x03\x05\x12\x04\xa3\x03\x11\x16\n\r\n\x05\x04!\x02\x03\
    \x01\x12\x04\xa3\x03\x17\x1c\n\r\n\x05\x04!\x02\x03\x03\x12\x04\xa3\x03\
    \x1f\x20\n\x0c\n\x04\x04!\x02\x04\x12\x04\xa4\x03\x08!\n\r\n\x05\x04!\
    \x02\x04\x04\x12\x04\xa4\x03\x08\x10\n\r\n\x05\x04!\x02\x04\x05\x12\x04\
    \xa4\x03\x11\x16\n\r\n\x05\x04!\x02\x04\x01\x12\x04\xa4\x03\x17\x1c\n\r\
    \n\x05\x04!\x02\x04\x03\x12\x04\xa4\x03\x1f\x20\n\x0c\n\x04\x04!\x02\x05\
    \x12\x04\xa5\x03\x08#\n\r\n\x05\x04!\x02\x05\x04\x12\x04\xa5\x03\x08\x10\
    \n\r\n\x05\x04!\x02\x05\x05\x12\x04\xa5\x03\x11\x16\n\r\n\x05\x04!\x02\
    \x05\x01\x12\x04\xa5\x03\x17\x1e\n\r\n\x05\x04!\x02\x05\x03\x12\x04\xa5\
    \x03!\"\n\x0c\n\x04\x04!\x02\x06\x12\x04\xa6\x03\x08\"\n\r\n\x05\x04!\
    \x02\x06\x04\x12\x04\xa6\x03\x08\x10\n\r\n\x05\x04!\x02\x06\x05\x12\x04\
    \xa6\x03\x11\x16\n\r\n\x05\x04!\x02\x06\x01\x12\x04\xa6\x03\x17\x1d\n\r\
    \n\x05\x04!\x02\x06\x03\x12\x04\xa6\x03\x20!\n\x0c\n\x04\x04!\x02\x07\
    \x12\x04\xa7\x03\x08\"\n\r\n\x05\x04!\x02\x07\x04\x12\x04\xa7\x03\x08\
    \x10\n\r\n\x05\x04!\x02\x07\x05\x12\x04\xa7\x03\x11\x16\n\r\n\x05\x04!\
    \x02\x07\x01\x12\x04\xa7\x03\x17\x1d\n\r\n\x05\x04!\x02\x07\x03\x12\x04\
    \xa7\x03\x20!\n\x0c\n\x04\x04!\x02\x08\x12\x04\xa8\x03\x08!\n\r\n\x05\
    \x04!\x02\x08\x04\x12\x04\xa8\x03\x08\x10\n\r\n\x05\x04!\x02\x08\x05\x12\
    \x04\xa8\x03\x11\x16\n\r\n\x05\x04!\x02\x08\x01\x12\x04\xa8\x03\x17\x1c\
    \n\r\n\x05\x04!\x02\x08\x03\x12\x04\xa8\x03\x1f\x20\n\x0c\n\x04\x04!\x02\
    \t\x12\x04\xa9\x03\x08)\n\r\n\x05\x04!\x02\t\x04\x12\x04\xa9\x03\x08\x10\
    \n\r\n\x05\x04!\x02\t\x05\x12\x04\xa9\x03\x11\x16\n\r\n\x05\x04!\x02\t\
    \x01\x12\x04\xa9\x03\x17#\n\r\n\x05\x04!\x02\t\x03\x12\x04\xa9\x03&(\n\
    \x0c\n\x04\x04!\x02\n\x12\x04\xaa\x03\x08)\n\r\n\x05\x04!\x02\n\x04\x12\
    \x04\xaa\x03\x08\x10\n\r\n\x05\x04!\x02\n\x05\x12\x04\xaa\x03\x11\x16\n\
    \r\n\x05\x04!\x02\n\x01\x12\x04\xaa\x03\x17#\n\r\n\x05\x04!\x02\n\x03\
    \x12\x04\xaa\x03&(\n\x0c\n\x04\x04!\x02\x0b\x12\x04\xab\x03\x08(\n\r\n\
    \x05\x04!\x02\x0b\x04\x12\x04\xab\x03\x08\x10\n\r\n\x05\x04!\x02\x0b\x05\
    \x12\x04\xab\x03\x11\x16\n\r\n\x05\x04!\x02\x0b\x01\x12\x04\xab\x03\x17\
    \"\n\r\n\x05\x04!\x02\x0b\x03\x12\x04\xab\x03%'\n\x0c\n\x04\x04!\x02\x0c\
    \x12\x04\xac\x03\x08N\n\r\n\x05\x04!\x02\x0c\x04\x12\x04\xac\x03\x08\x10\
    \n\r\n\x05\x04!\x02\x0c\x06\x12\x04\xac\x03\x11@\n\r\n\x05\x04!\x02\x0c\
    \x01\x12\x04\xac\x03AH\n\r\n\x05\x04!\x02\x0c\x03\x12\x04\xac\x03KM\n\
    \x0c\n\x04\x04!\x02\r\x12\x04\xad\x03\x08.\n\r\n\x05\x04!\x02\r\x04\x12\
    \x04\xad\x03\x08\x10\n\r\n\x05\x04!\x02\r\x05\x12\x04\xad\x03\x11\x16\n\
    \r\n\x05\x04!\x02\r\x01\x12\x04\xad\x03\x17(\n\r\n\x05\x04!\x02\r\x03\
    \x12\x04\xad\x03+-\n\x0c\n\x04\x04!\x02\x0e\x12\x04\xae\x03\x08+\n\r\n\
    \x05\x04!\x02\x0e\x04\x12\x04\xae\x03\x08\x10\n\r\n\x05\x04!\x02\x0e\x05\
    \x12\x04\xae\x03\x11\x16\n\r\n\x05\x04!\x02\x0e\x01\x12\x04\xae\x03\x17%\
    \n\r\n\x05\x04!\x02\x0e\x03\x12\x04\xae\x03(*\n\x0c\n\x04\x04!\x02\x0f\
    \x12\x04\xaf\x03\x08(\n\r\n\x05\x04!\x02\x0f\x04\x12\x04\xaf\x03\x08\x10\
    \n\r\n\x05\x04!\x02\x0f\x05\x12\x04\xaf\x03\x11\x16\n\r\n\x05\x04!\x02\
    \x0f\x01\x12\x04\xaf\x03\x17\"\n\r\n\x05\x04!\x02\x0f\x03\x12\x04\xaf\
    \x03%'\n\x0c\n\x04\x04!\x02\x10\x12\x04\xb0\x03\x08,\n\r\n\x05\x04!\x02\
    \x10\x04\x12\x04\xb0\x03\x08\x10\n\r\n\x05\x04!\x02\x10\x05\x12\x04\xb0\
    \x03\x11\x16\n\r\n\x05\x04!\x02\x10\x01\x12\x04\xb0\x03\x17&\n\r\n\x05\
    \x04!\x02\x10\x03\x12\x04\xb0\x03)+\n\x0c\n\x04\x04!\x02\x11\x12\x04\xb1\
    \x03\x08&\n\r\n\x05\x04!\x02\x11\x04\x12\x04\xb1\x03\x08\x10\n\r\n\x05\
    \x04!\x02\x11\x05\x12\x04\xb1\x03\x11\x16\n\r\n\x05\x04!\x02\x11\x01\x12\
    \x04\xb1\x03\x17\x20\n\r\n\x05\x04!\x02\x11\x03\x12\x04\xb1\x03#%\n\x0c\
    \n\x04\x04!\x02\x12\x12\x04\xb2\x03\x08&\n\r\n\x05\x04!\x02\x12\x04\x12\
    \x04\xb2\x03\x08\x10\n\r\n\x05\x04!\x02\x12\x05\x12\x04\xb2\x03\x11\x16\
    \n\r\n\x05\x04!\x02\x12\x01\x12\x04\xb2\x03\x17\x20\n\r\n\x05\x04!\x02\
    \x12\x03\x12\x04\xb2\x03#%\n\x0c\n\x04\x04!\x02\x13\x12\x04\xb3\x03\x08&\
    \n\r\n\x05\x04!\x02\x13\x04\x12\x04\xb3\x03\x08\x10\n\r\n\x05\x04!\x02\
    \x13\x05\x12\x04\xb3\x03\x11\x16\n\r\n\x05\x04!\x02\x13\x01\x12\x04\xb3\
    \x03\x17\x20\n\r\n\x05\x04!\x02\x13\x03\x12\x04\xb3\x03#%\n\x0c\n\x04\
    \x04!\x02\x14\x12\x04\xb4\x03\x08!\n\r\n\x05\x04!\x02\x14\x04\x12\x04\
    \xb4\x03\x08\x10\n\r\n\x05\x04!\x02\x14\x05\x12\x04\xb4\x03\x11\x16\n\r\
    \n\x05\x04!\x02\x14\x01\x12\x04\xb4\x03\x17\x1b\n\r\n\x05\x04!\x02\x14\
    \x03\x12\x04\xb4\x03\x1e\x20\n\x0c\n\x04\x04!\x02\x15\x12\x04\xb5\x03\
    \x08.\n\r\n\x05\x04!\x02\x15\x04\x12\x04\xb5\x03\x08\x10\n\r\n\x05\x04!\
    \x02\x15\x05\x12\x04\xb5\x03\x11\x17\n\r\n\x05\x04!\x02\x15\x01\x12\x04\
    \xb5\x03\x18(\n\r\n\x05\x04!\x02\x15\x03\x12\x04\xb5\x03+-\n\x0c\n\x04\
    \x04!\x02\x16\x12\x04\xb6\x03\x081\n\r\n\x05\x04!\x02\x16\x04\x12\x04\
    \xb6\x03\x08\x10\n\r\n\x05\x04!\x02\x16\x05\x12\x04\xb6\x03\x11\x17\n\r\
    \n\x05\x04!\x02\x16\x01\x12\x04\xb6\x03\x18+\n\r\n\x05\x04!\x02\x16\x03\
    \x12\x04\xb6\x03.0\n\x0c\n\x04\x04!\x02\x17\x12\x04\xb7\x03\x082\n\r\n\
    \x05\x04!\x02\x17\x04\x12\x04\xb7\x03\x08\x10\n\r\n\x05\x04!\x02\x17\x05\
    \x12\x04\xb7\x03\x11\x17\n\r\n\x05\x04!\x02\x17\x01\x12\x04\xb7\x03\x18,\
    \n\r\n\x05\x04!\x02\x17\x03\x12\x04\xb7\x03/1\n\x0c\n\x04\x04!\x02\x18\
    \x12\x04\xb8\x03\x08,\n\r\n\x05\x04!\x02\x18\x04\x12\x04\xb8\x03\x08\x10\
    \n\r\n\x05\x04!\x02\x18\x05\x12\x04\xb8\x03\x11\x16\n\r\n\x05\x04!\x02\
    \x18\x01\x12\x04\xb8\x03\x17&\n\r\n\x05\x04!\x02\x18\x03\x12\x04\xb8\x03\
    )+\n\x0c\n\x04\x04!\x02\x19\x12\x04\xb9\x03\x08Y\n\r\n\x05\x04!\x02\x19\
    \x04\x12\x04\xb9\x03\x08\x10\n\r\n\x05\x04!\x02\x19\x06\x12\x04\xb9\x03\
    \x11I\n\r\n\x05\x04!\x02\x19\x01\x12\x04\xb9\x03JS\n\r\n\x05\x04!\x02\
    \x19\x03\x12\x04\xb9\x03VX\n\x0c\n\x02\x04\"\x12\x06\xbc\x03\0\xc5\x03\
    \x01\n\x0b\n\x03\x04\"\x01\x12\x04\xbc\x03\x084\n\x0c\n\x04\x04\"\x02\0\
    \x12\x04\xbd\x03\x08K\n\r\n\x05\x04\"\x02\0\x04\x12\x04\xbd\x03\x08\x10\
    \n\r\n\x05\x04\"\x02\0\x06\x12\x04\xbd\x03\x11@\n\r\n\x05\x04\"\x02\0\
    \x01\x12\x04\xbd\x03AF\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xbd\x03IJ\n\x0c\
    \n\x04\x04\"\x02\x01\x12\x04\xbe\x03\x08M\n\r\n\x05\x04\"\x02\x01\x04\
    \x12\x04\xbe\x03\x08\x10\n\r\n\x05\x04\"\x02\x01\x06\x12\x04\xbe\x03\x11\
    @\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\xbe\x03AH\n\r\n\x05\x04\"\x02\x01\
    \x03\x12\x04\xbe\x03KL\n\x0c\n\x04\x04\"\x02\x02\x12\x04\xbf\x03\x08$\n\
    \r\n\x05\x04\"\x02\x02\x04\x12\x04\xbf\x03\x08\x10\n\r\n\x05\x04\"\x02\
    \x02\x05\x12\x04\xbf\x03\x11\x17\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\xbf\
    \x03\x18\x1f\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\xbf\x03\"#\n\x0c\n\x04\
    \x04\"\x02\x03\x12\x04\xc0\x03\x08)\n\r\n\x05\x04\"\x02\x03\x04\x12\x04\
    \xc0\x03\x08\x10\n\r\n\x05\x04\"\x02\x03\x05\x12\x04\xc0\x03\x11\x17\n\r\
    \n\x05\x04\"\x02\x03\x01\x12\x04\xc0\x03\x18$\n\r\n\x05\x04\"\x02\x03\
    \x03\x12\x04\xc0\x03'(\n\x0c\n\x04\x04\"\x02\x04\x12\x04\xc1\x03\x08.\n\
    \r\n\x05\x04\"\x02\x04\x04\x12\x04\xc1\x03\x08\x10\n\r\n\x05\x04\"\x02\
    \x04\x05\x12\x04\xc1\x03\x11\x17\n\r\n\x05\x04\"\x02\x04\x01\x12\x04\xc1\
    \x03\x18)\n\r\n\x05\x04\"\x02\x04\x03\x12\x04\xc1\x03,-\n\x0c\n\x04\x04\
    \"\x02\x05\x12\x04\xc2\x03\x08(\n\r\n\x05\x04\"\x02\x05\x04\x12\x04\xc2\
    \x03\x08\x10\n\r\n\x05\x04\"\x02\x05\x05\x12\x04\xc2\x03\x11\x15\n\r\n\
    \x05\x04\"\x02\x05\x01\x12\x04\xc2\x03\x16#\n\r\n\x05\x04\"\x02\x05\x03\
    \x12\x04\xc2\x03&'\n\x0c\n\x04\x04\"\x02\x06\x12\x04\xc3\x03\x08H\n\r\n\
    \x05\x04\"\x02\x06\x04\x12\x04\xc3\x03\x08\x10\n\r\n\x05\x04\"\x02\x06\
    \x06\x12\x04\xc3\x03\x11.\n\r\n\x05\x04\"\x02\x06\x01\x12\x04\xc3\x03/C\
    \n\r\n\x05\x04\"\x02\x06\x03\x12\x04\xc3\x03FG\n\x0c\n\x04\x04\"\x02\x07\
    \x12\x04\xc4\x03\x08+\n\r\n\x05\x04\"\x02\x07\x04\x12\x04\xc4\x03\x08\
    \x10\n\r\n\x05\x04\"\x02\x07\x05\x12\x04\xc4\x03\x11\x17\n\r\n\x05\x04\"\
    \x02\x07\x01\x12\x04\xc4\x03\x18&\n\r\n\x05\x04\"\x02\x07\x03\x12\x04\
    \xc4\x03)*\n\x0c\n\x02\x04#\x12\x06\xc7\x03\0\xc8\x03\x01\n\x0b\n\x03\
    \x04#\x01\x12\x04\xc7\x03\x084\n\x0c\n\x02\x04$\x12\x06\xca\x03\0\xdd\
    \x03\x01\n\x0b\n\x03\x04$\x01\x12\x04\xca\x03\x084\n\x0c\n\x04\x04$\x02\
    \0\x12\x04\xcb\x03\x08'\n\r\n\x05\x04$\x02\0\x04\x12\x04\xcb\x03\x08\x10\
    \n\r\n\x05\x04$\x02\0\x05\x12\x04\xcb\x03\x11\x17\n\r\n\x05\x04$\x02\0\
    \x01\x12\x04\xcb\x03\x18\"\n\r\n\x05\x04$\x02\0\x03\x12\x04\xcb\x03%&\n\
    \x0c\n\x04\x04$\x02\x01\x12\x04\xcc\x03\x08R\n\r\n\x05\x04$\x02\x01\x04\
    \x12\x04\xcc\x03\x08\x10\n\r\n\x05\x04$\x02\x01\x06\x12\x04\xcc\x03\x11@\
    \n\r\n\x05\x04$\x02\x01\x01\x12\x04\xcc\x03AM\n\r\n\x05\x04$\x02\x01\x03\
    \x12\x04\xcc\x03PQ\n\x0c\n\x04\x04$\x02\x02\x12\x04\xcd\x03\x084\n\r\n\
    \x05\x04$\x02\x02\x04\x12\x04\xcd\x03\x08\x10\n\r\n\x05\x04$\x02\x02\x06\
    \x12\x04\xcd\x03\x11\"\n\r\n\x05\x04$\x02\x02\x01\x12\x04\xcd\x03#/\n\r\
    \n\x05\x04$\x02\x02\x03\x12\x04\xcd\x0323\n\x0c\n\x04\x04$\x02\x03\x12\
    \x04\xce\x03\x08,\n\r\n\x05\x04$\x02\x03\x04\x12\x04\xce\x03\x08\x10\n\r\
    \n\x05\x04$\x02\x03\x05\x12\x04\xce\x03\x11\x17\n\r\n\x05\x04$\x02\x03\
    \x01\x12\x04\xce\x03\x18'\n\r\n\x05\x04$\x02\x03\x03\x12\x04\xce\x03*+\n\
    \x0c\n\x04\x04$\x02\x04\x12\x04\xcf\x03\x08+\n\r\n\x05\x04$\x02\x04\x04\
    \x12\x04\xcf\x03\x08\x10\n\r\n\x05\x04$\x02\x04\x05\x12\x04\xcf\x03\x11\
    \x17\n\r\n\x05\x04$\x02\x04\x01\x12\x04\xcf\x03\x18&\n\r\n\x05\x04$\x02\
    \x04\x03\x12\x04\xcf\x03)*\n\x0c\n\x04\x04$\x02\x05\x12\x04\xd0\x03\x08&\
    \n\r\n\x05\x04$\x02\x05\x04\x12\x04\xd0\x03\x08\x10\n\r\n\x05\x04$\x02\
    \x05\x05\x12\x04\xd0\x03\x11\x16\n\r\n\x05\x04$\x02\x05\x01\x12\x04\xd0\
    \x03\x17!\n\r\n\x05\x04$\x02\x05\x03\x12\x04\xd0\x03$%\n\x0c\n\x04\x04$\
    \x02\x06\x12\x04\xd1\x03\x080\n\r\n\x05\x04$\x02\x06\x04\x12\x04\xd1\x03\
    \x08\x10\n\r\n\x05\x04$\x02\x06\x06\x12\x04\xd1\x03\x11#\n\r\n\x05\x04$\
    \x02\x06\x01\x12\x04\xd1\x03$+\n\r\n\x05\x04$\x02\x06\x03\x12\x04\xd1\
    \x03./\n\x0c\n\x04\x04$\x02\x07\x12\x04\xd2\x03\x08:\n\r\n\x05\x04$\x02\
    \x07\x04\x12\x04\xd2\x03\x08\x10\n\r\n\x05\x04$\x02\x07\x06\x12\x04\xd2\
    \x03\x11(\n\r\n\x05\x04$\x02\x07\x01\x12\x04\xd2\x03)5\n\r\n\x05\x04$\
    \x02\x07\x03\x12\x04\xd2\x0389\n\x0c\n\x04\x04$\x02\x08\x12\x04\xd3\x03\
    \x08.\n\r\n\x05\x04$\x02\x08\x04\x12\x04\xd3\x03\x08\x10\n\r\n\x05\x04$\
    \x02\x08\x06\x12\x04\xd3\x03\x11\"\n\r\n\x05\x04$\x02\x08\x01\x12\x04\
    \xd3\x03#)\n\r\n\x05\x04$\x02\x08\x03\x12\x04\xd3\x03,-\n\x0c\n\x04\x04$\
    \x02\t\x12\x04\xd4\x03\x088\n\r\n\x05\x04$\x02\t\x04\x12\x04\xd4\x03\x08\
    \x10\n\r\n\x05\x04$\x02\t\x06\x12\x04\xd4\x03\x11!\n\r\n\x05\x04$\x02\t\
    \x01\x12\x04\xd4\x03\"2\n\r\n\x05\x04$\x02\t\x03\x12\x04\xd4\x0357\n\x0c\
    \n\x04\x04$\x02\n\x12\x04\xd5\x03\x08=\n\r\n\x05\x04$\x02\n\x04\x12\x04\
    \xd5\x03\x08\x10\n\r\n\x05\x04$\x02\n\x06\x12\x04\xd5\x03\x11\x20\n\r\n\
    \x05\x04$\x02\n\x01\x12\x04\xd5\x03!7\n\r\n\x05\x04$\x02\n\x03\x12\x04\
    \xd5\x03:<\n\x0c\n\x04\x04$\x02\x0b\x12\x04\xd6\x03\x086\n\r\n\x05\x04$\
    \x02\x0b\x04\x12\x04\xd6\x03\x08\x10\n\r\n\x05\x04$\x02\x0b\x06\x12\x04\
    \xd6\x03\x11\x20\n\r\n\x05\x04$\x02\x0b\x01\x12\x04\xd6\x03!0\n\r\n\x05\
    \x04$\x02\x0b\x03\x12\x04\xd6\x0335\n\x0c\n\x04\x04$\x02\x0c\x12\x04\xd7\
    \x03\x08?\n\r\n\x05\x04$\x02\x0c\x04\x12\x04\xd7\x03\x08\x10\n\r\n\x05\
    \x04$\x02\x0c\x06\x12\x04\xd7\x03\x11!\n\r\n\x05\x04$\x02\x0c\x01\x12\
    \x04\xd7\x03\"9\n\r\n\x05\x04$\x02\x0c\x03\x12\x04\xd7\x03<>\n\x0c\n\x04\
    \x04$\x02\r\x12\x04\xd8\x03\x08)\n\r\n\x05\x04$\x02\r\x04\x12\x04\xd8\
    \x03\x08\x10\n\r\n\x05\x04$\x02\r\x05\x12\x04\xd8\x03\x11\x17\n\r\n\x05\
    \x04$\x02\r\x01\x12\x04\xd8\x03\x18#\n\r\n\x05\x04$\x02\r\x03\x12\x04\
    \xd8\x03&(\n\x0c\n\x04\x04$\x02\x0e\x12\x04\xd9\x03\x080\n\r\n\x05\x04$\
    \x02\x0e\x04\x12\x04\xd9\x03\x08\x10\n\r\n\x05\x04$\x02\x0e\x06\x12\x04\
    \xd9\x03\x11!\n\r\n\x05\x04$\x02\x0e\x01\x12\x04\xd9\x03\"*\n\r\n\x05\
    \x04$\x02\x0e\x03\x12\x04\xd9\x03-/\n\x0c\n\x04\x04$\x02\x0f\x12\x04\xda\
    \x03\x08)\n\r\n\x05\x04$\x02\x0f\x04\x12\x04\xda\x03\x08\x10\n\r\n\x05\
    \x04$\x02\x0f\x05\x12\x04\xda\x03\x11\x16\n\r\n\x05\x04$\x02\x0f\x01\x12\
    \x04\xda\x03\x17#\n\r\n\x05\x04$\x02\x0f\x03\x12\x04\xda\x03&(\n\x0c\n\
    \x04\x04$\x02\x10\x12\x04\xdb\x03\x08*\n\r\n\x05\x04$\x02\x10\x04\x12\
    \x04\xdb\x03\x08\x10\n\r\n\x05\x04$\x02\x10\x05\x12\x04\xdb\x03\x11\x16\
    \n\r\n\x05\x04$\x02\x10\x01\x12\x04\xdb\x03\x17$\n\r\n\x05\x04$\x02\x10\
    \x03\x12\x04\xdb\x03')\n\x0c\n\x04\x04$\x02\x11\x12\x04\xdc\x03\x082\n\r\
    \n\x05\x04$\x02\x11\x04\x12\x04\xdc\x03\x08\x10\n\r\n\x05\x04$\x02\x11\
    \x05\x12\x04\xdc\x03\x11\x16\n\r\n\x05\x04$\x02\x11\x01\x12\x04\xdc\x03\
    \x17,\n\r\n\x05\x04$\x02\x11\x03\x12\x04\xdc\x03/1\n\x0c\n\x02\x04%\x12\
    \x06\xdf\x03\0\xe6\x03\x01\n\x0b\n\x03\x04%\x01\x12\x04\xdf\x03\x081\n\
    \x0e\n\x04\x04%\x03\0\x12\x06\xe0\x03\x08\xe3\x03\t\n\r\n\x05\x04%\x03\0\
    \x01\x12\x04\xe0\x03\x10\x17\n\x0e\n\x06\x04%\x03\0\x02\0\x12\x04\xe1\
    \x03\x101\n\x0f\n\x07\x04%\x03\0\x02\0\x04\x12\x04\xe1\x03\x10\x18\n\x0f\
    \n\x07\x04%\x03\0\x02\0\x05\x12\x04\xe1\x03\x19\x1f\n\x0f\n\x07\x04%\x03\
    \0\x02\0\x01\x12\x04\xe1\x03\x20,\n\x0f\n\x07\x04%\x03\0\x02\0\x03\x12\
    \x04\xe1\x03/0\n\x0e\n\x06\x04%\x03\0\x02\x01\x12\x04\xe2\x03\x102\n\x0f\
    \n\x07\x04%\x03\0\x02\x01\x04\x12\x04\xe2\x03\x10\x18\n\x0f\n\x07\x04%\
    \x03\0\x02\x01\x05\x12\x04\xe2\x03\x19\x1f\n\x0f\n\x07\x04%\x03\0\x02\
    \x01\x01\x12\x04\xe2\x03\x20-\n\x0f\n\x07\x04%\x03\0\x02\x01\x03\x12\x04\
    \xe2\x0301\n\x0c\n\x04\x04%\x02\0\x12\x04\xe5\x03\x08Q\n\r\n\x05\x04%\
    \x02\0\x04\x12\x04\xe5\x03\x08\x10\n\r\n\x05\x04%\x02\0\x06\x12\x04\xe5\
    \x03\x11C\n\r\n\x05\x04%\x02\0\x01\x12\x04\xe5\x03DL\n\r\n\x05\x04%\x02\
    \0\x03\x12\x04\xe5\x03OP\n\x0c\n\x02\x04&\x12\x06\xe8\x03\0\xed\x03\x01\
    \n\x0b\n\x03\x04&\x01\x12\x04\xe8\x03\x086\n\x0c\n\x04\x04&\x02\0\x12\
    \x04\xe9\x03\x08'\n\r\n\x05\x04&\x02\0\x04\x12\x04\xe9\x03\x08\x10\n\r\n\
    \x05\x04&\x02\0\x05\x12\x04\xe9\x03\x11\x17\n\r\n\x05\x04&\x02\0\x01\x12\
    \x04\xe9\x03\x18\"\n\r\n\x05\x04&\x02\0\x03\x12\x04\xe9\x03%&\n\x0c\n\
    \x04\x04&\x02\x01\x12\x04\xea\x03\x08U\n\r\n\x05\x04&\x02\x01\x04\x12\
    \x04\xea\x03\x08\x10\n\r\n\x05\x04&\x02\x01\x06\x12\x04\xea\x03\x11@\n\r\
    \n\x05\x04&\x02\x01\x01\x12\x04\xea\x03AP\n\r\n\x05\x04&\x02\x01\x03\x12\
    \x04\xea\x03ST\n\x0c\n\x04\x04&\x02\x02\x12\x04\xeb\x03\x08,\n\r\n\x05\
    \x04&\x02\x02\x04\x12\x04\xeb\x03\x08\x10\n\r\n\x05\x04&\x02\x02\x05\x12\
    \x04\xeb\x03\x11\x17\n\r\n\x05\x04&\x02\x02\x01\x12\x04\xeb\x03\x18'\n\r\
    \n\x05\x04&\x02\x02\x03\x12\x04\xeb\x03*+\n\x0c\n\x04\x04&\x02\x03\x12\
    \x04\xec\x03\x08+\n\r\n\x05\x04&\x02\x03\x04\x12\x04\xec\x03\x08\x10\n\r\
    \n\x05\x04&\x02\x03\x05\x12\x04\xec\x03\x11\x17\n\r\n\x05\x04&\x02\x03\
    \x01\x12\x04\xec\x03\x18&\n\r\n\x05\x04&\x02\x03\x03\x12\x04\xec\x03)*\n\
    \x0c\n\x02\x04'\x12\x06\xef\x03\0\xf3\x03\x01\n\x0b\n\x03\x04'\x01\x12\
    \x04\xef\x03\x083\n\x0c\n\x04\x04'\x02\0\x12\x04\xf0\x03\x08'\n\r\n\x05\
    \x04'\x02\0\x04\x12\x04\xf0\x03\x08\x10\n\r\n\x05\x04'\x02\0\x05\x12\x04\
    \xf0\x03\x11\x17\n\r\n\x05\x04'\x02\0\x01\x12\x04\xf0\x03\x18\"\n\r\n\
    \x05\x04'\x02\0\x03\x12\x04\xf0\x03%&\n\x0c\n\x04\x04'\x02\x01\x12\x04\
    \xf1\x03\x08Q\n\r\n\x05\x04'\x02\x01\x04\x12\x04\xf1\x03\x08\x10\n\r\n\
    \x05\x04'\x02\x01\x06\x12\x04\xf1\x03\x11@\n\r\n\x05\x04'\x02\x01\x01\
    \x12\x04\xf1\x03AL\n\r\n\x05\x04'\x02\x01\x03\x12\x04\xf1\x03OP\n\x0c\n\
    \x04\x04'\x02\x02\x12\x04\xf2\x03\x08#\n\r\n\x05\x04'\x02\x02\x04\x12\
    \x04\xf2\x03\x08\x10\n\r\n\x05\x04'\x02\x02\x05\x12\x04\xf2\x03\x11\x17\
    \n\r\n\x05\x04'\x02\x02\x01\x12\x04\xf2\x03\x18\x1e\n\r\n\x05\x04'\x02\
    \x02\x03\x12\x04\xf2\x03!\"\n\x0c\n\x02\x04(\x12\x06\xf5\x03\0\xf8\x03\
    \x01\n\x0b\n\x03\x04(\x01\x12\x04\xf5\x03\x089\n\x0c\n\x04\x04(\x02\0\
    \x12\x04\xf6\x03\x081\n\r\n\x05\x04(\x02\0\x04\x12\x04\xf6\x03\x08\x10\n\
    \r\n\x05\x04(\x02\0\x06\x12\x04\xf6\x03\x11#\n\r\n\x05\x04(\x02\0\x01\
    \x12\x04\xf6\x03$,\n\r\n\x05\x04(\x02\0\x03\x12\x04\xf6\x03/0\n\x0c\n\
    \x04\x04(\x02\x01\x12\x04\xf7\x03\x08%\n\r\n\x05\x04(\x02\x01\x04\x12\
    \x04\xf7\x03\x08\x10\n\r\n\x05\x04(\x02\x01\x05\x12\x04\xf7\x03\x11\x17\
    \n\r\n\x05\x04(\x02\x01\x01\x12\x04\xf7\x03\x18\x20\n\r\n\x05\x04(\x02\
    \x01\x03\x12\x04\xf7\x03#$\n\x0c\n\x02\x04)\x12\x06\xfa\x03\0\xfc\x03\
    \x01\n\x0b\n\x03\x04)\x01\x12\x04\xfa\x03\x08;\n\x0c\n\x04\x04)\x02\0\
    \x12\x04\xfb\x03\x08*\n\r\n\x05\x04)\x02\0\x04\x12\x04\xfb\x03\x08\x10\n\
    \r\n\x05\x04)\x02\0\x05\x12\x04\xfb\x03\x11\x17\n\r\n\x05\x04)\x02\0\x01\
    \x12\x04\xfb\x03\x18%\n\r\n\x05\x04)\x02\0\x03\x12\x04\xfb\x03()\n\x0c\n\
    \x02\x04*\x12\x06\xfe\x03\0\x82\x04\x01\n\x0b\n\x03\x04*\x01\x12\x04\xfe\
    \x03\x08;\n\x0c\n\x04\x04*\x02\0\x12\x04\xff\x03\x08'\n\r\n\x05\x04*\x02\
    \0\x04\x12\x04\xff\x03\x08\x10\n\r\n\x05\x04*\x02\0\x05\x12\x04\xff\x03\
    \x11\x17\n\r\n\x05\x04*\x02\0\x01\x12\x04\xff\x03\x18\"\n\r\n\x05\x04*\
    \x02\0\x03\x12\x04\xff\x03%&\n\x0c\n\x04\x04*\x02\x01\x12\x04\x80\x04\
    \x08#\n\r\n\x05\x04*\x02\x01\x04\x12\x04\x80\x04\x08\x10\n\r\n\x05\x04*\
    \x02\x01\x05\x12\x04\x80\x04\x11\x17\n\r\n\x05\x04*\x02\x01\x01\x12\x04\
    \x80\x04\x18\x1e\n\r\n\x05\x04*\x02\x01\x03\x12\x04\x80\x04!\"\n\x0c\n\
    \x04\x04*\x02\x02\x12\x04\x81\x04\x08$\n\r\n\x05\x04*\x02\x02\x04\x12\
    \x04\x81\x04\x08\x10\n\r\n\x05\x04*\x02\x02\x05\x12\x04\x81\x04\x11\x17\
    \n\r\n\x05\x04*\x02\x02\x01\x12\x04\x81\x04\x18\x1f\n\r\n\x05\x04*\x02\
    \x02\x03\x12\x04\x81\x04\"#\n\x0c\n\x02\x04+\x12\x06\x84\x04\0\x8d\x04\
    \x01\n\x0b\n\x03\x04+\x01\x12\x04\x84\x04\x08-\n\x0c\n\x04\x04+\x02\0\
    \x12\x04\x85\x04\x08'\n\r\n\x05\x04+\x02\0\x04\x12\x04\x85\x04\x08\x10\n\
    \r\n\x05\x04+\x02\0\x05\x12\x04\x85\x04\x11\x17\n\r\n\x05\x04+\x02\0\x01\
    \x12\x04\x85\x04\x18\"\n\r\n\x05\x04+\x02\0\x03\x12\x04\x85\x04%&\n\x0c\
    \n\x04\x04+\x02\x01\x12\x04\x86\x04\x08'\n\r\n\x05\x04+\x02\x01\x04\x12\
    \x04\x86\x04\x08\x10\n\r\n\x05\x04+\x02\x01\x05\x12\x04\x86\x04\x11\x17\
    \n\r\n\x05\x04+\x02\x01\x01\x12\x04\x86\x04\x18\"\n\r\n\x05\x04+\x02\x01\
    \x03\x12\x04\x86\x04%&\n\x0c\n\x04\x04+\x02\x02\x12\x04\x87\x04\x08)\n\r\
    \n\x05\x04+\x02\x02\x04\x12\x04\x87\x04\x08\x10\n\r\n\x05\x04+\x02\x02\
    \x05\x12\x04\x87\x04\x11\x17\n\r\n\x05\x04+\x02\x02\x01\x12\x04\x87\x04\
    \x18$\n\r\n\x05\x04+\x02\x02\x03\x12\x04\x87\x04'(\n\x0c\n\x04\x04+\x02\
    \x03\x12\x04\x88\x04\x08*\n\r\n\x05\x04+\x02\x03\x04\x12\x04\x88\x04\x08\
    \x10\n\r\n\x05\x04+\x02\x03\x05\x12\x04\x88\x04\x11\x17\n\r\n\x05\x04+\
    \x02\x03\x01\x12\x04\x88\x04\x18%\n\r\n\x05\x04+\x02\x03\x03\x12\x04\x88\
    \x04()\n\x0c\n\x04\x04+\x02\x04\x12\x04\x89\x04\x08)\n\r\n\x05\x04+\x02\
    \x04\x04\x12\x04\x89\x04\x08\x10\n\r\n\x05\x04+\x02\x04\x05\x12\x04\x89\
    \x04\x11\x17\n\r\n\x05\x04+\x02\x04\x01\x12\x04\x89\x04\x18$\n\r\n\x05\
    \x04+\x02\x04\x03\x12\x04\x89\x04'(\n\x0c\n\x04\x04+\x02\x05\x12\x04\x8a\
    \x04\x08*\n\r\n\x05\x04+\x02\x05\x04\x12\x04\x8a\x04\x08\x10\n\r\n\x05\
    \x04+\x02\x05\x05\x12\x04\x8a\x04\x11\x17\n\r\n\x05\x04+\x02\x05\x01\x12\
    \x04\x8a\x04\x18%\n\r\n\x05\x04+\x02\x05\x03\x12\x04\x8a\x04()\n\x0c\n\
    \x04\x04+\x02\x06\x12\x04\x8b\x04\x08+\n\r\n\x05\x04+\x02\x06\x04\x12\
    \x04\x8b\x04\x08\x10\n\r\n\x05\x04+\x02\x06\x05\x12\x04\x8b\x04\x11\x17\
    \n\r\n\x05\x04+\x02\x06\x01\x12\x04\x8b\x04\x18&\n\r\n\x05\x04+\x02\x06\
    \x03\x12\x04\x8b\x04)*\n\x0c\n\x04\x04+\x02\x07\x12\x04\x8c\x04\x08%\n\r\
    \n\x05\x04+\x02\x07\x04\x12\x04\x8c\x04\x08\x10\n\r\n\x05\x04+\x02\x07\
    \x05\x12\x04\x8c\x04\x11\x17\n\r\n\x05\x04+\x02\x07\x01\x12\x04\x8c\x04\
    \x18\x20\n\r\n\x05\x04+\x02\x07\x03\x12\x04\x8c\x04#$\n\x0c\n\x02\x04,\
    \x12\x06\x8f\x04\0\x94\x04\x01\n\x0b\n\x03\x04,\x01\x12\x04\x8f\x04\x08.\
    \n\x0c\n\x04\x04,\x02\0\x12\x04\x90\x04\x08'\n\r\n\x05\x04,\x02\0\x04\
    \x12\x04\x90\x04\x08\x10\n\r\n\x05\x04,\x02\0\x05\x12\x04\x90\x04\x11\
    \x17\n\r\n\x05\x04,\x02\0\x01\x12\x04\x90\x04\x18\"\n\r\n\x05\x04,\x02\0\
    \x03\x12\x04\x90\x04%&\n\x0c\n\x04\x04,\x02\x01\x12\x04\x91\x04\x08%\n\r\
    \n\x05\x04,\x02\x01\x04\x12\x04\x91\x04\x08\x10\n\r\n\x05\x04,\x02\x01\
    \x05\x12\x04\x91\x04\x11\x17\n\r\n\x05\x04,\x02\x01\x01\x12\x04\x91\x04\
    \x18\x20\n\r\n\x05\x04,\x02\x01\x03\x12\x04\x91\x04#$\n\x0c\n\x04\x04,\
    \x02\x02\x12\x04\x92\x04\x08:\n\r\n\x05\x04,\x02\x02\x04\x12\x04\x92\x04\
    \x08\x10\n\r\n\x05\x04,\x02\x02\x06\x12\x04\x92\x04\x11(\n\r\n\x05\x04,\
    \x02\x02\x01\x12\x04\x92\x04)5\n\r\n\x05\x04,\x02\x02\x03\x12\x04\x92\
    \x0489\n\x0c\n\x04\x04,\x02\x03\x12\x04\x93\x04\x08$\n\r\n\x05\x04,\x02\
    \x03\x04\x12\x04\x93\x04\x08\x10\n\r\n\x05\x04,\x02\x03\x05\x12\x04\x93\
    \x04\x11\x17\n\r\n\x05\x04,\x02\x03\x01\x12\x04\x93\x04\x18\x1e\n\r\n\
    \x05\x04,\x02\x03\x03\x12\x04\x93\x04!#\n\x0c\n\x02\x04-\x12\x06\x96\x04\
    \0\x9d\x04\x01\n\x0b\n\x03\x04-\x01\x12\x04\x96\x04\x08-\n\x0c\n\x04\x04\
    -\x02\0\x12\x04\x97\x04\x08)\n\r\n\x05\x04-\x02\0\x04\x12\x04\x97\x04\
    \x08\x10\n\r\n\x05\x04-\x02\0\x05\x12\x04\x97\x04\x11\x17\n\r\n\x05\x04-\
    \x02\0\x01\x12\x04\x97\x04\x18$\n\r\n\x05\x04-\x02\0\x03\x12\x04\x97\x04\
    '(\n\x0c\n\x04\x04-\x02\x01\x12\x04\x98\x04\x08.\n\r\n\x05\x04-\x02\x01\
    \x04\x12\x04\x98\x04\x08\x10\n\r\n\x05\x04-\x02\x01\x05\x12\x04\x98\x04\
    \x11\x17\n\r\n\x05\x04-\x02\x01\x01\x12\x04\x98\x04\x18)\n\r\n\x05\x04-\
    \x02\x01\x03\x12\x04\x98\x04,-\n\x0c\n\x04\x04-\x02\x02\x12\x04\x99\x04\
    \x08(\n\r\n\x05\x04-\x02\x02\x04\x12\x04\x99\x04\x08\x10\n\r\n\x05\x04-\
    \x02\x02\x05\x12\x04\x99\x04\x11\x17\n\r\n\x05\x04-\x02\x02\x01\x12\x04\
    \x99\x04\x18#\n\r\n\x05\x04-\x02\x02\x03\x12\x04\x99\x04&'\n\x0c\n\x04\
    \x04-\x02\x03\x12\x04\x9a\x04\x08-\n\r\n\x05\x04-\x02\x03\x04\x12\x04\
    \x9a\x04\x08\x10\n\r\n\x05\x04-\x02\x03\x05\x12\x04\x9a\x04\x11\x17\n\r\
    \n\x05\x04-\x02\x03\x01\x12\x04\x9a\x04\x18(\n\r\n\x05\x04-\x02\x03\x03\
    \x12\x04\x9a\x04+,\n\x0c\n\x04\x04-\x02\x04\x12\x04\x9b\x04\x08/\n\r\n\
    \x05\x04-\x02\x04\x04\x12\x04\x9b\x04\x08\x10\n\r\n\x05\x04-\x02\x04\x05\
    \x12\x04\x9b\x04\x11\x17\n\r\n\x05\x04-\x02\x04\x01\x12\x04\x9b\x04\x18*\
    \n\r\n\x05\x04-\x02\x04\x03\x12\x04\x9b\x04-.\n\x0c\n\x04\x04-\x02\x05\
    \x12\x04\x9c\x04\x08%\n\r\n\x05\x04-\x02\x05\x04\x12\x04\x9c\x04\x08\x10\
    \n\r\n\x05\x04-\x02\x05\x05\x12\x04\x9c\x04\x11\x17\n\r\n\x05\x04-\x02\
    \x05\x01\x12\x04\x9c\x04\x18\x20\n\r\n\x05\x04-\x02\x05\x03\x12\x04\x9c\
    \x04#$\n\x0c\n\x02\x04.\x12\x06\x9f\x04\0\xa6\x04\x01\n\x0b\n\x03\x04.\
    \x01\x12\x04\x9f\x04\x08/\n\x0c\n\x04\x04.\x02\0\x12\x04\xa0\x04\x08,\n\
    \r\n\x05\x04.\x02\0\x04\x12\x04\xa0\x04\x08\x10\n\r\n\x05\x04.\x02\0\x05\
    \x12\x04\xa0\x04\x11\x17\n\r\n\x05\x04.\x02\0\x01\x12\x04\xa0\x04\x18'\n\
    \r\n\x05\x04.\x02\0\x03\x12\x04\xa0\x04*+\n\x0c\n\x04\x04.\x02\x01\x12\
    \x04\xa1\x04\x08'\n\r\n\x05\x04.\x02\x01\x04\x12\x04\xa1\x04\x08\x10\n\r\
    \n\x05\x04.\x02\x01\x05\x12\x04\xa1\x04\x11\x17\n\r\n\x05\x04.\x02\x01\
    \x01\x12\x04\xa1\x04\x18\"\n\r\n\x05\x04.\x02\x01\x03\x12\x04\xa1\x04%&\
    \n\x0c\n\x04\x04.\x02\x02\x12\x04\xa2\x04\x08&\n\r\n\x05\x04.\x02\x02\
    \x04\x12\x04\xa2\x04\x08\x10\n\r\n\x05\x04.\x02\x02\x05\x12\x04\xa2\x04\
    \x11\x17\n\r\n\x05\x04.\x02\x02\x01\x12\x04\xa2\x04\x18!\n\r\n\x05\x04.\
    \x02\x02\x03\x12\x04\xa2\x04$%\n\x0c\n\x04\x04.\x02\x03\x12\x04\xa3\x04\
    \x08*\n\r\n\x05\x04.\x02\x03\x04\x12\x04\xa3\x04\x08\x10\n\r\n\x05\x04.\
    \x02\x03\x05\x12\x04\xa3\x04\x11\x17\n\r\n\x05\x04.\x02\x03\x01\x12\x04\
    \xa3\x04\x18%\n\r\n\x05\x04.\x02\x03\x03\x12\x04\xa3\x04()\n\x0c\n\x04\
    \x04.\x02\x04\x12\x04\xa4\x04\x08,\n\r\n\x05\x04.\x02\x04\x04\x12\x04\
    \xa4\x04\x08\x10\n\r\n\x05\x04.\x02\x04\x05\x12\x04\xa4\x04\x11\x17\n\r\
    \n\x05\x04.\x02\x04\x01\x12\x04\xa4\x04\x18'\n\r\n\x05\x04.\x02\x04\x03\
    \x12\x04\xa4\x04*+\n\x0c\n\x04\x04.\x02\x05\x12\x04\xa5\x04\x08#\n\r\n\
    \x05\x04.\x02\x05\x04\x12\x04\xa5\x04\x08\x10\n\r\n\x05\x04.\x02\x05\x05\
    \x12\x04\xa5\x04\x11\x17\n\r\n\x05\x04.\x02\x05\x01\x12\x04\xa5\x04\x18\
    \x1e\n\r\n\x05\x04.\x02\x05\x03\x12\x04\xa5\x04!\"\n\x0c\n\x02\x04/\x12\
    \x06\xa8\x04\0\xad\x04\x01\n\x0b\n\x03\x04/\x01\x12\x04\xa8\x04\x088\n\
    \x0c\n\x04\x04/\x02\0\x12\x04\xa9\x04\x08'\n\r\n\x05\x04/\x02\0\x04\x12\
    \x04\xa9\x04\x08\x10\n\r\n\x05\x04/\x02\0\x05\x12\x04\xa9\x04\x11\x17\n\
    \r\n\x05\x04/\x02\0\x01\x12\x04\xa9\x04\x18\"\n\r\n\x05\x04/\x02\0\x03\
    \x12\x04\xa9\x04%&\n\x0c\n\x04\x04/\x02\x01\x12\x04\xaa\x04\x08(\n\r\n\
    \x05\x04/\x02\x01\x04\x12\x04\xaa\x04\x08\x10\n\r\n\x05\x04/\x02\x01\x05\
    \x12\x04\xaa\x04\x11\x17\n\r\n\x05\x04/\x02\x01\x01\x12\x04\xaa\x04\x18#\
    \n\r\n\x05\x04/\x02\x01\x03\x12\x04\xaa\x04&'\n\x0c\n\x04\x04/\x02\x02\
    \x12\x04\xab\x04\x08%\n\r\n\x05\x04/\x02\x02\x04\x12\x04\xab\x04\x08\x10\
    \n\r\n\x05\x04/\x02\x02\x05\x12\x04\xab\x04\x11\x17\n\r\n\x05\x04/\x02\
    \x02\x01\x12\x04\xab\x04\x18\x20\n\r\n\x05\x04/\x02\x02\x03\x12\x04\xab\
    \x04#$\n\x0c\n\x04\x04/\x02\x03\x12\x04\xac\x04\x08$\n\r\n\x05\x04/\x02\
    \x03\x04\x12\x04\xac\x04\x08\x10\n\r\n\x05\x04/\x02\x03\x05\x12\x04\xac\
    \x04\x11\x17\n\r\n\x05\x04/\x02\x03\x01\x12\x04\xac\x04\x18\x1f\n\r\n\
    \x05\x04/\x02\x03\x03\x12\x04\xac\x04\"#\n\x0c\n\x02\x040\x12\x06\xaf\
    \x04\0\xbd\x04\x01\n\x0b\n\x03\x040\x01\x12\x04\xaf\x04\x08\x1a\n\x0c\n\
    \x04\x040\x02\0\x12\x04\xb0\x04\x08&\n\r\n\x05\x040\x02\0\x04\x12\x04\
    \xb0\x04\x08\x10\n\r\n\x05\x040\x02\0\x05\x12\x04\xb0\x04\x11\x17\n\r\n\
    \x05\x040\x02\0\x01\x12\x04\xb0\x04\x18!\n\r\n\x05\x040\x02\0\x03\x12\
    \x04\xb0\x04$%\n\x0c\n\x04\x040\x02\x01\x12\x04\xb1\x04\x08$\n\r\n\x05\
    \x040\x02\x01\x04\x12\x04\xb1\x04\x08\x10\n\r\n\x05\x040\x02\x01\x05\x12\
    \x04\xb1\x04\x11\x17\n\r\n\x05\x040\x02\x01\x01\x12\x04\xb1\x04\x18\x1f\
    \n\r\n\x05\x040\x02\x01\x03\x12\x04\xb1\x04\"#\n\x0c\n\x04\x040\x02\x02\
    \x12\x04\xb2\x04\x08*\n\r\n\x05\x040\x02\x02\x04\x12\x04\xb2\x04\x08\x10\
    \n\r\n\x05\x040\x02\x02\x05\x12\x04\xb2\x04\x11\x17\n\r\n\x05\x040\x02\
    \x02\x01\x12\x04\xb2\x04\x18%\n\r\n\x05\x040\x02\x02\x03\x12\x04\xb2\x04\
    ()\n\x0c\n\x04\x040\x02\x03\x12\x04\xb3\x04\x08$\n\r\n\x05\x040\x02\x03\
    \x04\x12\x04\xb3\x04\x08\x10\n\r\n\x05\x040\x02\x03\x05\x12\x04\xb3\x04\
    \x11\x17\n\r\n\x05\x040\x02\x03\x01\x12\x04\xb3\x04\x18\x1f\n\r\n\x05\
    \x040\x02\x03\x03\x12\x04\xb3\x04\"#\n\x0c\n\x04\x040\x02\x04\x12\x04\
    \xb4\x04\x08-\n\r\n\x05\x040\x02\x04\x04\x12\x04\xb4\x04\x08\x10\n\r\n\
    \x05\x040\x02\x04\x05\x12\x04\xb4\x04\x11\x16\n\r\n\x05\x040\x02\x04\x01\
    \x12\x04\xb4\x04\x17(\n\r\n\x05\x040\x02\x04\x03\x12\x04\xb4\x04+,\n\x0c\
    \n\x04\x040\x02\x05\x12\x04\xb5\x04\x08/\n\r\n\x05\x040\x02\x05\x04\x12\
    \x04\xb5\x04\x08\x10\n\r\n\x05\x040\x02\x05\x05\x12\x04\xb5\x04\x11\x17\
    \n\r\n\x05\x040\x02\x05\x01\x12\x04\xb5\x04\x18*\n\r\n\x05\x040\x02\x05\
    \x03\x12\x04\xb5\x04-.\n\x0c\n\x04\x040\x02\x06\x12\x04\xb6\x04\x083\n\r\
    \n\x05\x040\x02\x06\x04\x12\x04\xb6\x04\x08\x10\n\r\n\x05\x040\x02\x06\
    \x05\x12\x04\xb6\x04\x11\x17\n\r\n\x05\x040\x02\x06\x01\x12\x04\xb6\x04\
    \x18.\n\r\n\x05\x040\x02\x06\x03\x12\x04\xb6\x0412\n\x0c\n\x04\x040\x02\
    \x07\x12\x04\xb7\x04\x08&\n\r\n\x05\x040\x02\x07\x04\x12\x04\xb7\x04\x08\
    \x10\n\r\n\x05\x040\x02\x07\x05\x12\x04\xb7\x04\x11\x17\n\r\n\x05\x040\
    \x02\x07\x01\x12\x04\xb7\x04\x18!\n\r\n\x05\x040\x02\x07\x03\x12\x04\xb7\
    \x04$%\n\x0c\n\x04\x040\x02\x08\x12\x04\xb8\x04\x08*\n\r\n\x05\x040\x02\
    \x08\x04\x12\x04\xb8\x04\x08\x10\n\r\n\x05\x040\x02\x08\x05\x12\x04\xb8\
    \x04\x11\x17\n\r\n\x05\x040\x02\x08\x01\x12\x04\xb8\x04\x18%\n\r\n\x05\
    \x040\x02\x08\x03\x12\x04\xb8\x04()\n\x0c\n\x04\x040\x02\t\x12\x04\xb9\
    \x04\x08&\n\r\n\x05\x040\x02\t\x04\x12\x04\xb9\x04\x08\x10\n\r\n\x05\x04\
    0\x02\t\x05\x12\x04\xb9\x04\x11\x17\n\r\n\x05\x040\x02\t\x01\x12\x04\xb9\
    \x04\x18\x20\n\r\n\x05\x040\x02\t\x03\x12\x04\xb9\x04#%\n\x0c\n\x04\x040\
    \x02\n\x12\x04\xba\x04\x08'\n\r\n\x05\x040\x02\n\x04\x12\x04\xba\x04\x08\
    \x10\n\r\n\x05\x040\x02\n\x05\x12\x04\xba\x04\x11\x17\n\r\n\x05\x040\x02\
    \n\x01\x12\x04\xba\x04\x18!\n\r\n\x05\x040\x02\n\x03\x12\x04\xba\x04$&\n\
    \x0c\n\x04\x040\x02\x0b\x12\x04\xbb\x04\x08&\n\r\n\x05\x040\x02\x0b\x04\
    \x12\x04\xbb\x04\x08\x10\n\r\n\x05\x040\x02\x0b\x05\x12\x04\xbb\x04\x11\
    \x17\n\r\n\x05\x040\x02\x0b\x01\x12\x04\xbb\x04\x18\x20\n\r\n\x05\x040\
    \x02\x0b\x03\x12\x04\xbb\x04#%\n\x0c\n\x04\x040\x02\x0c\x12\x04\xbc\x04\
    \x08,\n\r\n\x05\x040\x02\x0c\x04\x12\x04\xbc\x04\x08\x10\n\r\n\x05\x040\
    \x02\x0c\x05\x12\x04\xbc\x04\x11\x17\n\r\n\x05\x040\x02\x0c\x01\x12\x04\
    \xbc\x04\x18&\n\r\n\x05\x040\x02\x0c\x03\x12\x04\xbc\x04)+\n\x0c\n\x02\
    \x041\x12\x06\xbf\x04\0\xc6\x04\x01\n\x0b\n\x03\x041\x01\x12\x04\xbf\x04\
    \x086\n\x0c\n\x04\x041\x02\0\x12\x04\xc0\x04\x08$\n\r\n\x05\x041\x02\0\
    \x04\x12\x04\xc0\x04\x08\x10\n\r\n\x05\x041\x02\0\x05\x12\x04\xc0\x04\
    \x11\x17\n\r\n\x05\x041\x02\0\x01\x12\x04\xc0\x04\x18\x1f\n\r\n\x05\x041\
    \x02\0\x03\x12\x04\xc0\x04\"#\n\x0c\n\x04\x041\x02\x01\x12\x04\xc1\x04\
    \x08'\n\r\n\x05\x041\x02\x01\x04\x12\x04\xc1\x04\x08\x10\n\r\n\x05\x041\
    \x02\x01\x05\x12\x04\xc1\x04\x11\x17\n\r\n\x05\x041\x02\x01\x01\x12\x04\
    \xc1\x04\x18\"\n\r\n\x05\x041\x02\x01\x03\x12\x04\xc1\x04%&\n\x0c\n\x04\
    \x041\x02\x02\x12\x04\xc2\x04\x08'\n\r\n\x05\x041\x02\x02\x04\x12\x04\
    \xc2\x04\x08\x10\n\r\n\x05\x041\x02\x02\x05\x12\x04\xc2\x04\x11\x17\n\r\
    \n\x05\x041\x02\x02\x01\x12\x04\xc2\x04\x18\"\n\r\n\x05\x041\x02\x02\x03\
    \x12\x04\xc2\x04%&\n\x0c\n\x04\x041\x02\x03\x12\x04\xc3\x04\x08%\n\r\n\
    \x05\x041\x02\x03\x04\x12\x04\xc3\x04\x08\x10\n\r\n\x05\x041\x02\x03\x05\
    \x12\x04\xc3\x04\x11\x17\n\r\n\x05\x041\x02\x03\x01\x12\x04\xc3\x04\x18\
    \x20\n\r\n\x05\x041\x02\x03\x03\x12\x04\xc3\x04#$\n\x0c\n\x04\x041\x02\
    \x04\x12\x04\xc4\x04\x08I\n\r\n\x05\x041\x02\x04\x04\x12\x04\xc4\x04\x08\
    \x10\n\r\n\x05\x041\x02\x04\x06\x12\x04\xc4\x04\x11@\n\r\n\x05\x041\x02\
    \x04\x01\x12\x04\xc4\x04AD\n\r\n\x05\x041\x02\x04\x03\x12\x04\xc4\x04GH\
    \n\x0c\n\x04\x041\x02\x05\x12\x04\xc5\x04\x08%\n\r\n\x05\x041\x02\x05\
    \x04\x12\x04\xc5\x04\x08\x10\n\r\n\x05\x041\x02\x05\x05\x12\x04\xc5\x04\
    \x11\x17\n\r\n\x05\x041\x02\x05\x01\x12\x04\xc5\x04\x18\x20\n\r\n\x05\
    \x041\x02\x05\x03\x12\x04\xc5\x04#$\n\x0c\n\x02\x042\x12\x06\xc8\x04\0\
    \xcf\x04\x01\n\x0b\n\x03\x042\x01\x12\x04\xc8\x04\x086\n\x0c\n\x04\x042\
    \x02\0\x12\x04\xc9\x04\x08$\n\r\n\x05\x042\x02\0\x04\x12\x04\xc9\x04\x08\
    \x10\n\r\n\x05\x042\x02\0\x05\x12\x04\xc9\x04\x11\x17\n\r\n\x05\x042\x02\
    \0\x01\x12\x04\xc9\x04\x18\x1f\n\r\n\x05\x042\x02\0\x03\x12\x04\xc9\x04\
    \"#\n\x0c\n\x04\x042\x02\x01\x12\x04\xca\x04\x08'\n\r\n\x05\x042\x02\x01\
    \x04\x12\x04\xca\x04\x08\x10\n\r\n\x05\x042\x02\x01\x05\x12\x04\xca\x04\
    \x11\x17\n\r\n\x05\x042\x02\x01\x01\x12\x04\xca\x04\x18\"\n\r\n\x05\x042\
    \x02\x01\x03\x12\x04\xca\x04%&\n\x0c\n\x04\x042\x02\x02\x12\x04\xcb\x04\
    \x08%\n\r\n\x05\x042\x02\x02\x04\x12\x04\xcb\x04\x08\x10\n\r\n\x05\x042\
    \x02\x02\x05\x12\x04\xcb\x04\x11\x17\n\r\n\x05\x042\x02\x02\x01\x12\x04\
    \xcb\x04\x18\x20\n\r\n\x05\x042\x02\x02\x03\x12\x04\xcb\x04#$\n\x0c\n\
    \x04\x042\x02\x03\x12\x04\xcc\x04\x08&\n\r\n\x05\x042\x02\x03\x04\x12\
    \x04\xcc\x04\x08\x10\n\r\n\x05\x042\x02\x03\x05\x12\x04\xcc\x04\x11\x17\
    \n\r\n\x05\x042\x02\x03\x01\x12\x04\xcc\x04\x18!\n\r\n\x05\x042\x02\x03\
    \x03\x12\x04\xcc\x04$%\n\x0c\n\x04\x042\x02\x04\x12\x04\xcd\x04\x08(\n\r\
    \n\x05\x042\x02\x04\x04\x12\x04\xcd\x04\x08\x10\n\r\n\x05\x042\x02\x04\
    \x05\x12\x04\xcd\x04\x11\x17\n\r\n\x05\x042\x02\x04\x01\x12\x04\xcd\x04\
    \x18#\n\r\n\x05\x042\x02\x04\x03\x12\x04\xcd\x04&'\n\x0c\n\x04\x042\x02\
    \x05\x12\x04\xce\x04\x08I\n\r\n\x05\x042\x02\x05\x04\x12\x04\xce\x04\x08\
    \x10\n\r\n\x05\x042\x02\x05\x06\x12\x04\xce\x04\x11@\n\r\n\x05\x042\x02\
    \x05\x01\x12\x04\xce\x04AD\n\r\n\x05\x042\x02\x05\x03\x12\x04\xce\x04GH\
    \n\x0c\n\x02\x043\x12\x06\xd1\x04\0\xd4\x04\x01\n\x0b\n\x03\x043\x01\x12\
    \x04\xd1\x04\x082\n\x0c\n\x04\x043\x02\0\x12\x04\xd2\x04\x08'\n\r\n\x05\
    \x043\x02\0\x04\x12\x04\xd2\x04\x08\x10\n\r\n\x05\x043\x02\0\x05\x12\x04\
    \xd2\x04\x11\x17\n\r\n\x05\x043\x02\0\x01\x12\x04\xd2\x04\x18\"\n\r\n\
    \x05\x043\x02\0\x03\x12\x04\xd2\x04%&\n\x0c\n\x04\x043\x02\x01\x12\x04\
    \xd3\x04\x08(\n\r\n\x05\x043\x02\x01\x04\x12\x04\xd3\x04\x08\x10\n\r\n\
    \x05\x043\x02\x01\x05\x12\x04\xd3\x04\x11\x17\n\r\n\x05\x043\x02\x01\x01\
    \x12\x04\xd3\x04\x18#\n\r\n\x05\x043\x02\x01\x03\x12\x04\xd3\x04&'\n\x0c\
    \n\x02\x044\x12\x06\xd6\x04\0\xdc\x04\x01\n\x0b\n\x03\x044\x01\x12\x04\
    \xd6\x04\x084\n\x0c\n\x04\x044\x02\0\x12\x04\xd7\x04\x086\n\r\n\x05\x044\
    \x02\0\x04\x12\x04\xd7\x04\x08\x10\n\r\n\x05\x044\x02\0\x06\x12\x04\xd7\
    \x04\x11\x20\n\r\n\x05\x044\x02\0\x01\x12\x04\xd7\x04!1\n\r\n\x05\x044\
    \x02\0\x03\x12\x04\xd7\x0445\n\x0c\n\x04\x044\x02\x01\x12\x04\xd8\x04\
    \x08'\n\r\n\x05\x044\x02\x01\x04\x12\x04\xd8\x04\x08\x10\n\r\n\x05\x044\
    \x02\x01\x05\x12\x04\xd8\x04\x11\x17\n\r\n\x05\x044\x02\x01\x01\x12\x04\
    \xd8\x04\x18\"\n\r\n\x05\x044\x02\x01\x03\x12\x04\xd8\x04%&\n\x0c\n\x04\
    \x044\x02\x02\x12\x04\xd9\x04\x08'\n\r\n\x05\x044\x02\x02\x04\x12\x04\
    \xd9\x04\x08\x10\n\r\n\x05\x044\x02\x02\x05\x12\x04\xd9\x04\x11\x17\n\r\
    \n\x05\x044\x02\x02\x01\x12\x04\xd9\x04\x18\"\n\r\n\x05\x044\x02\x02\x03\
    \x12\x04\xd9\x04%&\n\x0c\n\x04\x044\x02\x03\x12\x04\xda\x04\x08*\n\r\n\
    \x05\x044\x02\x03\x04\x12\x04\xda\x04\x08\x10\n\r\n\x05\x044\x02\x03\x05\
    \x12\x04\xda\x04\x11\x17\n\r\n\x05\x044\x02\x03\x01\x12\x04\xda\x04\x18%\
    \n\r\n\x05\x044\x02\x03\x03\x12\x04\xda\x04()\n\x0c\n\x04\x044\x02\x04\
    \x12\x04\xdb\x04\x08,\n\r\n\x05\x044\x02\x04\x04\x12\x04\xdb\x04\x08\x10\
    \n\r\n\x05\x044\x02\x04\x05\x12\x04\xdb\x04\x11\x17\n\r\n\x05\x044\x02\
    \x04\x01\x12\x04\xdb\x04\x18'\n\r\n\x05\x044\x02\x04\x03\x12\x04\xdb\x04\
    *+\n\x0c\n\x02\x045\x12\x06\xde\x04\0\xe3\x04\x01\n\x0b\n\x03\x045\x01\
    \x12\x04\xde\x04\x08)\n\x0c\n\x04\x045\x02\0\x12\x04\xdf\x04\x08'\n\r\n\
    \x05\x045\x02\0\x04\x12\x04\xdf\x04\x08\x10\n\r\n\x05\x045\x02\0\x05\x12\
    \x04\xdf\x04\x11\x17\n\r\n\x05\x045\x02\0\x01\x12\x04\xdf\x04\x18\"\n\r\
    \n\x05\x045\x02\0\x03\x12\x04\xdf\x04%&\n\x0c\n\x04\x045\x02\x01\x12\x04\
    \xe0\x04\x08(\n\r\n\x05\x045\x02\x01\x04\x12\x04\xe0\x04\x08\x10\n\r\n\
    \x05\x045\x02\x01\x05\x12\x04\xe0\x04\x11\x17\n\r\n\x05\x045\x02\x01\x01\
    \x12\x04\xe0\x04\x18#\n\r\n\x05\x045\x02\x01\x03\x12\x04\xe0\x04&'\n\x0c\
    \n\x04\x045\x02\x02\x12\x04\xe1\x04\x08?\n\r\n\x05\x045\x02\x02\x04\x12\
    \x04\xe1\x04\x08\x10\n\r\n\x05\x045\x02\x02\x06\x12\x04\xe1\x04\x11$\n\r\
    \n\x05\x045\x02\x02\x01\x12\x04\xe1\x04%:\n\r\n\x05\x045\x02\x02\x03\x12\
    \x04\xe1\x04=>\n\x0c\n\x04\x045\x02\x03\x12\x04\xe2\x04\x08-\n\r\n\x05\
    \x045\x02\x03\x04\x12\x04\xe2\x04\x08\x10\n\r\n\x05\x045\x02\x03\x05\x12\
    \x04\xe2\x04\x11\x17\n\r\n\x05\x045\x02\x03\x01\x12\x04\xe2\x04\x18(\n\r\
    \n\x05\x045\x02\x03\x03\x12\x04\xe2\x04+,\n\x0c\n\x02\x046\x12\x06\xe5\
    \x04\0\xea\x04\x01\n\x0b\n\x03\x046\x01\x12\x04\xe5\x04\x086\n\x0c\n\x04\
    \x046\x02\0\x12\x04\xe6\x04\x083\n\r\n\x05\x046\x02\0\x04\x12\x04\xe6\
    \x04\x08\x10\n\r\n\x05\x046\x02\0\x05\x12\x04\xe6\x04\x11\x17\n\r\n\x05\
    \x046\x02\0\x01\x12\x04\xe6\x04\x18.\n\r\n\x05\x046\x02\0\x03\x12\x04\
    \xe6\x0412\n\x0c\n\x04\x046\x02\x01\x12\x04\xe7\x04\x084\n\r\n\x05\x046\
    \x02\x01\x04\x12\x04\xe7\x04\x08\x10\n\r\n\x05\x046\x02\x01\x05\x12\x04\
    \xe7\x04\x11\x17\n\r\n\x05\x046\x02\x01\x01\x12\x04\xe7\x04\x18/\n\r\n\
    \x05\x046\x02\x01\x03\x12\x04\xe7\x0423\n\x0c\n\x04\x046\x02\x02\x12\x04\
    \xe8\x04\x08'\n\r\n\x05\x046\x02\x02\x04\x12\x04\xe8\x04\x08\x10\n\r\n\
    \x05\x046\x02\x02\x05\x12\x04\xe8\x04\x11\x17\n\r\n\x05\x046\x02\x02\x01\
    \x12\x04\xe8\x04\x18\"\n\r\n\x05\x046\x02\x02\x03\x12\x04\xe8\x04%&\n\
    \x0c\n\x04\x046\x02\x03\x12\x04\xe9\x04\x08*\n\r\n\x05\x046\x02\x03\x04\
    \x12\x04\xe9\x04\x08\x10\n\r\n\x05\x046\x02\x03\x05\x12\x04\xe9\x04\x11\
    \x17\n\r\n\x05\x046\x02\x03\x01\x12\x04\xe9\x04\x18%\n\r\n\x05\x046\x02\
    \x03\x03\x12\x04\xe9\x04()\n\x0c\n\x02\x047\x12\x06\xec\x04\0\xef\x04\
    \x01\n\x0b\n\x03\x047\x01\x12\x04\xec\x04\x08)\n\x0c\n\x04\x047\x02\0\
    \x12\x04\xed\x04\x08'\n\r\n\x05\x047\x02\0\x04\x12\x04\xed\x04\x08\x10\n\
    \r\n\x05\x047\x02\0\x05\x12\x04\xed\x04\x11\x17\n\r\n\x05\x047\x02\0\x01\
    \x12\x04\xed\x04\x18\"\n\r\n\x05\x047\x02\0\x03\x12\x04\xed\x04%&\n\x0c\
    \n\x04\x047\x02\x01\x12\x04\xee\x04\x08T\n\r\n\x05\x047\x02\x01\x04\x12\
    \x04\xee\x04\x08\x10\n\r\n\x05\x047\x02\x01\x06\x12\x04\xee\x04\x11>\n\r\
    \n\x05\x047\x02\x01\x01\x12\x04\xee\x04?O\n\r\n\x05\x047\x02\x01\x03\x12\
    \x04\xee\x04RS\n\x0c\n\x02\x048\x12\x06\xf1\x04\0\xfa\x04\x01\n\x0b\n\
    \x03\x048\x01\x12\x04\xf1\x04\x084\n\x0c\n\x04\x048\x02\0\x12\x04\xf2\
    \x04\x08#\n\r\n\x05\x048\x02\0\x04\x12\x04\xf2\x04\x08\x10\n\r\n\x05\x04\
    8\x02\0\x05\x12\x04\xf2\x04\x11\x17\n\r\n\x05\x048\x02\0\x01\x12\x04\xf2\
    \x04\x18\x1e\n\r\n\x05\x048\x02\0\x03\x12\x04\xf2\x04!\"\n\x0c\n\x04\x04\
    8\x02\x01\x12\x04\xf3\x04\x08&\n\r\n\x05\x048\x02\x01\x04\x12\x04\xf3\
    \x04\x08\x10\n\r\n\x05\x048\x02\x01\x05\x12\x04\xf3\x04\x11\x17\n\r\n\
    \x05\x048\x02\x01\x01\x12\x04\xf3\x04\x18!\n\r\n\x05\x048\x02\x01\x03\
    \x12\x04\xf3\x04$%\n\x0c\n\x04\x048\x02\x02\x12\x04\xf4\x04\x08'\n\r\n\
    \x05\x048\x02\x02\x04\x12\x04\xf4\x04\x08\x10\n\r\n\x05\x048\x02\x02\x05\
    \x12\x04\xf4\x04\x11\x17\n\r\n\x05\x048\x02\x02\x01\x12\x04\xf4\x04\x18\
    \"\n\r\n\x05\x048\x02\x02\x03\x12\x04\xf4\x04%&\n\x0c\n\x04\x048\x02\x03\
    \x12\x04\xf5\x04\x08'\n\r\n\x05\x048\x02\x03\x04\x12\x04\xf5\x04\x08\x10\
    \n\r\n\x05\x048\x02\x03\x05\x12\x04\xf5\x04\x11\x17\n\r\n\x05\x048\x02\
    \x03\x01\x12\x04\xf5\x04\x18\"\n\r\n\x05\x048\x02\x03\x03\x12\x04\xf5\
    \x04%&\n\x0c\n\x04\x048\x02\x04\x12\x04\xf6\x04\x08)\n\r\n\x05\x048\x02\
    \x04\x04\x12\x04\xf6\x04\x08\x10\n\r\n\x05\x048\x02\x04\x05\x12\x04\xf6\
    \x04\x11\x17\n\r\n\x05\x048\x02\x04\x01\x12\x04\xf6\x04\x18$\n\r\n\x05\
    \x048\x02\x04\x03\x12\x04\xf6\x04'(\n\x0c\n\x04\x048\x02\x05\x12\x04\xf7\
    \x04\x08*\n\r\n\x05\x048\x02\x05\x04\x12\x04\xf7\x04\x08\x10\n\r\n\x05\
    \x048\x02\x05\x05\x12\x04\xf7\x04\x11\x17\n\r\n\x05\x048\x02\x05\x01\x12\
    \x04\xf7\x04\x18%\n\r\n\x05\x048\x02\x05\x03\x12\x04\xf7\x04()\n\x0c\n\
    \x04\x048\x02\x06\x12\x04\xf8\x04\x08)\n\r\n\x05\x048\x02\x06\x04\x12\
    \x04\xf8\x04\x08\x10\n\r\n\x05\x048\x02\x06\x05\x12\x04\xf8\x04\x11\x17\
    \n\r\n\x05\x048\x02\x06\x01\x12\x04\xf8\x04\x18$\n\r\n\x05\x048\x02\x06\
    \x03\x12\x04\xf8\x04'(\n\x0c\n\x04\x048\x02\x07\x12\x04\xf9\x04\x08#\n\r\
    \n\x05\x048\x02\x07\x04\x12\x04\xf9\x04\x08\x10\n\r\n\x05\x048\x02\x07\
    \x05\x12\x04\xf9\x04\x11\x17\n\r\n\x05\x048\x02\x07\x01\x12\x04\xf9\x04\
    \x18\x1e\n\r\n\x05\x048\x02\x07\x03\x12\x04\xf9\x04!\"\n\x0c\n\x02\x049\
    \x12\x06\xfc\x04\0\x88\x05\x01\n\x0b\n\x03\x049\x01\x12\x04\xfc\x04\x088\
    \n\x0c\n\x04\x049\x02\0\x12\x04\xfd\x04\x08#\n\r\n\x05\x049\x02\0\x04\
    \x12\x04\xfd\x04\x08\x10\n\r\n\x05\x049\x02\0\x05\x12\x04\xfd\x04\x11\
    \x17\n\r\n\x05\x049\x02\0\x01\x12\x04\xfd\x04\x18\x1e\n\r\n\x05\x049\x02\
    \0\x03\x12\x04\xfd\x04!\"\n\x0c\n\x04\x049\x02\x01\x12\x04\xfe\x04\x08$\
    \n\r\n\x05\x049\x02\x01\x04\x12\x04\xfe\x04\x08\x10\n\r\n\x05\x049\x02\
    \x01\x05\x12\x04\xfe\x04\x11\x17\n\r\n\x05\x049\x02\x01\x01\x12\x04\xfe\
    \x04\x18\x1f\n\r\n\x05\x049\x02\x01\x03\x12\x04\xfe\x04\"#\n\x0c\n\x04\
    \x049\x02\x02\x12\x04\xff\x04\x08$\n\r\n\x05\x049\x02\x02\x04\x12\x04\
    \xff\x04\x08\x10\n\r\n\x05\x049\x02\x02\x05\x12\x04\xff\x04\x11\x17\n\r\
    \n\x05\x049\x02\x02\x01\x12\x04\xff\x04\x18\x1f\n\r\n\x05\x049\x02\x02\
    \x03\x12\x04\xff\x04\"#\n\x0c\n\x04\x049\x02\x03\x12\x04\x80\x05\x08&\n\
    \r\n\x05\x049\x02\x03\x04\x12\x04\x80\x05\x08\x10\n\r\n\x05\x049\x02\x03\
    \x05\x12\x04\x80\x05\x11\x17\n\r\n\x05\x049\x02\x03\x01\x12\x04\x80\x05\
    \x18!\n\r\n\x05\x049\x02\x03\x03\x12\x04\x80\x05$%\n\x0c\n\x04\x049\x02\
    \x04\x12\x04\x81\x05\x08,\n\r\n\x05\x049\x02\x04\x04\x12\x04\x81\x05\x08\
    \x10\n\r\n\x05\x049\x02\x04\x05\x12\x04\x81\x05\x11\x17\n\r\n\x05\x049\
    \x02\x04\x01\x12\x04\x81\x05\x18'\n\r\n\x05\x049\x02\x04\x03\x12\x04\x81\
    \x05*+\n\x0c\n\x04\x049\x02\x05\x12\x04\x82\x05\x08&\n\r\n\x05\x049\x02\
    \x05\x04\x12\x04\x82\x05\x08\x10\n\r\n\x05\x049\x02\x05\x05\x12\x04\x82\
    \x05\x11\x17\n\r\n\x05\x049\x02\x05\x01\x12\x04\x82\x05\x18!\n\r\n\x05\
    \x049\x02\x05\x03\x12\x04\x82\x05$%\n\x0c\n\x04\x049\x02\x06\x12\x04\x83\
    \x05\x08'\n\r\n\x05\x049\x02\x06\x04\x12\x04\x83\x05\x08\x10\n\r\n\x05\
    \x049\x02\x06\x05\x12\x04\x83\x05\x11\x17\n\r\n\x05\x049\x02\x06\x01\x12\
    \x04\x83\x05\x18\"\n\r\n\x05\x049\x02\x06\x03\x12\x04\x83\x05%&\n\x0c\n\
    \x04\x049\x02\x07\x12\x04\x84\x05\x08&\n\r\n\x05\x049\x02\x07\x04\x12\
    \x04\x84\x05\x08\x10\n\r\n\x05\x049\x02\x07\x05\x12\x04\x84\x05\x11\x17\
    \n\r\n\x05\x049\x02\x07\x01\x12\x04\x84\x05\x18!\n\r\n\x05\x049\x02\x07\
    \x03\x12\x04\x84\x05$%\n\x0c\n\x04\x049\x02\x08\x12\x04\x85\x05\x08+\n\r\
    \n\x05\x049\x02\x08\x04\x12\x04\x85\x05\x08\x10\n\r\n\x05\x049\x02\x08\
    \x05\x12\x04\x85\x05\x11\x17\n\r\n\x05\x049\x02\x08\x01\x12\x04\x85\x05\
    \x18&\n\r\n\x05\x049\x02\x08\x03\x12\x04\x85\x05)*\n\x0c\n\x04\x049\x02\
    \t\x12\x04\x86\x05\x08.\n\r\n\x05\x049\x02\t\x04\x12\x04\x86\x05\x08\x10\
    \n\r\n\x05\x049\x02\t\x05\x12\x04\x86\x05\x11\x16\n\r\n\x05\x049\x02\t\
    \x01\x12\x04\x86\x05\x17(\n\r\n\x05\x049\x02\t\x03\x12\x04\x86\x05+-\n\
    \x0c\n\x04\x049\x02\n\x12\x04\x87\x05\x08$\n\r\n\x05\x049\x02\n\x04\x12\
    \x04\x87\x05\x08\x10\n\r\n\x05\x049\x02\n\x05\x12\x04\x87\x05\x11\x17\n\
    \r\n\x05\x049\x02\n\x01\x12\x04\x87\x05\x18\x1e\n\r\n\x05\x049\x02\n\x03\
    \x12\x04\x87\x05!#\n\x0c\n\x02\x04:\x12\x06\x8a\x05\0\x8d\x05\x01\n\x0b\
    \n\x03\x04:\x01\x12\x04\x8a\x05\x084\n\x0c\n\x04\x04:\x02\0\x12\x04\x8b\
    \x05\x08#\n\r\n\x05\x04:\x02\0\x04\x12\x04\x8b\x05\x08\x10\n\r\n\x05\x04\
    :\x02\0\x05\x12\x04\x8b\x05\x11\x17\n\r\n\x05\x04:\x02\0\x01\x12\x04\x8b\
    \x05\x18\x1e\n\r\n\x05\x04:\x02\0\x03\x12\x04\x8b\x05!\"\n\x0c\n\x04\x04\
    :\x02\x01\x12\x04\x8c\x05\x08%\n\r\n\x05\x04:\x02\x01\x04\x12\x04\x8c\
    \x05\x08\x10\n\r\n\x05\x04:\x02\x01\x05\x12\x04\x8c\x05\x11\x17\n\r\n\
    \x05\x04:\x02\x01\x01\x12\x04\x8c\x05\x18\x20\n\r\n\x05\x04:\x02\x01\x03\
    \x12\x04\x8c\x05#$\n\x0c\n\x02\x04;\x12\x06\x8f\x05\0\x92\x05\x01\n\x0b\
    \n\x03\x04;\x01\x12\x04\x8f\x05\x08&\n\x0c\n\x04\x04;\x02\0\x12\x04\x90\
    \x05\x08&\n\r\n\x05\x04;\x02\0\x04\x12\x04\x90\x05\x08\x10\n\r\n\x05\x04\
    ;\x02\0\x05\x12\x04\x90\x05\x11\x17\n\r\n\x05\x04;\x02\0\x01\x12\x04\x90\
    \x05\x18!\n\r\n\x05\x04;\x02\0\x03\x12\x04\x90\x05$%\n\x0c\n\x04\x04;\
    \x02\x01\x12\x04\x91\x05\x08#\n\r\n\x05\x04;\x02\x01\x04\x12\x04\x91\x05\
    \x08\x10\n\r\n\x05\x04;\x02\x01\x05\x12\x04\x91\x05\x11\x17\n\r\n\x05\
    \x04;\x02\x01\x01\x12\x04\x91\x05\x18\x1e\n\r\n\x05\x04;\x02\x01\x03\x12\
    \x04\x91\x05!\"\n\x0c\n\x02\x04<\x12\x06\x94\x05\0\x98\x05\x01\n\x0b\n\
    \x03\x04<\x01\x12\x04\x94\x05\x08+\n\x0c\n\x04\x04<\x02\0\x12\x04\x95\
    \x05\x08\x1f\n\r\n\x05\x04<\x02\0\x04\x12\x04\x95\x05\x08\x10\n\r\n\x05\
    \x04<\x02\0\x05\x12\x04\x95\x05\x11\x17\n\r\n\x05\x04<\x02\0\x01\x12\x04\
    \x95\x05\x18\x1a\n\r\n\x05\x04<\x02\0\x03\x12\x04\x95\x05\x1d\x1e\n\x0c\
    \n\x04\x04<\x02\x01\x12\x04\x96\x05\x08!\n\r\n\x05\x04<\x02\x01\x04\x12\
    \x04\x96\x05\x08\x10\n\r\n\x05\x04<\x02\x01\x05\x12\x04\x96\x05\x11\x17\
    \n\r\n\x05\x04<\x02\x01\x01\x12\x04\x96\x05\x18\x1c\n\r\n\x05\x04<\x02\
    \x01\x03\x12\x04\x96\x05\x1f\x20\n\x0c\n\x04\x04<\x02\x02\x12\x04\x97\
    \x05\x08#\n\r\n\x05\x04<\x02\x02\x04\x12\x04\x97\x05\x08\x10\n\r\n\x05\
    \x04<\x02\x02\x05\x12\x04\x97\x05\x11\x16\n\r\n\x05\x04<\x02\x02\x01\x12\
    \x04\x97\x05\x17\x1e\n\r\n\x05\x04<\x02\x02\x03\x12\x04\x97\x05!\"\n\x0c\
    \n\x02\x04=\x12\x06\x9a\x05\0\x9d\x05\x01\n\x0b\n\x03\x04=\x01\x12\x04\
    \x9a\x05\x08+\n\x0c\n\x04\x04=\x02\0\x12\x04\x9b\x05\x08\x1f\n\r\n\x05\
    \x04=\x02\0\x04\x12\x04\x9b\x05\x08\x10\n\r\n\x05\x04=\x02\0\x05\x12\x04\
    \x9b\x05\x11\x17\n\r\n\x05\x04=\x02\0\x01\x12\x04\x9b\x05\x18\x1a\n\r\n\
    \x05\x04=\x02\0\x03\x12\x04\x9b\x05\x1d\x1e\n\x0c\n\x04\x04=\x02\x01\x12\
    \x04\x9c\x05\x08\x20\n\r\n\x05\x04=\x02\x01\x04\x12\x04\x9c\x05\x08\x10\
    \n\r\n\x05\x04=\x02\x01\x05\x12\x04\x9c\x05\x11\x16\n\r\n\x05\x04=\x02\
    \x01\x01\x12\x04\x9c\x05\x17\x1b\n\r\n\x05\x04=\x02\x01\x03\x12\x04\x9c\
    \x05\x1e\x1f\n\x0c\n\x02\x04>\x12\x06\x9f\x05\0\xa2\x05\x01\n\x0b\n\x03\
    \x04>\x01\x12\x04\x9f\x05\x081\n\x0c\n\x04\x04>\x02\0\x12\x04\xa0\x05\
    \x08Y\n\r\n\x05\x04>\x02\0\x04\x12\x04\xa0\x05\x08\x10\n\r\n\x05\x04>\
    \x02\0\x06\x12\x04\xa0\x05\x11I\n\r\n\x05\x04>\x02\0\x01\x12\x04\xa0\x05\
    JT\n\r\n\x05\x04>\x02\0\x03\x12\x04\xa0\x05WX\n\x0c\n\x04\x04>\x02\x01\
    \x12\x04\xa1\x05\x08H\n\r\n\x05\x04>\x02\x01\x04\x12\x04\xa1\x05\x08\x10\
    \n\r\n\x05\x04>\x02\x01\x06\x12\x04\xa1\x05\x11.\n\r\n\x05\x04>\x02\x01\
    \x01\x12\x04\xa1\x05/C\n\r\n\x05\x04>\x02\x01\x03\x12\x04\xa1\x05FG\n\
    \x0c\n\x02\x04?\x12\x06\xa4\x05\0\xbd\x05\x01\n\x0b\n\x03\x04?\x01\x12\
    \x04\xa4\x05\x08!\n\x0e\n\x04\x04?\x03\0\x12\x06\xa5\x05\x08\xab\x05\t\n\
    \r\n\x05\x04?\x03\0\x01\x12\x04\xa5\x05\x10\x17\n\x0e\n\x06\x04?\x03\0\
    \x02\0\x12\x04\xa6\x05\x10)\n\x0f\n\x07\x04?\x03\0\x02\0\x04\x12\x04\xa6\
    \x05\x10\x18\n\x0f\n\x07\x04?\x03\0\x02\0\x05\x12\x04\xa6\x05\x19\x1f\n\
    \x0f\n\x07\x04?\x03\0\x02\0\x01\x12\x04\xa6\x05\x20$\n\x0f\n\x07\x04?\
    \x03\0\x02\0\x03\x12\x04\xa6\x05'(\n\x0e\n\x06\x04?\x03\0\x02\x01\x12\
    \x04\xa7\x05\x10/\n\x0f\n\x07\x04?\x03\0\x02\x01\x04\x12\x04\xa7\x05\x10\
    \x18\n\x0f\n\x07\x04?\x03\0\x02\x01\x05\x12\x04\xa7\x05\x19\x1f\n\x0f\n\
    \x07\x04?\x03\0\x02\x01\x01\x12\x04\xa7\x05\x20*\n\x0f\n\x07\x04?\x03\0\
    \x02\x01\x03\x12\x04\xa7\x05-.\n\x0e\n\x06\x04?\x03\0\x02\x02\x12\x04\
    \xa8\x05\x10(\n\x0f\n\x07\x04?\x03\0\x02\x02\x04\x12\x04\xa8\x05\x10\x18\
    \n\x0f\n\x07\x04?\x03\0\x02\x02\x05\x12\x04\xa8\x05\x19\x1e\n\x0f\n\x07\
    \x04?\x03\0\x02\x02\x01\x12\x04\xa8\x05\x1f#\n\x0f\n\x07\x04?\x03\0\x02\
    \x02\x03\x12\x04\xa8\x05&'\n\x0e\n\x06\x04?\x03\0\x02\x03\x12\x04\xa9\
    \x05\x10)\n\x0f\n\x07\x04?\x03\0\x02\x03\x04\x12\x04\xa9\x05\x10\x18\n\
    \x0f\n\x07\x04?\x03\0\x02\x03\x05\x12\x04\xa9\x05\x19\x1e\n\x0f\n\x07\
    \x04?\x03\0\x02\x03\x01\x12\x04\xa9\x05\x1f$\n\x0f\n\x07\x04?\x03\0\x02\
    \x03\x03\x12\x04\xa9\x05'(\n\x0e\n\x06\x04?\x03\0\x02\x04\x12\x04\xaa\
    \x05\x10,\n\x0f\n\x07\x04?\x03\0\x02\x04\x04\x12\x04\xaa\x05\x10\x18\n\
    \x0f\n\x07\x04?\x03\0\x02\x04\x05\x12\x04\xaa\x05\x19\x1e\n\x0f\n\x07\
    \x04?\x03\0\x02\x04\x01\x12\x04\xaa\x05\x1f'\n\x0f\n\x07\x04?\x03\0\x02\
    \x04\x03\x12\x04\xaa\x05*+\n\x0c\n\x04\x04?\x02\0\x12\x04\xad\x05\x08&\n\
    \r\n\x05\x04?\x02\0\x04\x12\x04\xad\x05\x08\x10\n\r\n\x05\x04?\x02\0\x05\
    \x12\x04\xad\x05\x11\x17\n\r\n\x05\x04?\x02\0\x01\x12\x04\xad\x05\x18!\n\
    \r\n\x05\x04?\x02\0\x03\x12\x04\xad\x05$%\n\x0c\n\x04\x04?\x02\x01\x12\
    \x04\xae\x05\x08#\n\r\n\x05\x04?\x02\x01\x04\x12\x04\xae\x05\x08\x10\n\r\
    \n\x05\x04?\x02\x01\x05\x12\x04\xae\x05\x11\x17\n\r\n\x05\x04?\x02\x01\
    \x01\x12\x04\xae\x05\x18\x1e\n\r\n\x05\x04?\x02\x01\x03\x12\x04\xae\x05!\
    \"\n\x0c\n\x04\x04?\x02\x02\x12\x04\xaf\x05\x08%\n\r\n\x05\x04?\x02\x02\
    \x04\x12\x04\xaf\x05\x08\x10\n\r\n\x05\x04?\x02\x02\x05\x12\x04\xaf\x05\
    \x11\x17\n\r\n\x05\x04?\x02\x02\x01\x12\x04\xaf\x05\x18\x20\n\r\n\x05\
    \x04?\x02\x02\x03\x12\x04\xaf\x05#$\n\x0c\n\x04\x04?\x02\x03\x12\x04\xb0\
    \x05\x08'\n\r\n\x05\x04?\x02\x03\x04\x12\x04\xb0\x05\x08\x10\n\r\n\x05\
    \x04?\x02\x03\x05\x12\x04\xb0\x05\x11\x17\n\r\n\x05\x04?\x02\x03\x01\x12\
    \x04\xb0\x05\x18\"\n\r\n\x05\x04?\x02\x03\x03\x12\x04\xb0\x05%&\n\x0c\n\
    \x04\x04?\x02\x04\x12\x04\xb1\x05\x08#\n\r\n\x05\x04?\x02\x04\x04\x12\
    \x04\xb1\x05\x08\x10\n\r\n\x05\x04?\x02\x04\x05\x12\x04\xb1\x05\x11\x17\
    \n\r\n\x05\x04?\x02\x04\x01\x12\x04\xb1\x05\x18\x1e\n\r\n\x05\x04?\x02\
    \x04\x03\x12\x04\xb1\x05!\"\n\x0c\n\x04\x04?\x02\x05\x12\x04\xb2\x05\x08\
    $\n\r\n\x05\x04?\x02\x05\x04\x12\x04\xb2\x05\x08\x10\n\r\n\x05\x04?\x02\
    \x05\x05\x12\x04\xb2\x05\x11\x17\n\r\n\x05\x04?\x02\x05\x01\x12\x04\xb2\
    \x05\x18\x1f\n\r\n\x05\x04?\x02\x05\x03\x12\x04\xb2\x05\"#\n\x0c\n\x04\
    \x04?\x02\x06\x12\x04\xb3\x05\x08&\n\r\n\x05\x04?\x02\x06\x04\x12\x04\
    \xb3\x05\x08\x10\n\r\n\x05\x04?\x02\x06\x05\x12\x04\xb3\x05\x11\x17\n\r\
    \n\x05\x04?\x02\x06\x01\x12\x04\xb3\x05\x18!\n\r\n\x05\x04?\x02\x06\x03\
    \x12\x04\xb3\x05$%\n\x0c\n\x04\x04?\x02\x07\x12\x04\xb4\x05\x08&\n\r\n\
    \x05\x04?\x02\x07\x04\x12\x04\xb4\x05\x08\x10\n\r\n\x05\x04?\x02\x07\x05\
    \x12\x04\xb4\x05\x11\x17\n\r\n\x05\x04?\x02\x07\x01\x12\x04\xb4\x05\x18!\
    \n\r\n\x05\x04?\x02\x07\x03\x12\x04\xb4\x05$%\n\x0c\n\x04\x04?\x02\x08\
    \x12\x04\xb5\x05\x08/\n\r\n\x05\x04?\x02\x08\x04\x12\x04\xb5\x05\x08\x10\
    \n\r\n\x05\x04?\x02\x08\x05\x12\x04\xb5\x05\x11\x17\n\r\n\x05\x04?\x02\
    \x08\x01\x12\x04\xb5\x05\x18*\n\r\n\x05\x04?\x02\x08\x03\x12\x04\xb5\x05\
    -.\n\x0c\n\x04\x04?\x02\t\x12\x04\xb6\x05\x08,\n\r\n\x05\x04?\x02\t\x04\
    \x12\x04\xb6\x05\x08\x10\n\r\n\x05\x04?\x02\t\x05\x12\x04\xb6\x05\x11\
    \x17\n\r\n\x05\x04?\x02\t\x01\x12\x04\xb6\x05\x18&\n\r\n\x05\x04?\x02\t\
    \x03\x12\x04\xb6\x05)+\n\x0c\n\x04\x04?\x02\n\x12\x04\xb7\x05\x08(\n\r\n\
    \x05\x04?\x02\n\x04\x12\x04\xb7\x05\x08\x10\n\r\n\x05\x04?\x02\n\x05\x12\
    \x04\xb7\x05\x11\x17\n\r\n\x05\x04?\x02\n\x01\x12\x04\xb7\x05\x18\"\n\r\
    \n\x05\x04?\x02\n\x03\x12\x04\xb7\x05%'\n\x0c\n\x04\x04?\x02\x0b\x12\x04\
    \xb8\x05\x08B\n\r\n\x05\x04?\x02\x0b\x04\x12\x04\xb8\x05\x08\x10\n\r\n\
    \x05\x04?\x02\x0b\x06\x12\x04\xb8\x05\x113\n\r\n\x05\x04?\x02\x0b\x01\
    \x12\x04\xb8\x054<\n\r\n\x05\x04?\x02\x0b\x03\x12\x04\xb8\x05?A\n\x0c\n\
    \x04\x04?\x02\x0c\x12\x04\xb9\x05\x08'\n\r\n\x05\x04?\x02\x0c\x04\x12\
    \x04\xb9\x05\x08\x10\n\r\n\x05\x04?\x02\x0c\x05\x12\x04\xb9\x05\x11\x17\
    \n\r\n\x05\x04?\x02\x0c\x01\x12\x04\xb9\x05\x18!\n\r\n\x05\x04?\x02\x0c\
    \x03\x12\x04\xb9\x05$&\n\x0c\n\x04\x04?\x02\r\x12\x04\xba\x05\x08$\n\r\n\
    \x05\x04?\x02\r\x04\x12\x04\xba\x05\x08\x10\n\r\n\x05\x04?\x02\r\x05\x12\
    \x04\xba\x05\x11\x17\n\r\n\x05\x04?\x02\r\x01\x12\x04\xba\x05\x18\x1e\n\
    \r\n\x05\x04?\x02\r\x03\x12\x04\xba\x05!#\n\x0c\n\x04\x04?\x02\x0e\x12\
    \x04\xbb\x05\x08%\n\r\n\x05\x04?\x02\x0e\x04\x12\x04\xbb\x05\x08\x10\n\r\
    \n\x05\x04?\x02\x0e\x05\x12\x04\xbb\x05\x11\x17\n\r\n\x05\x04?\x02\x0e\
    \x01\x12\x04\xbb\x05\x18\x1f\n\r\n\x05\x04?\x02\x0e\x03\x12\x04\xbb\x05\
    \"$\n\x0c\n\x04\x04?\x02\x0f\x12\x04\xbc\x05\x08(\n\r\n\x05\x04?\x02\x0f\
    \x04\x12\x04\xbc\x05\x08\x10\n\r\n\x05\x04?\x02\x0f\x05\x12\x04\xbc\x05\
    \x11\x17\n\r\n\x05\x04?\x02\x0f\x01\x12\x04\xbc\x05\x18\"\n\r\n\x05\x04?\
    \x02\x0f\x03\x12\x04\xbc\x05%'\n\x0c\n\x02\x04@\x12\x06\xbf\x05\0\xc1\
    \x05\x01\n\x0b\n\x03\x04@\x01\x12\x04\xbf\x05\x08:\n\x0c\n\x04\x04@\x02\
    \0\x12\x04\xc0\x05\x089\n\r\n\x05\x04@\x02\0\x04\x12\x04\xc0\x05\x08\x10\
    \n\r\n\x05\x04@\x02\0\x06\x12\x04\xc0\x05\x11+\n\r\n\x05\x04@\x02\0\x01\
    \x12\x04\xc0\x05,4\n\r\n\x05\x04@\x02\0\x03\x12\x04\xc0\x0578\n\x0c\n\
    \x02\x04A\x12\x06\xc3\x05\0\xc5\x05\x01\n\x0b\n\x03\x04A\x01\x12\x04\xc3\
    \x05\x08\x1c\n\x0c\n\x04\x04A\x02\0\x12\x04\xc4\x05\x089\n\r\n\x05\x04A\
    \x02\0\x04\x12\x04\xc4\x05\x08\x10\n\r\n\x05\x04A\x02\0\x06\x12\x04\xc4\
    \x05\x11+\n\r\n\x05\x04A\x02\0\x01\x12\x04\xc4\x05,4\n\r\n\x05\x04A\x02\
    \0\x03\x12\x04\xc4\x0578\n\x0c\n\x02\x04B\x12\x06\xc7\x05\0\xcc\x05\x01\
    \n\x0b\n\x03\x04B\x01\x12\x04\xc7\x05\x08?\n\x0c\n\x04\x04B\x02\0\x12\
    \x04\xc8\x05\x08$\n\r\n\x05\x04B\x02\0\x04\x12\x04\xc8\x05\x08\x10\n\r\n\
    \x05\x04B\x02\0\x05\x12\x04\xc8\x05\x11\x17\n\r\n\x05\x04B\x02\0\x01\x12\
    \x04\xc8\x05\x18\x1f\n\r\n\x05\x04B\x02\0\x03\x12\x04\xc8\x05\"#\n\x0c\n\
    \x04\x04B\x02\x01\x12\x04\xc9\x05\x08$\n\r\n\x05\x04B\x02\x01\x04\x12\
    \x04\xc9\x05\x08\x10\n\r\n\x05\x04B\x02\x01\x05\x12\x04\xc9\x05\x11\x17\
    \n\r\n\x05\x04B\x02\x01\x01\x12\x04\xc9\x05\x18\x1f\n\r\n\x05\x04B\x02\
    \x01\x03\x12\x04\xc9\x05\"#\n\x0c\n\x04\x04B\x02\x02\x12\x04\xca\x05\x08\
    $\n\r\n\x05\x04B\x02\x02\x04\x12\x04\xca\x05\x08\x10\n\r\n\x05\x04B\x02\
    \x02\x05\x12\x04\xca\x05\x11\x17\n\r\n\x05\x04B\x02\x02\x01\x12\x04\xca\
    \x05\x18\x1f\n\r\n\x05\x04B\x02\x02\x03\x12\x04\xca\x05\"#\n\x0c\n\x04\
    \x04B\x02\x03\x12\x04\xcb\x05\x08$\n\r\n\x05\x04B\x02\x03\x04\x12\x04\
    \xcb\x05\x08\x10\n\r\n\x05\x04B\x02\x03\x05\x12\x04\xcb\x05\x11\x17\n\r\
    \n\x05\x04B\x02\x03\x01\x12\x04\xcb\x05\x18\x1f\n\r\n\x05\x04B\x02\x03\
    \x03\x12\x04\xcb\x05\"#\n\x0c\n\x02\x04C\x12\x06\xce\x05\0\xd0\x05\x01\n\
    \x0b\n\x03\x04C\x01\x12\x04\xce\x05\x08@\n\x0c\n\x04\x04C\x02\0\x12\x04\
    \xcf\x05\x089\n\r\n\x05\x04C\x02\0\x04\x12\x04\xcf\x05\x08\x10\n\r\n\x05\
    \x04C\x02\0\x06\x12\x04\xcf\x05\x11+\n\r\n\x05\x04C\x02\0\x01\x12\x04\
    \xcf\x05,4\n\r\n\x05\x04C\x02\0\x03\x12\x04\xcf\x0578\n\x0c\n\x02\x04D\
    \x12\x06\xd2\x05\0\xd6\x05\x01\n\x0b\n\x03\x04D\x01\x12\x04\xd2\x05\x08A\
    \n\x0c\n\x04\x04D\x02\0\x12\x04\xd3\x05\x08%\n\r\n\x05\x04D\x02\0\x04\
    \x12\x04\xd3\x05\x08\x10\n\r\n\x05\x04D\x02\0\x05\x12\x04\xd3\x05\x11\
    \x17\n\r\n\x05\x04D\x02\0\x01\x12\x04\xd3\x05\x18\x20\n\r\n\x05\x04D\x02\
    \0\x03\x12\x04\xd3\x05#$\n\x0c\n\x04\x04D\x02\x01\x12\x04\xd4\x05\x08%\n\
    \r\n\x05\x04D\x02\x01\x04\x12\x04\xd4\x05\x08\x10\n\r\n\x05\x04D\x02\x01\
    \x05\x12\x04\xd4\x05\x11\x17\n\r\n\x05\x04D\x02\x01\x01\x12\x04\xd4\x05\
    \x18\x20\n\r\n\x05\x04D\x02\x01\x03\x12\x04\xd4\x05#$\n\x0c\n\x04\x04D\
    \x02\x02\x12\x04\xd5\x05\x08'\n\r\n\x05\x04D\x02\x02\x04\x12\x04\xd5\x05\
    \x08\x10\n\r\n\x05\x04D\x02\x02\x05\x12\x04\xd5\x05\x11\x17\n\r\n\x05\
    \x04D\x02\x02\x01\x12\x04\xd5\x05\x18\"\n\r\n\x05\x04D\x02\x02\x03\x12\
    \x04\xd5\x05%&\n\x0c\n\x02\x04E\x12\x06\xd8\x05\0\xd9\x05\x01\n\x0b\n\
    \x03\x04E\x01\x12\x04\xd8\x05\x08;\n\x0c\n\x02\x04F\x12\x06\xdb\x05\0\
    \xdd\x05\x01\n\x0b\n\x03\x04F\x01\x12\x04\xdb\x05\x08:\n\x0c\n\x04\x04F\
    \x02\0\x12\x04\xdc\x05\x08&\n\r\n\x05\x04F\x02\0\x04\x12\x04\xdc\x05\x08\
    \x10\n\r\n\x05\x04F\x02\0\x05\x12\x04\xdc\x05\x11\x17\n\r\n\x05\x04F\x02\
    \0\x01\x12\x04\xdc\x05\x18!\n\r\n\x05\x04F\x02\0\x03\x12\x04\xdc\x05$%\n\
    \x0c\n\x02\x04G\x12\x06\xdf\x05\0\xe1\x05\x01\n\x0b\n\x03\x04G\x01\x12\
    \x04\xdf\x05\x08:\n\x0c\n\x04\x04G\x02\0\x12\x04\xe0\x05\x08&\n\r\n\x05\
    \x04G\x02\0\x04\x12\x04\xe0\x05\x08\x10\n\r\n\x05\x04G\x02\0\x05\x12\x04\
    \xe0\x05\x11\x17\n\r\n\x05\x04G\x02\0\x01\x12\x04\xe0\x05\x18!\n\r\n\x05\
    \x04G\x02\0\x03\x12\x04\xe0\x05$%\n\x0c\n\x02\x04H\x12\x06\xe3\x05\0\xe5\
    \x05\x01\n\x0b\n\x03\x04H\x01\x12\x04\xe3\x05\x08:\n\x0c\n\x04\x04H\x02\
    \0\x12\x04\xe4\x05\x08#\n\r\n\x05\x04H\x02\0\x04\x12\x04\xe4\x05\x08\x10\
    \n\r\n\x05\x04H\x02\0\x05\x12\x04\xe4\x05\x11\x16\n\r\n\x05\x04H\x02\0\
    \x01\x12\x04\xe4\x05\x17\x1e\n\r\n\x05\x04H\x02\0\x03\x12\x04\xe4\x05!\"\
    \n\x0c\n\x02\x04I\x12\x06\xe7\x05\0\xeb\x05\x01\n\x0b\n\x03\x04I\x01\x12\
    \x04\xe7\x05\x087\n\x0c\n\x04\x04I\x02\0\x12\x04\xe8\x05\x08$\n\r\n\x05\
    \x04I\x02\0\x04\x12\x04\xe8\x05\x08\x10\n\r\n\x05\x04I\x02\0\x05\x12\x04\
    \xe8\x05\x11\x17\n\r\n\x05\x04I\x02\0\x01\x12\x04\xe8\x05\x18\x1f\n\r\n\
    \x05\x04I\x02\0\x03\x12\x04\xe8\x05\"#\n\x0c\n\x04\x04I\x02\x01\x12\x04\
    \xe9\x05\x08&\n\r\n\x05\x04I\x02\x01\x04\x12\x04\xe9\x05\x08\x10\n\r\n\
    \x05\x04I\x02\x01\x05\x12\x04\xe9\x05\x11\x17\n\r\n\x05\x04I\x02\x01\x01\
    \x12\x04\xe9\x05\x18!\n\r\n\x05\x04I\x02\x01\x03\x12\x04\xe9\x05$%\n\x0c\
    \n\x04\x04I\x02\x02\x12\x04\xea\x05\x08\"\n\r\n\x05\x04I\x02\x02\x04\x12\
    \x04\xea\x05\x08\x10\n\r\n\x05\x04I\x02\x02\x05\x12\x04\xea\x05\x11\x17\
    \n\r\n\x05\x04I\x02\x02\x01\x12\x04\xea\x05\x18\x1d\n\r\n\x05\x04I\x02\
    \x02\x03\x12\x04\xea\x05\x20!\n\x0c\n\x02\x04J\x12\x06\xed\x05\0\xf3\x05\
    \x01\n\x0b\n\x03\x04J\x01\x12\x04\xed\x05\x08%\n\x0c\n\x04\x04J\x02\0\
    \x12\x04\xee\x05\x08$\n\r\n\x05\x04J\x02\0\x04\x12\x04\xee\x05\x08\x10\n\
    \r\n\x05\x04J\x02\0\x05\x12\x04\xee\x05\x11\x17\n\r\n\x05\x04J\x02\0\x01\
    \x12\x04\xee\x05\x18\x1f\n\r\n\x05\x04J\x02\0\x03\x12\x04\xee\x05\"#\n\
    \x0c\n\x04\x04J\x02\x01\x12\x04\xef\x05\x08&\n\r\n\x05\x04J\x02\x01\x04\
    \x12\x04\xef\x05\x08\x10\n\r\n\x05\x04J\x02\x01\x05\x12\x04\xef\x05\x11\
    \x17\n\r\n\x05\x04J\x02\x01\x01\x12\x04\xef\x05\x18!\n\r\n\x05\x04J\x02\
    \x01\x03\x12\x04\xef\x05$%\n\x0c\n\x04\x04J\x02\x02\x12\x04\xf0\x05\x08<\
    \n\r\n\x05\x04J\x02\x02\x04\x12\x04\xf0\x05\x08\x10\n\r\n\x05\x04J\x02\
    \x02\x06\x12\x04\xf0\x05\x11$\n\r\n\x05\x04J\x02\x02\x01\x12\x04\xf0\x05\
    %7\n\r\n\x05\x04J\x02\x02\x03\x12\x04\xf0\x05:;\n\x0c\n\x04\x04J\x02\x03\
    \x12\x04\xf1\x05\x08W\n\r\n\x05\x04J\x02\x03\x04\x12\x04\xf1\x05\x08\x10\
    \n\r\n\x05\x04J\x02\x03\x06\x12\x04\xf1\x05\x11@\n\r\n\x05\x04J\x02\x03\
    \x01\x12\x04\xf1\x05AR\n\r\n\x05\x04J\x02\x03\x03\x12\x04\xf1\x05UV\n\
    \x0c\n\x04\x04J\x02\x04\x12\x04\xf2\x05\x08S\n\r\n\x05\x04J\x02\x04\x04\
    \x12\x04\xf2\x05\x08\x10\n\r\n\x05\x04J\x02\x04\x06\x12\x04\xf2\x05\x11@\
    \n\r\n\x05\x04J\x02\x04\x01\x12\x04\xf2\x05AN\n\r\n\x05\x04J\x02\x04\x03\
    \x12\x04\xf2\x05QR\n\x0c\n\x02\x04K\x12\x06\xf5\x05\0\xf9\x05\x01\n\x0b\
    \n\x03\x04K\x01\x12\x04\xf5\x05\x08/\n\x0c\n\x04\x04K\x02\0\x12\x04\xf6\
    \x05\x08#\n\r\n\x05\x04K\x02\0\x04\x12\x04\xf6\x05\x08\x10\n\r\n\x05\x04\
    K\x02\0\x05\x12\x04\xf6\x05\x11\x16\n\r\n\x05\x04K\x02\0\x01\x12\x04\xf6\
    \x05\x17\x1e\n\r\n\x05\x04K\x02\0\x03\x12\x04\xf6\x05!\"\n\x0c\n\x04\x04\
    K\x02\x01\x12\x04\xf7\x05\x08!\n\r\n\x05\x04K\x02\x01\x04\x12\x04\xf7\
    \x05\x08\x10\n\r\n\x05\x04K\x02\x01\x05\x12\x04\xf7\x05\x11\x16\n\r\n\
    \x05\x04K\x02\x01\x01\x12\x04\xf7\x05\x17\x1c\n\r\n\x05\x04K\x02\x01\x03\
    \x12\x04\xf7\x05\x1f\x20\n\x0c\n\x04\x04K\x02\x02\x12\x04\xf8\x05\x08&\n\
    \r\n\x05\x04K\x02\x02\x04\x12\x04\xf8\x05\x08\x10\n\r\n\x05\x04K\x02\x02\
    \x05\x12\x04\xf8\x05\x11\x15\n\r\n\x05\x04K\x02\x02\x01\x12\x04\xf8\x05\
    \x16!\n\r\n\x05\x04K\x02\x02\x03\x12\x04\xf8\x05$%\n\x0c\n\x02\x04L\x12\
    \x06\xfb\x05\0\x8a\x06\x01\n\x0b\n\x03\x04L\x01\x12\x04\xfb\x05\x08+\n\
    \x0e\n\x04\x04L\x03\0\x12\x06\xfc\x05\x08\xfe\x05\t\n\r\n\x05\x04L\x03\0\
    \x01\x12\x04\xfc\x05\x10\x15\n\x0e\n\x06\x04L\x03\0\x02\0\x12\x04\xfd\
    \x05\x10+\n\x0f\n\x07\x04L\x03\0\x02\0\x04\x12\x04\xfd\x05\x10\x18\n\x0f\
    \n\x07\x04L\x03\0\x02\0\x05\x12\x04\xfd\x05\x19\x1e\n\x0f\n\x07\x04L\x03\
    \0\x02\0\x01\x12\x04\xfd\x05\x1f&\n\x0f\n\x07\x04L\x03\0\x02\0\x03\x12\
    \x04\xfd\x05)*\n\x0c\n\x04\x04L\x02\0\x12\x04\x80\x06\x08$\n\r\n\x05\x04\
    L\x02\0\x04\x12\x04\x80\x06\x08\x10\n\r\n\x05\x04L\x02\0\x05\x12\x04\x80\
    \x06\x11\x17\n\r\n\x05\x04L\x02\0\x01\x12\x04\x80\x06\x18\x1f\n\r\n\x05\
    \x04L\x02\0\x03\x12\x04\x80\x06\"#\n\x0c\n\x04\x04L\x02\x01\x12\x04\x81\
    \x06\x08!\n\r\n\x05\x04L\x02\x01\x04\x12\x04\x81\x06\x08\x10\n\r\n\x05\
    \x04L\x02\x01\x05\x12\x04\x81\x06\x11\x17\n\r\n\x05\x04L\x02\x01\x01\x12\
    \x04\x81\x06\x18\x1c\n\r\n\x05\x04L\x02\x01\x03\x12\x04\x81\x06\x1f\x20\
    \n\x0c\n\x04\x04L\x02\x02\x12\x04\x82\x06\x08!\n\r\n\x05\x04L\x02\x02\
    \x04\x12\x04\x82\x06\x08\x10\n\r\n\x05\x04L\x02\x02\x05\x12\x04\x82\x06\
    \x11\x17\n\r\n\x05\x04L\x02\x02\x01\x12\x04\x82\x06\x18\x1c\n\r\n\x05\
    \x04L\x02\x02\x03\x12\x04\x82\x06\x1f\x20\n\x0c\n\x04\x04L\x02\x03\x12\
    \x04\x83\x06\x08.\n\r\n\x05\x04L\x02\x03\x04\x12\x04\x83\x06\x08\x10\n\r\
    \n\x05\x04L\x02\x03\x05\x12\x04\x83\x06\x11\x17\n\r\n\x05\x04L\x02\x03\
    \x01\x12\x04\x83\x06\x18)\n\r\n\x05\x04L\x02\x03\x03\x12\x04\x83\x06,-\n\
    \x0c\n\x04\x04L\x02\x04\x12\x04\x84\x06\x08D\n\r\n\x05\x04L\x02\x04\x04\
    \x12\x04\x84\x06\x08\x10\n\r\n\x05\x04L\x02\x04\x06\x12\x04\x84\x06\x119\
    \n\r\n\x05\x04L\x02\x04\x01\x12\x04\x84\x06:?\n\r\n\x05\x04L\x02\x04\x03\
    \x12\x04\x84\x06BC\n\x0c\n\x04\x04L\x02\x05\x12\x04\x85\x06\x08%\n\r\n\
    \x05\x04L\x02\x05\x04\x12\x04\x85\x06\x08\x10\n\r\n\x05\x04L\x02\x05\x05\
    \x12\x04\x85\x06\x11\x16\n\r\n\x05\x04L\x02\x05\x01\x12\x04\x85\x06\x17\
    \x20\n\r\n\x05\x04L\x02\x05\x03\x12\x04\x85\x06#$\n\x0c\n\x04\x04L\x02\
    \x06\x12\x04\x86\x06\x08.\n\r\n\x05\x04L\x02\x06\x04\x12\x04\x86\x06\x08\
    \x10\n\r\n\x05\x04L\x02\x06\x05\x12\x04\x86\x06\x11\x17\n\r\n\x05\x04L\
    \x02\x06\x01\x12\x04\x86\x06\x18)\n\r\n\x05\x04L\x02\x06\x03\x12\x04\x86\
    \x06,-\n\x0c\n\x04\x04L\x02\x07\x12\x04\x87\x06\x08*\n\r\n\x05\x04L\x02\
    \x07\x04\x12\x04\x87\x06\x08\x10\n\r\n\x05\x04L\x02\x07\x05\x12\x04\x87\
    \x06\x11\x17\n\r\n\x05\x04L\x02\x07\x01\x12\x04\x87\x06\x18%\n\r\n\x05\
    \x04L\x02\x07\x03\x12\x04\x87\x06()\n\x0c\n\x04\x04L\x02\x08\x12\x04\x88\
    \x06\x08,\n\r\n\x05\x04L\x02\x08\x04\x12\x04\x88\x06\x08\x10\n\r\n\x05\
    \x04L\x02\x08\x05\x12\x04\x88\x06\x11\x17\n\r\n\x05\x04L\x02\x08\x01\x12\
    \x04\x88\x06\x18'\n\r\n\x05\x04L\x02\x08\x03\x12\x04\x88\x06*+\n\x0c\n\
    \x04\x04L\x02\t\x12\x04\x89\x06\x08G\n\r\n\x05\x04L\x02\t\x04\x12\x04\
    \x89\x06\x08\x10\n\r\n\x05\x04L\x02\t\x06\x12\x04\x89\x06\x11;\n\r\n\x05\
    \x04L\x02\t\x01\x12\x04\x89\x06<A\n\r\n\x05\x04L\x02\t\x03\x12\x04\x89\
    \x06DF\n\x0c\n\x02\x04M\x12\x06\x8c\x06\0\x91\x06\x01\n\x0b\n\x03\x04M\
    \x01\x12\x04\x8c\x06\x08-\n\x0c\n\x04\x04M\x02\0\x12\x04\x8d\x06\x08&\n\
    \r\n\x05\x04M\x02\0\x04\x12\x04\x8d\x06\x08\x10\n\r\n\x05\x04M\x02\0\x05\
    \x12\x04\x8d\x06\x11\x17\n\r\n\x05\x04M\x02\0\x01\x12\x04\x8d\x06\x18!\n\
    \r\n\x05\x04M\x02\0\x03\x12\x04\x8d\x06$%\n\x0c\n\x04\x04M\x02\x01\x12\
    \x04\x8e\x06\x08!\n\r\n\x05\x04M\x02\x01\x04\x12\x04\x8e\x06\x08\x10\n\r\
    \n\x05\x04M\x02\x01\x05\x12\x04\x8e\x06\x11\x17\n\r\n\x05\x04M\x02\x01\
    \x01\x12\x04\x8e\x06\x18\x1c\n\r\n\x05\x04M\x02\x01\x03\x12\x04\x8e\x06\
    \x1f\x20\n\x0c\n\x04\x04M\x02\x02\x12\x04\x8f\x06\x08!\n\r\n\x05\x04M\
    \x02\x02\x04\x12\x04\x8f\x06\x08\x10\n\r\n\x05\x04M\x02\x02\x05\x12\x04\
    \x8f\x06\x11\x17\n\r\n\x05\x04M\x02\x02\x01\x12\x04\x8f\x06\x18\x1c\n\r\
    \n\x05\x04M\x02\x02\x03\x12\x04\x8f\x06\x1f\x20\n\x0c\n\x04\x04M\x02\x03\
    \x12\x04\x90\x06\x08A\n\r\n\x05\x04M\x02\x03\x04\x12\x04\x90\x06\x08\x10\
    \n\r\n\x05\x04M\x02\x03\x06\x12\x04\x90\x06\x115\n\r\n\x05\x04M\x02\x03\
    \x01\x12\x04\x90\x066<\n\r\n\x05\x04M\x02\x03\x03\x12\x04\x90\x06?@\n\
    \x0c\n\x02\x04N\x12\x06\x93\x06\0\x97\x06\x01\n\x0b\n\x03\x04N\x01\x12\
    \x04\x93\x06\x08*\n\x0c\n\x04\x04N\x02\0\x12\x04\x94\x06\x08E\n\r\n\x05\
    \x04N\x02\0\x04\x12\x04\x94\x06\x08\x10\n\r\n\x05\x04N\x02\0\x06\x12\x04\
    \x94\x06\x117\n\r\n\x05\x04N\x02\0\x01\x12\x04\x94\x068@\n\r\n\x05\x04N\
    \x02\0\x03\x12\x04\x94\x06CD\n\x0c\n\x04\x04N\x02\x01\x12\x04\x95\x06\
    \x087\n\r\n\x05\x04N\x02\x01\x04\x12\x04\x95\x06\x08\x10\n\r\n\x05\x04N\
    \x02\x01\x06\x12\x04\x95\x06\x11!\n\r\n\x05\x04N\x02\x01\x01\x12\x04\x95\
    \x06\"2\n\r\n\x05\x04N\x02\x01\x03\x12\x04\x95\x0656\n\x0c\n\x04\x04N\
    \x02\x02\x12\x04\x96\x06\x086\n\r\n\x05\x04N\x02\x02\x04\x12\x04\x96\x06\
    \x08\x10\n\r\n\x05\x04N\x02\x02\x06\x12\x04\x96\x06\x11\x20\n\r\n\x05\
    \x04N\x02\x02\x01\x12\x04\x96\x06!1\n\r\n\x05\x04N\x02\x02\x03\x12\x04\
    \x96\x0645\n\x0c\n\x02\x04O\x12\x06\x99\x06\0\xa0\x06\x01\n\x0b\n\x03\
    \x04O\x01\x12\x04\x99\x06\x08$\n\x0c\n\x04\x04O\x02\0\x12\x04\x9a\x06\
    \x08)\n\r\n\x05\x04O\x02\0\x04\x12\x04\x9a\x06\x08\x10\n\r\n\x05\x04O\
    \x02\0\x05\x12\x04\x9a\x06\x11\x17\n\r\n\x05\x04O\x02\0\x01\x12\x04\x9a\
    \x06\x18$\n\r\n\x05\x04O\x02\0\x03\x12\x04\x9a\x06'(\n\x0c\n\x04\x04O\
    \x02\x01\x12\x04\x9b\x06\x08&\n\r\n\x05\x04O\x02\x01\x04\x12\x04\x9b\x06\
    \x08\x10\n\r\n\x05\x04O\x02\x01\x05\x12\x04\x9b\x06\x11\x17\n\r\n\x05\
    \x04O\x02\x01\x01\x12\x04\x9b\x06\x18!\n\r\n\x05\x04O\x02\x01\x03\x12\
    \x04\x9b\x06$%\n\x0c\n\x04\x04O\x02\x02\x12\x04\x9c\x06\x08'\n\r\n\x05\
    \x04O\x02\x02\x04\x12\x04\x9c\x06\x08\x10\n\r\n\x05\x04O\x02\x02\x05\x12\
    \x04\x9c\x06\x11\x17\n\r\n\x05\x04O\x02\x02\x01\x12\x04\x9c\x06\x18\"\n\
    \r\n\x05\x04O\x02\x02\x03\x12\x04\x9c\x06%&\n\x0c\n\x04\x04O\x02\x03\x12\
    \x04\x9d\x06\x08<\n\r\n\x05\x04O\x02\x03\x04\x12\x04\x9d\x06\x08\x10\n\r\
    \n\x05\x04O\x02\x03\x06\x12\x04\x9d\x06\x11/\n\r\n\x05\x04O\x02\x03\x01\
    \x12\x04\x9d\x0607\n\r\n\x05\x04O\x02\x03\x03\x12\x04\x9d\x06:;\n\x0c\n\
    \x04\x04O\x02\x04\x12\x04\x9e\x06\x08-\n\r\n\x05\x04O\x02\x04\x04\x12\
    \x04\x9e\x06\x08\x10\n\r\n\x05\x04O\x02\x04\x06\x12\x04\x9e\x06\x11\x20\
    \n\r\n\x05\x04O\x02\x04\x01\x12\x04\x9e\x06!(\n\r\n\x05\x04O\x02\x04\x03\
    \x12\x04\x9e\x06+,\n\x0c\n\x04\x04O\x02\x05\x12\x04\x9f\x06\x08H\n\r\n\
    \x05\x04O\x02\x05\x04\x12\x04\x9f\x06\x08\x10\n\r\n\x05\x04O\x02\x05\x06\
    \x12\x04\x9f\x06\x114\n\r\n\x05\x04O\x02\x05\x01\x12\x04\x9f\x065C\n\r\n\
    \x05\x04O\x02\x05\x03\x12\x04\x9f\x06FG\n\x0c\n\x02\x04P\x12\x06\xa2\x06\
    \0\xad\x06\x01\n\x0b\n\x03\x04P\x01\x12\x04\xa2\x06\x08&\n\x0e\n\x04\x04\
    P\x03\0\x12\x06\xa3\x06\x08\xa9\x06\t\n\r\n\x05\x04P\x03\0\x01\x12\x04\
    \xa3\x06\x10\"\n\x0e\n\x06\x04P\x03\0\x02\0\x12\x04\xa4\x06\x10-\n\x0f\n\
    \x07\x04P\x03\0\x02\0\x04\x12\x04\xa4\x06\x10\x18\n\x0f\n\x07\x04P\x03\0\
    \x02\0\x05\x12\x04\xa4\x06\x19\x1e\n\x0f\n\x07\x04P\x03\0\x02\0\x01\x12\
    \x04\xa4\x06\x1f(\n\x0f\n\x07\x04P\x03\0\x02\0\x03\x12\x04\xa4\x06+,\n\
    \x0e\n\x06\x04P\x03\0\x02\x01\x12\x04\xa5\x06\x10+\n\x0f\n\x07\x04P\x03\
    \0\x02\x01\x04\x12\x04\xa5\x06\x10\x18\n\x0f\n\x07\x04P\x03\0\x02\x01\
    \x05\x12\x04\xa5\x06\x19\x1e\n\x0f\n\x07\x04P\x03\0\x02\x01\x01\x12\x04\
    \xa5\x06\x1f&\n\x0f\n\x07\x04P\x03\0\x02\x01\x03\x12\x04\xa5\x06)*\n\x0e\
    \n\x06\x04P\x03\0\x02\x02\x12\x04\xa6\x06\x10)\n\x0f\n\x07\x04P\x03\0\
    \x02\x02\x04\x12\x04\xa6\x06\x10\x18\n\x0f\n\x07\x04P\x03\0\x02\x02\x05\
    \x12\x04\xa6\x06\x19\x1e\n\x0f\n\x07\x04P\x03\0\x02\x02\x01\x12\x04\xa6\
    \x06\x1f$\n\x0f\n\x07\x04P\x03\0\x02\x02\x03\x12\x04\xa6\x06'(\n\x0e\n\
    \x06\x04P\x03\0\x02\x03\x12\x04\xa7\x06\x10*\n\x0f\n\x07\x04P\x03\0\x02\
    \x03\x04\x12\x04\xa7\x06\x10\x18\n\x0f\n\x07\x04P\x03\0\x02\x03\x05\x12\
    \x04\xa7\x06\x19\x1e\n\x0f\n\x07\x04P\x03\0\x02\x03\x01\x12\x04\xa7\x06\
    \x1f%\n\x0f\n\x07\x04P\x03\0\x02\x03\x03\x12\x04\xa7\x06()\n\x0e\n\x06\
    \x04P\x03\0\x02\x04\x12\x04\xa8\x06\x10+\n\x0f\n\x07\x04P\x03\0\x02\x04\
    \x04\x12\x04\xa8\x06\x10\x18\n\x0f\n\x07\x04P\x03\0\x02\x04\x05\x12\x04\
    \xa8\x06\x19\x1f\n\x0f\n\x07\x04P\x03\0\x02\x04\x01\x12\x04\xa8\x06\x20&\
    \n\x0f\n\x07\x04P\x03\0\x02\x04\x03\x12\x04\xa8\x06)*\n\x0c\n\x04\x04P\
    \x02\0\x12\x04\xab\x06\x08%\n\r\n\x05\x04P\x02\0\x04\x12\x04\xab\x06\x08\
    \x10\n\r\n\x05\x04P\x02\0\x05\x12\x04\xab\x06\x11\x17\n\r\n\x05\x04P\x02\
    \0\x01\x12\x04\xab\x06\x18\x20\n\r\n\x05\x04P\x02\0\x03\x12\x04\xab\x06#\
    $\n\x0c\n\x04\x04P\x02\x01\x12\x04\xac\x06\x08_\n\r\n\x05\x04P\x02\x01\
    \x04\x12\x04\xac\x06\x08\x10\n\r\n\x05\x04P\x02\x01\x06\x12\x04\xac\x06\
    \x11C\n\r\n\x05\x04P\x02\x01\x01\x12\x04\xac\x06DZ\n\r\n\x05\x04P\x02\
    \x01\x03\x12\x04\xac\x06]^\n\x0c\n\x02\x04Q\x12\x06\xaf\x06\0\xbd\x06\
    \x01\n\x0b\n\x03\x04Q\x01\x12\x04\xaf\x06\x08\"\n\x0e\n\x04\x04Q\x03\0\
    \x12\x06\xb0\x06\x08\xb4\x06\t\n\r\n\x05\x04Q\x03\0\x01\x12\x04\xb0\x06\
    \x10\x1b\n\x0e\n\x06\x04Q\x03\0\x02\0\x12\x04\xb1\x06\x10(\n\x0f\n\x07\
    \x04Q\x03\0\x02\0\x04\x12\x04\xb1\x06\x10\x18\n\x0f\n\x07\x04Q\x03\0\x02\
    \0\x05\x12\x04\xb1\x06\x19\x1e\n\x0f\n\x07\x04Q\x03\0\x02\0\x01\x12\x04\
    \xb1\x06\x1f#\n\x0f\n\x07\x04Q\x03\0\x02\0\x03\x12\x04\xb1\x06&'\n\x0e\n\
    \x06\x04Q\x03\0\x02\x01\x12\x04\xb2\x06\x10(\n\x0f\n\x07\x04Q\x03\0\x02\
    \x01\x04\x12\x04\xb2\x06\x10\x18\n\x0f\n\x07\x04Q\x03\0\x02\x01\x05\x12\
    \x04\xb2\x06\x19\x1e\n\x0f\n\x07\x04Q\x03\0\x02\x01\x01\x12\x04\xb2\x06\
    \x1f#\n\x0f\n\x07\x04Q\x03\0\x02\x01\x03\x12\x04\xb2\x06&'\n\x0e\n\x06\
    \x04Q\x03\0\x02\x02\x12\x04\xb3\x06\x10+\n\x0f\n\x07\x04Q\x03\0\x02\x02\
    \x04\x12\x04\xb3\x06\x10\x18\n\x0f\n\x07\x04Q\x03\0\x02\x02\x05\x12\x04\
    \xb3\x06\x19\x1f\n\x0f\n\x07\x04Q\x03\0\x02\x02\x01\x12\x04\xb3\x06\x20&\
    \n\x0f\n\x07\x04Q\x03\0\x02\x02\x03\x12\x04\xb3\x06)*\n\x0e\n\x04\x04Q\
    \x03\x01\x12\x06\xb6\x06\x08\xb9\x06\t\n\r\n\x05\x04Q\x03\x01\x01\x12\
    \x04\xb6\x06\x10\x1b\n\x0e\n\x06\x04Q\x03\x01\x02\0\x12\x04\xb7\x06\x10-\
    \n\x0f\n\x07\x04Q\x03\x01\x02\0\x04\x12\x04\xb7\x06\x10\x18\n\x0f\n\x07\
    \x04Q\x03\x01\x02\0\x05\x12\x04\xb7\x06\x19\x1e\n\x0f\n\x07\x04Q\x03\x01\
    \x02\0\x01\x12\x04\xb7\x06\x1f(\n\x0f\n\x07\x04Q\x03\x01\x02\0\x03\x12\
    \x04\xb7\x06+,\n\x0e\n\x06\x04Q\x03\x01\x02\x01\x12\x04\xb8\x06\x10K\n\
    \x0f\n\x07\x04Q\x03\x01\x02\x01\x04\x12\x04\xb8\x06\x10\x18\n\x0f\n\x07\
    \x04Q\x03\x01\x02\x01\x06\x12\x04\xb8\x06\x19@\n\x0f\n\x07\x04Q\x03\x01\
    \x02\x01\x01\x12\x04\xb8\x06AF\n\x0f\n\x07\x04Q\x03\x01\x02\x01\x03\x12\
    \x04\xb8\x06IJ\n\x0c\n\x04\x04Q\x02\0\x12\x04\xbb\x06\x08%\n\r\n\x05\x04\
    Q\x02\0\x04\x12\x04\xbb\x06\x08\x10\n\r\n\x05\x04Q\x02\0\x05\x12\x04\xbb\
    \x06\x11\x17\n\r\n\x05\x04Q\x02\0\x01\x12\x04\xbb\x06\x18\x20\n\r\n\x05\
    \x04Q\x02\0\x03\x12\x04\xbb\x06#$\n\x0c\n\x04\x04Q\x02\x01\x12\x04\xbc\
    \x06\x08C\n\r\n\x05\x04Q\x02\x01\x04\x12\x04\xbc\x06\x08\x10\n\r\n\x05\
    \x04Q\x02\x01\x06\x12\x04\xbc\x06\x118\n\r\n\x05\x04Q\x02\x01\x01\x12\
    \x04\xbc\x069>\n\r\n\x05\x04Q\x02\x01\x03\x12\x04\xbc\x06AB\n\x0c\n\x02\
    \x04R\x12\x06\xbf\x06\0\xc1\x06\x01\n\x0b\n\x03\x04R\x01\x12\x04\xbf\x06\
    \x08\x19\n\x0c\n\x04\x04R\x02\0\x12\x04\xc0\x06\x08\"\n\r\n\x05\x04R\x02\
    \0\x04\x12\x04\xc0\x06\x08\x10\n\r\n\x05\x04R\x02\0\x05\x12\x04\xc0\x06\
    \x11\x17\n\r\n\x05\x04R\x02\0\x01\x12\x04\xc0\x06\x18\x1d\n\r\n\x05\x04R\
    \x02\0\x03\x12\x04\xc0\x06\x20!\n\x0c\n\x02\x04S\x12\x06\xc3\x06\0\xc4\
    \x06\x01\n\x0b\n\x03\x04S\x01\x12\x04\xc3\x06\x08\x20\n\x0c\n\x02\x04T\
    \x12\x06\xc6\x06\0\xce\x06\x01\n\x0b\n\x03\x04T\x01\x12\x04\xc6\x06\x08\
    \x1c\n\x0c\n\x04\x04T\x02\0\x12\x04\xc7\x06\x08,\n\r\n\x05\x04T\x02\0\
    \x04\x12\x04\xc7\x06\x08\x10\n\r\n\x05\x04T\x02\0\x05\x12\x04\xc7\x06\
    \x11\x17\n\r\n\x05\x04T\x02\0\x01\x12\x04\xc7\x06\x18'\n\r\n\x05\x04T\
    \x02\0\x03\x12\x04\xc7\x06*+\n\x0c\n\x04\x04T\x02\x01\x12\x04\xc8\x06\
    \x084\n\r\n\x05\x04T\x02\x01\x04\x12\x04\xc8\x06\x08\x10\n\r\n\x05\x04T\
    \x02\x01\x05\x12\x04\xc8\x06\x11\x17\n\r\n\x05\x04T\x02\x01\x01\x12\x04\
    \xc8\x06\x18/\n\r\n\x05\x04T\x02\x01\x03\x12\x04\xc8\x0623\n\x0c\n\x04\
    \x04T\x02\x02\x12\x04\xc9\x06\x08/\n\r\n\x05\x04T\x02\x02\x04\x12\x04\
    \xc9\x06\x08\x10\n\r\n\x05\x04T\x02\x02\x05\x12\x04\xc9\x06\x11\x17\n\r\
    \n\x05\x04T\x02\x02\x01\x12\x04\xc9\x06\x18)\n\r\n\x05\x04T\x02\x02\x03\
    \x12\x04\xc9\x06,.\n\x0c\n\x04\x04T\x02\x03\x12\x04\xca\x06\x08.\n\r\n\
    \x05\x04T\x02\x03\x04\x12\x04\xca\x06\x08\x10\n\r\n\x05\x04T\x02\x03\x05\
    \x12\x04\xca\x06\x11\x17\n\r\n\x05\x04T\x02\x03\x01\x12\x04\xca\x06\x18(\
    \n\r\n\x05\x04T\x02\x03\x03\x12\x04\xca\x06+-\n\x0c\n\x04\x04T\x02\x04\
    \x12\x04\xcb\x06\x08-\n\r\n\x05\x04T\x02\x04\x04\x12\x04\xcb\x06\x08\x10\
    \n\r\n\x05\x04T\x02\x04\x05\x12\x04\xcb\x06\x11\x17\n\r\n\x05\x04T\x02\
    \x04\x01\x12\x04\xcb\x06\x18'\n\r\n\x05\x04T\x02\x04\x03\x12\x04\xcb\x06\
    *,\n\x0c\n\x04\x04T\x02\x05\x12\x04\xcc\x06\x08(\n\r\n\x05\x04T\x02\x05\
    \x04\x12\x04\xcc\x06\x08\x10\n\r\n\x05\x04T\x02\x05\x05\x12\x04\xcc\x06\
    \x11\x17\n\r\n\x05\x04T\x02\x05\x01\x12\x04\xcc\x06\x18\"\n\r\n\x05\x04T\
    \x02\x05\x03\x12\x04\xcc\x06%'\n\x0c\n\x04\x04T\x02\x06\x12\x04\xcd\x06\
    \x08&\n\r\n\x05\x04T\x02\x06\x04\x12\x04\xcd\x06\x08\x10\n\r\n\x05\x04T\
    \x02\x06\x05\x12\x04\xcd\x06\x11\x17\n\r\n\x05\x04T\x02\x06\x01\x12\x04\
    \xcd\x06\x18\x20\n\r\n\x05\x04T\x02\x06\x03\x12\x04\xcd\x06#%\n\x0c\n\
    \x02\x04U\x12\x06\xd0\x06\0\xd6\x06\x01\n\x0b\n\x03\x04U\x01\x12\x04\xd0\
    \x06\x089\n\x0c\n\x04\x04U\x02\0\x12\x04\xd1\x06\x08'\n\r\n\x05\x04U\x02\
    \0\x04\x12\x04\xd1\x06\x08\x10\n\r\n\x05\x04U\x02\0\x05\x12\x04\xd1\x06\
    \x11\x17\n\r\n\x05\x04U\x02\0\x01\x12\x04\xd1\x06\x18\"\n\r\n\x05\x04U\
    \x02\0\x03\x12\x04\xd1\x06%&\n\x0c\n\x04\x04U\x02\x01\x12\x04\xd2\x06\
    \x08%\n\r\n\x05\x04U\x02\x01\x04\x12\x04\xd2\x06\x08\x10\n\r\n\x05\x04U\
    \x02\x01\x05\x12\x04\xd2\x06\x11\x16\n\r\n\x05\x04U\x02\x01\x01\x12\x04\
    \xd2\x06\x17\x20\n\r\n\x05\x04U\x02\x01\x03\x12\x04\xd2\x06#$\n\x0c\n\
    \x04\x04U\x02\x02\x12\x04\xd3\x06\x08(\n\r\n\x05\x04U\x02\x02\x04\x12\
    \x04\xd3\x06\x08\x10\n\r\n\x05\x04U\x02\x02\x05\x12\x04\xd3\x06\x11\x17\
    \n\r\n\x05\x04U\x02\x02\x01\x12\x04\xd3\x06\x18#\n\r\n\x05\x04U\x02\x02\
    \x03\x12\x04\xd3\x06&'\n\x0c\n\x04\x04U\x02\x03\x12\x04\xd4\x06\x08(\n\r\
    \n\x05\x04U\x02\x03\x04\x12\x04\xd4\x06\x08\x10\n\r\n\x05\x04U\x02\x03\
    \x05\x12\x04\xd4\x06\x11\x17\n\r\n\x05\x04U\x02\x03\x01\x12\x04\xd4\x06\
    \x18#\n\r\n\x05\x04U\x02\x03\x03\x12\x04\xd4\x06&'\n\x0c\n\x04\x04U\x02\
    \x04\x12\x04\xd5\x06\x08*\n\r\n\x05\x04U\x02\x04\x04\x12\x04\xd5\x06\x08\
    \x10\n\r\n\x05\x04U\x02\x04\x05\x12\x04\xd5\x06\x11\x17\n\r\n\x05\x04U\
    \x02\x04\x01\x12\x04\xd5\x06\x18%\n\r\n\x05\x04U\x02\x04\x03\x12\x04\xd5\
    \x06()\n\x0c\n\x02\x04V\x12\x06\xd8\x06\0\xdc\x06\x01\n\x0b\n\x03\x04V\
    \x01\x12\x04\xd8\x06\x089\n\x0c\n\x04\x04V\x02\0\x12\x04\xd9\x06\x08&\n\
    \r\n\x05\x04V\x02\0\x04\x12\x04\xd9\x06\x08\x10\n\r\n\x05\x04V\x02\0\x05\
    \x12\x04\xd9\x06\x11\x17\n\r\n\x05\x04V\x02\0\x01\x12\x04\xd9\x06\x18!\n\
    \r\n\x05\x04V\x02\0\x03\x12\x04\xd9\x06$%\n\x0c\n\x04\x04V\x02\x01\x12\
    \x04\xda\x06\x08'\n\r\n\x05\x04V\x02\x01\x04\x12\x04\xda\x06\x08\x10\n\r\
    \n\x05\x04V\x02\x01\x05\x12\x04\xda\x06\x11\x17\n\r\n\x05\x04V\x02\x01\
    \x01\x12\x04\xda\x06\x18\"\n\r\n\x05\x04V\x02\x01\x03\x12\x04\xda\x06%&\
    \n\x0c\n\x04\x04V\x02\x02\x12\x04\xdb\x06\x08!\n\r\n\x05\x04V\x02\x02\
    \x04\x12\x04\xdb\x06\x08\x10\n\r\n\x05\x04V\x02\x02\x05\x12\x04\xdb\x06\
    \x11\x17\n\r\n\x05\x04V\x02\x02\x01\x12\x04\xdb\x06\x18\x1c\n\r\n\x05\
    \x04V\x02\x02\x03\x12\x04\xdb\x06\x1f\x20\n\x0c\n\x02\x04W\x12\x06\xde\
    \x06\0\xdf\x06\x01\n\x0b\n\x03\x04W\x01\x12\x04\xde\x06\x082\n\x0c\n\x02\
    \x04X\x12\x06\xe1\x06\0\xec\x06\x01\n\x0b\n\x03\x04X\x01\x12\x04\xe1\x06\
    \x083\n\x0e\n\x04\x04X\x03\0\x12\x06\xe2\x06\x08\xe5\x06\t\n\r\n\x05\x04\
    X\x03\0\x01\x12\x04\xe2\x06\x10$\n\x0e\n\x06\x04X\x03\0\x02\0\x12\x04\
    \xe3\x06\x10.\n\x0f\n\x07\x04X\x03\0\x02\0\x04\x12\x04\xe3\x06\x10\x18\n\
    \x0f\n\x07\x04X\x03\0\x02\0\x05\x12\x04\xe3\x06\x19\x1f\n\x0f\n\x07\x04X\
    \x03\0\x02\0\x01\x12\x04\xe3\x06\x20)\n\x0f\n\x07\x04X\x03\0\x02\0\x03\
    \x12\x04\xe3\x06,-\n\x0e\n\x06\x04X\x03\0\x02\x01\x12\x04\xe4\x06\x10*\n\
    \x0f\n\x07\x04X\x03\0\x02\x01\x04\x12\x04\xe4\x06\x10\x18\n\x0f\n\x07\
    \x04X\x03\0\x02\x01\x05\x12\x04\xe4\x06\x19\x1f\n\x0f\n\x07\x04X\x03\0\
    \x02\x01\x01\x12\x04\xe4\x06\x20%\n\x0f\n\x07\x04X\x03\0\x02\x01\x03\x12\
    \x04\xe4\x06()\n\x0c\n\x04\x04X\x02\0\x12\x04\xe7\x06\x08'\n\r\n\x05\x04\
    X\x02\0\x04\x12\x04\xe7\x06\x08\x10\n\r\n\x05\x04X\x02\0\x05\x12\x04\xe7\
    \x06\x11\x17\n\r\n\x05\x04X\x02\0\x01\x12\x04\xe7\x06\x18\"\n\r\n\x05\
    \x04X\x02\0\x03\x12\x04\xe7\x06%&\n\x0c\n\x04\x04X\x02\x01\x12\x04\xe8\
    \x06\x080\n\r\n\x05\x04X\x02\x01\x04\x12\x04\xe8\x06\x08\x10\n\r\n\x05\
    \x04X\x02\x01\x05\x12\x04\xe8\x06\x11\x17\n\r\n\x05\x04X\x02\x01\x01\x12\
    \x04\xe8\x06\x18+\n\r\n\x05\x04X\x02\x01\x03\x12\x04\xe8\x06./\n\x0c\n\
    \x04\x04X\x02\x02\x12\x04\xe9\x06\x08.\n\r\n\x05\x04X\x02\x02\x04\x12\
    \x04\xe9\x06\x08\x10\n\r\n\x05\x04X\x02\x02\x05\x12\x04\xe9\x06\x11\x17\
    \n\r\n\x05\x04X\x02\x02\x01\x12\x04\xe9\x06\x18)\n\r\n\x05\x04X\x02\x02\
    \x03\x12\x04\xe9\x06,-\n\x0c\n\x04\x04X\x02\x03\x12\x04\xea\x06\x08)\n\r\
    \n\x05\x04X\x02\x03\x04\x12\x04\xea\x06\x08\x10\n\r\n\x05\x04X\x02\x03\
    \x05\x12\x04\xea\x06\x11\x17\n\r\n\x05\x04X\x02\x03\x01\x12\x04\xea\x06\
    \x18$\n\r\n\x05\x04X\x02\x03\x03\x12\x04\xea\x06'(\n\x0c\n\x04\x04X\x02\
    \x04\x12\x04\xeb\x06\x08_\n\r\n\x05\x04X\x02\x04\x04\x12\x04\xeb\x06\x08\
    \x10\n\r\n\x05\x04X\x02\x04\x06\x12\x04\xeb\x06\x11R\n\r\n\x05\x04X\x02\
    \x04\x01\x12\x04\xeb\x06SZ\n\r\n\x05\x04X\x02\x04\x03\x12\x04\xeb\x06]^\
    \n\x0c\n\x02\x04Y\x12\x06\xee\x06\0\xf1\x06\x01\n\x0b\n\x03\x04Y\x01\x12\
    \x04\xee\x06\x081\n\x0c\n\x04\x04Y\x02\0\x12\x04\xef\x06\x08&\n\r\n\x05\
    \x04Y\x02\0\x04\x12\x04\xef\x06\x08\x10\n\r\n\x05\x04Y\x02\0\x05\x12\x04\
    \xef\x06\x11\x17\n\r\n\x05\x04Y\x02\0\x01\x12\x04\xef\x06\x18!\n\r\n\x05\
    \x04Y\x02\0\x03\x12\x04\xef\x06$%\n\x0c\n\x04\x04Y\x02\x01\x12\x04\xf0\
    \x06\x08!\n\r\n\x05\x04Y\x02\x01\x04\x12\x04\xf0\x06\x08\x10\n\r\n\x05\
    \x04Y\x02\x01\x05\x12\x04\xf0\x06\x11\x17\n\r\n\x05\x04Y\x02\x01\x01\x12\
    \x04\xf0\x06\x18\x1c\n\r\n\x05\x04Y\x02\x01\x03\x12\x04\xf0\x06\x1f\x20\
    \n\x0c\n\x02\x04Z\x12\x06\xf3\x06\0\xf5\x06\x01\n\x0b\n\x03\x04Z\x01\x12\
    \x04\xf3\x06\x082\n\x0c\n\x04\x04Z\x02\0\x12\x04\xf4\x06\x08&\n\r\n\x05\
    \x04Z\x02\0\x04\x12\x04\xf4\x06\x08\x10\n\r\n\x05\x04Z\x02\0\x05\x12\x04\
    \xf4\x06\x11\x17\n\r\n\x05\x04Z\x02\0\x01\x12\x04\xf4\x06\x18!\n\r\n\x05\
    \x04Z\x02\0\x03\x12\x04\xf4\x06$%\n\x0c\n\x02\x04[\x12\x06\xf7\x06\0\x80\
    \x07\x01\n\x0b\n\x03\x04[\x01\x12\x04\xf7\x06\x08?\n\x0c\n\x04\x04[\x02\
    \0\x12\x04\xf8\x06\x08&\n\r\n\x05\x04[\x02\0\x04\x12\x04\xf8\x06\x08\x10\
    \n\r\n\x05\x04[\x02\0\x05\x12\x04\xf8\x06\x11\x17\n\r\n\x05\x04[\x02\0\
    \x01\x12\x04\xf8\x06\x18!\n\r\n\x05\x04[\x02\0\x03\x12\x04\xf8\x06$%\n\
    \x0c\n\x04\x04[\x02\x01\x12\x04\xf9\x06\x08!\n\r\n\x05\x04[\x02\x01\x04\
    \x12\x04\xf9\x06\x08\x10\n\r\n\x05\x04[\x02\x01\x05\x12\x04\xf9\x06\x11\
    \x17\n\r\n\x05\x04[\x02\x01\x01\x12\x04\xf9\x06\x18\x1c\n\r\n\x05\x04[\
    \x02\x01\x03\x12\x04\xf9\x06\x1f\x20\n\x0c\n\x04\x04[\x02\x02\x12\x04\
    \xfa\x06\x08!\n\r\n\x05\x04[\x02\x02\x04\x12\x04\xfa\x06\x08\x10\n\r\n\
    \x05\x04[\x02\x02\x05\x12\x04\xfa\x06\x11\x17\n\r\n\x05\x04[\x02\x02\x01\
    \x12\x04\xfa\x06\x18\x1c\n\r\n\x05\x04[\x02\x02\x03\x12\x04\xfa\x06\x1f\
    \x20\n\x0c\n\x04\x04[\x02\x03\x12\x04\xfb\x06\x08\x20\n\r\n\x05\x04[\x02\
    \x03\x04\x12\x04\xfb\x06\x08\x10\n\r\n\x05\x04[\x02\x03\x05\x12\x04\xfb\
    \x06\x11\x17\n\r\n\x05\x04[\x02\x03\x01\x12\x04\xfb\x06\x18\x1b\n\r\n\
    \x05\x04[\x02\x03\x03\x12\x04\xfb\x06\x1e\x1f\n\x0c\n\x04\x04[\x02\x04\
    \x12\x04\xfc\x06\x08\x20\n\r\n\x05\x04[\x02\x04\x04\x12\x04\xfc\x06\x08\
    \x10\n\r\n\x05\x04[\x02\x04\x05\x12\x04\xfc\x06\x11\x16\n\r\n\x05\x04[\
    \x02\x04\x01\x12\x04\xfc\x06\x17\x1b\n\r\n\x05\x04[\x02\x04\x03\x12\x04\
    \xfc\x06\x1e\x1f\n\x0c\n\x04\x04[\x02\x05\x12\x04\xfd\x06\x08\x1f\n\r\n\
    \x05\x04[\x02\x05\x04\x12\x04\xfd\x06\x08\x10\n\r\n\x05\x04[\x02\x05\x05\
    \x12\x04\xfd\x06\x11\x16\n\r\n\x05\x04[\x02\x05\x01\x12\x04\xfd\x06\x17\
    \x1a\n\r\n\x05\x04[\x02\x05\x03\x12\x04\xfd\x06\x1d\x1e\n\x0c\n\x04\x04[\
    \x02\x06\x12\x04\xfe\x06\x08'\n\r\n\x05\x04[\x02\x06\x04\x12\x04\xfe\x06\
    \x08\x10\n\r\n\x05\x04[\x02\x06\x05\x12\x04\xfe\x06\x11\x16\n\r\n\x05\
    \x04[\x02\x06\x01\x12\x04\xfe\x06\x17\"\n\r\n\x05\x04[\x02\x06\x03\x12\
    \x04\xfe\x06%&\n\x0c\n\x04\x04[\x02\x07\x12\x04\xff\x06\x08(\n\r\n\x05\
    \x04[\x02\x07\x04\x12\x04\xff\x06\x08\x10\n\r\n\x05\x04[\x02\x07\x05\x12\
    \x04\xff\x06\x11\x16\n\r\n\x05\x04[\x02\x07\x01\x12\x04\xff\x06\x17#\n\r\
    \n\x05\x04[\x02\x07\x03\x12\x04\xff\x06&'\n\x0c\n\x02\x04\\\x12\x06\x82\
    \x07\0\x87\x07\x01\n\x0b\n\x03\x04\\\x01\x12\x04\x82\x07\x082\n\x0c\n\
    \x04\x04\\\x02\0\x12\x04\x83\x07\x08$\n\r\n\x05\x04\\\x02\0\x04\x12\x04\
    \x83\x07\x08\x10\n\r\n\x05\x04\\\x02\0\x05\x12\x04\x83\x07\x11\x17\n\r\n\
    \x05\x04\\\x02\0\x01\x12\x04\x83\x07\x18\x1f\n\r\n\x05\x04\\\x02\0\x03\
    \x12\x04\x83\x07\"#\n\x0c\n\x04\x04\\\x02\x01\x12\x04\x84\x07\x08$\n\r\n\
    \x05\x04\\\x02\x01\x04\x12\x04\x84\x07\x08\x10\n\r\n\x05\x04\\\x02\x01\
    \x05\x12\x04\x84\x07\x11\x17\n\r\n\x05\x04\\\x02\x01\x01\x12\x04\x84\x07\
    \x18\x1f\n\r\n\x05\x04\\\x02\x01\x03\x12\x04\x84\x07\"#\n\x0c\n\x04\x04\
    \\\x02\x02\x12\x04\x85\x07\x08&\n\r\n\x05\x04\\\x02\x02\x04\x12\x04\x85\
    \x07\x08\x10\n\r\n\x05\x04\\\x02\x02\x05\x12\x04\x85\x07\x11\x17\n\r\n\
    \x05\x04\\\x02\x02\x01\x12\x04\x85\x07\x18!\n\r\n\x05\x04\\\x02\x02\x03\
    \x12\x04\x85\x07$%\n\x0c\n\x04\x04\\\x02\x03\x12\x04\x86\x07\x08$\n\r\n\
    \x05\x04\\\x02\x03\x04\x12\x04\x86\x07\x08\x10\n\r\n\x05\x04\\\x02\x03\
    \x05\x12\x04\x86\x07\x11\x17\n\r\n\x05\x04\\\x02\x03\x01\x12\x04\x86\x07\
    \x18\x1f\n\r\n\x05\x04\\\x02\x03\x03\x12\x04\x86\x07\"#\n\x0c\n\x02\x04]\
    \x12\x06\x89\x07\0\x8d\x07\x01\n\x0b\n\x03\x04]\x01\x12\x04\x89\x07\x08\
    \x15\n\x0c\n\x04\x04]\x02\0\x12\x04\x8a\x07\x089\n\r\n\x05\x04]\x02\0\
    \x04\x12\x04\x8a\x07\x08\x10\n\r\n\x05\x04]\x02\0\x05\x12\x04\x8a\x07\
    \x11\x17\n\r\n\x05\x04]\x02\0\x01\x12\x04\x8a\x07\x18\x1f\n\r\n\x05\x04]\
    \x02\0\x03\x12\x04\x8a\x07\"#\n\r\n\x05\x04]\x02\0\x08\x12\x04\x8a\x07$8\
    \n\x10\n\x08\x04]\x02\0\x08\xe0\xd4\x03\x12\x04\x8a\x07%7\n\x0c\n\x04\
    \x04]\x02\x01\x12\x04\x8b\x07\x08#\n\r\n\x05\x04]\x02\x01\x04\x12\x04\
    \x8b\x07\x08\x10\n\r\n\x05\x04]\x02\x01\x05\x12\x04\x8b\x07\x11\x17\n\r\
    \n\x05\x04]\x02\x01\x01\x12\x04\x8b\x07\x18\x1e\n\r\n\x05\x04]\x02\x01\
    \x03\x12\x04\x8b\x07!\"\n\x0c\n\x04\x04]\x02\x02\x12\x04\x8c\x07\x08-\n\
    \r\n\x05\x04]\x02\x02\x04\x12\x04\x8c\x07\x08\x10\n\r\n\x05\x04]\x02\x02\
    \x05\x12\x04\x8c\x07\x11\x18\n\r\n\x05\x04]\x02\x02\x01\x12\x04\x8c\x07\
    \x19(\n\r\n\x05\x04]\x02\x02\x03\x12\x04\x8c\x07+,\n\x0c\n\x02\x04^\x12\
    \x06\x8f\x07\0\x93\x07\x01\n\x0b\n\x03\x04^\x01\x12\x04\x8f\x07\x08\x18\
    \n\x0c\n\x04\x04^\x02\0\x12\x04\x90\x07\x089\n\r\n\x05\x04^\x02\0\x04\
    \x12\x04\x90\x07\x08\x10\n\r\n\x05\x04^\x02\0\x05\x12\x04\x90\x07\x11\
    \x17\n\r\n\x05\x04^\x02\0\x01\x12\x04\x90\x07\x18\x1f\n\r\n\x05\x04^\x02\
    \0\x03\x12\x04\x90\x07\"#\n\r\n\x05\x04^\x02\0\x08\x12\x04\x90\x07$8\n\
    \x10\n\x08\x04^\x02\0\x08\xe0\xd4\x03\x12\x04\x90\x07%7\n\x0c\n\x04\x04^\
    \x02\x01\x12\x04\x91\x07\x08-\n\r\n\x05\x04^\x02\x01\x04\x12\x04\x91\x07\
    \x08\x10\n\r\n\x05\x04^\x02\x01\x05\x12\x04\x91\x07\x11\x17\n\r\n\x05\
    \x04^\x02\x01\x01\x12\x04\x91\x07\x18(\n\r\n\x05\x04^\x02\x01\x03\x12\
    \x04\x91\x07+,\n\x0c\n\x04\x04^\x02\x02\x12\x04\x92\x07\x08)\n\r\n\x05\
    \x04^\x02\x02\x04\x12\x04\x92\x07\x08\x10\n\r\n\x05\x04^\x02\x02\x05\x12\
    \x04\x92\x07\x11\x17\n\r\n\x05\x04^\x02\x02\x01\x12\x04\x92\x07\x18$\n\r\
    \n\x05\x04^\x02\x02\x03\x12\x04\x92\x07'(\n\x0c\n\x02\x04_\x12\x06\x95\
    \x07\0\x99\x07\x01\n\x0b\n\x03\x04_\x01\x12\x04\x95\x07\x08\x1c\n\x0c\n\
    \x04\x04_\x02\0\x12\x04\x96\x07\x08(\n\r\n\x05\x04_\x02\0\x04\x12\x04\
    \x96\x07\x08\x10\n\r\n\x05\x04_\x02\0\x05\x12\x04\x96\x07\x11\x16\n\r\n\
    \x05\x04_\x02\0\x01\x12\x04\x96\x07\x17#\n\r\n\x05\x04_\x02\0\x03\x12\
    \x04\x96\x07&'\n\x0c\n\x04\x04_\x02\x01\x12\x04\x97\x07\x08:\n\r\n\x05\
    \x04_\x02\x01\x04\x12\x04\x97\x07\x08\x10\n\r\n\x05\x04_\x02\x01\x06\x12\
    \x04\x97\x07\x11(\n\r\n\x05\x04_\x02\x01\x01\x12\x04\x97\x07)5\n\r\n\x05\
    \x04_\x02\x01\x03\x12\x04\x97\x0789\n\x0c\n\x04\x04_\x02\x02\x12\x04\x98\
    \x07\x08)\n\r\n\x05\x04_\x02\x02\x04\x12\x04\x98\x07\x08\x10\n\r\n\x05\
    \x04_\x02\x02\x05\x12\x04\x98\x07\x11\x15\n\r\n\x05\x04_\x02\x02\x01\x12\
    \x04\x98\x07\x16$\n\r\n\x05\x04_\x02\x02\x03\x12\x04\x98\x07'(\n\x0c\n\
    \x02\x04`\x12\x06\x9b\x07\0\x9d\x07\x01\n\x0b\n\x03\x04`\x01\x12\x04\x9b\
    \x07\x08#\n\x0c\n\x04\x04`\x02\0\x12\x04\x9c\x07\x08#\n\r\n\x05\x04`\x02\
    \0\x04\x12\x04\x9c\x07\x08\x10\n\r\n\x05\x04`\x02\0\x05\x12\x04\x9c\x07\
    \x11\x17\n\r\n\x05\x04`\x02\0\x01\x12\x04\x9c\x07\x18\x1e\n\r\n\x05\x04`\
    \x02\0\x03\x12\x04\x9c\x07!\"\n\x0c\n\x02\x04a\x12\x06\x9f\x07\0\xa1\x07\
    \x01\n\x0b\n\x03\x04a\x01\x12\x04\x9f\x07\x08%\n\x0c\n\x04\x04a\x02\0\
    \x12\x04\xa0\x07\x08$\n\r\n\x05\x04a\x02\0\x04\x12\x04\xa0\x07\x08\x10\n\
    \r\n\x05\x04a\x02\0\x05\x12\x04\xa0\x07\x11\x16\n\r\n\x05\x04a\x02\0\x01\
    \x12\x04\xa0\x07\x17\x1f\n\r\n\x05\x04a\x02\0\x03\x12\x04\xa0\x07\"#\n\
    \x0c\n\x02\x04b\x12\x06\xa3\x07\0\xa7\x07\x01\n\x0b\n\x03\x04b\x01\x12\
    \x04\xa3\x07\x08\x1e\n\x0c\n\x04\x04b\x02\0\x12\x04\xa4\x07\x08#\n\r\n\
    \x05\x04b\x02\0\x04\x12\x04\xa4\x07\x08\x10\n\r\n\x05\x04b\x02\0\x05\x12\
    \x04\xa4\x07\x11\x17\n\r\n\x05\x04b\x02\0\x01\x12\x04\xa4\x07\x18\x1e\n\
    \r\n\x05\x04b\x02\0\x03\x12\x04\xa4\x07!\"\n\x0c\n\x04\x04b\x02\x01\x12\
    \x04\xa5\x07\x08'\n\r\n\x05\x04b\x02\x01\x04\x12\x04\xa5\x07\x08\x10\n\r\
    \n\x05\x04b\x02\x01\x05\x12\x04\xa5\x07\x11\x17\n\r\n\x05\x04b\x02\x01\
    \x01\x12\x04\xa5\x07\x18\"\n\r\n\x05\x04b\x02\x01\x03\x12\x04\xa5\x07%&\
    \n\x0c\n\x04\x04b\x02\x02\x12\x04\xa6\x07\x08'\n\r\n\x05\x04b\x02\x02\
    \x04\x12\x04\xa6\x07\x08\x10\n\r\n\x05\x04b\x02\x02\x05\x12\x04\xa6\x07\
    \x11\x17\n\r\n\x05\x04b\x02\x02\x01\x12\x04\xa6\x07\x18\"\n\r\n\x05\x04b\
    \x02\x02\x03\x12\x04\xa6\x07%&\n\x0c\n\x02\x04c\x12\x06\xa9\x07\0\xab\
    \x07\x01\n\x0b\n\x03\x04c\x01\x12\x04\xa9\x07\x08-\n\x0c\n\x04\x04c\x02\
    \0\x12\x04\xaa\x07\x08(\n\r\n\x05\x04c\x02\0\x04\x12\x04\xaa\x07\x08\x10\
    \n\r\n\x05\x04c\x02\0\x05\x12\x04\xaa\x07\x11\x16\n\r\n\x05\x04c\x02\0\
    \x01\x12\x04\xaa\x07\x17#\n\r\n\x05\x04c\x02\0\x03\x12\x04\xaa\x07&'\n\
    \x0c\n\x02\x04d\x12\x06\xad\x07\0\xae\x07\x01\n\x0b\n\x03\x04d\x01\x12\
    \x04\xad\x07\x087\n\x0c\n\x02\x04e\x12\x06\xb0\x07\0\xb3\x07\x01\n\x0b\n\
    \x03\x04e\x01\x12\x04\xb0\x07\x080\n\x0c\n\x04\x04e\x02\0\x12\x04\xb1\
    \x07\x08#\n\r\n\x05\x04e\x02\0\x04\x12\x04\xb1\x07\x08\x10\n\r\n\x05\x04\
    e\x02\0\x05\x12\x04\xb1\x07\x11\x17\n\r\n\x05\x04e\x02\0\x01\x12\x04\xb1\
    \x07\x18\x1e\n\r\n\x05\x04e\x02\0\x03\x12\x04\xb1\x07!\"\n\x0c\n\x04\x04\
    e\x02\x01\x12\x04\xb2\x07\x08\x1e\n\r\n\x05\x04e\x02\x01\x04\x12\x04\xb2\
    \x07\x08\x10\n\r\n\x05\x04e\x02\x01\x05\x12\x04\xb2\x07\x11\x16\n\r\n\
    \x05\x04e\x02\x01\x01\x12\x04\xb2\x07\x17\x19\n\r\n\x05\x04e\x02\x01\x03\
    \x12\x04\xb2\x07\x1c\x1d\n\x0c\n\x02\x04f\x12\x06\xb5\x07\0\xb7\x07\x01\
    \n\x0b\n\x03\x04f\x01\x12\x04\xb5\x07\x083\n\x0c\n\x04\x04f\x02\0\x12\
    \x04\xb6\x07\x08\"\n\r\n\x05\x04f\x02\0\x04\x12\x04\xb6\x07\x08\x10\n\r\
    \n\x05\x04f\x02\0\x05\x12\x04\xb6\x07\x11\x17\n\r\n\x05\x04f\x02\0\x01\
    \x12\x04\xb6\x07\x18\x1d\n\r\n\x05\x04f\x02\0\x03\x12\x04\xb6\x07\x20!\n\
    \x0c\n\x02\x04g\x12\x06\xb9\x07\0\xbc\x07\x01\n\x0b\n\x03\x04g\x01\x12\
    \x04\xb9\x07\x08)\n\x0c\n\x04\x04g\x02\0\x12\x04\xba\x07\x08%\n\r\n\x05\
    \x04g\x02\0\x04\x12\x04\xba\x07\x08\x10\n\r\n\x05\x04g\x02\0\x05\x12\x04\
    \xba\x07\x11\x17\n\r\n\x05\x04g\x02\0\x01\x12\x04\xba\x07\x18\x20\n\r\n\
    \x05\x04g\x02\0\x03\x12\x04\xba\x07#$\n\x0c\n\x04\x04g\x02\x01\x12\x04\
    \xbb\x07\x08!\n\r\n\x05\x04g\x02\x01\x04\x12\x04\xbb\x07\x08\x10\n\r\n\
    \x05\x04g\x02\x01\x05\x12\x04\xbb\x07\x11\x17\n\r\n\x05\x04g\x02\x01\x01\
    \x12\x04\xbb\x07\x18\x1c\n\r\n\x05\x04g\x02\x01\x03\x12\x04\xbb\x07\x1f\
    \x20\n\x0c\n\x02\x04h\x12\x06\xbe\x07\0\xc1\x07\x01\n\x0b\n\x03\x04h\x01\
    \x12\x04\xbe\x07\x08)\n\x0c\n\x04\x04h\x02\0\x12\x04\xbf\x07\x08'\n\r\n\
    \x05\x04h\x02\0\x04\x12\x04\xbf\x07\x08\x10\n\r\n\x05\x04h\x02\0\x05\x12\
    \x04\xbf\x07\x11\x17\n\r\n\x05\x04h\x02\0\x01\x12\x04\xbf\x07\x18\"\n\r\
    \n\x05\x04h\x02\0\x03\x12\x04\xbf\x07%&\n\x0c\n\x04\x04h\x02\x01\x12\x04\
    \xc0\x07\x08!\n\r\n\x05\x04h\x02\x01\x04\x12\x04\xc0\x07\x08\x10\n\r\n\
    \x05\x04h\x02\x01\x05\x12\x04\xc0\x07\x11\x17\n\r\n\x05\x04h\x02\x01\x01\
    \x12\x04\xc0\x07\x18\x1c\n\r\n\x05\x04h\x02\x01\x03\x12\x04\xc0\x07\x1f\
    \x20\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::steammessages::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(119);
            messages.push(GameServerPing::generated_message_descriptor_data());
            messages.push(DetailedSearchStatistic::generated_message_descriptor_data());
            messages.push(TournamentPlayer::generated_message_descriptor_data());
            messages.push(TournamentTeam::generated_message_descriptor_data());
            messages.push(TournamentEvent::generated_message_descriptor_data());
            messages.push(GlobalStatistics::generated_message_descriptor_data());
            messages.push(OperationalStatisticDescription::generated_message_descriptor_data());
            messages.push(OperationalStatisticElement::generated_message_descriptor_data());
            messages.push(OperationalStatisticsPacket::generated_message_descriptor_data());
            messages.push(PlayerRankingInfo::generated_message_descriptor_data());
            messages.push(PlayerCommendationInfo::generated_message_descriptor_data());
            messages.push(PlayerMedalsInfo::generated_message_descriptor_data());
            messages.push(AccountActivity::generated_message_descriptor_data());
            messages.push(TournamentMatchSetup::generated_message_descriptor_data());
            messages.push(ServerHltvInfo::generated_message_descriptor_data());
            messages.push(IpAddressMask::generated_message_descriptor_data());
            messages.push(XpProgressData::generated_message_descriptor_data());
            messages.push(MatchEndItemUpdates::generated_message_descriptor_data());
            messages.push(ScoreLeaderboardData::generated_message_descriptor_data());
            messages.push(PlayerQuestData::generated_message_descriptor_data());
            messages.push(CMsgGC_ServerQuestUpdateData::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingGCOperationalStats::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GC2ServerReservationUpdate::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingStart::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingStop::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingClient2ServerPing::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate::generated_message_descriptor_data());
            messages.push(CDataGCCStrike15_v2_TournamentMatchDraft::generated_message_descriptor_data());
            messages.push(CPreMatchInfoData::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingServerReservationResponse::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingServerRoundStats::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingServerMatchEnd::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingClient2GCHello::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingGC2ClientHello::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_AccountPrivacySettings::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingServer2GCKick::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ServerNotificationForUserPenalty::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientReportPlayer::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientCommendPlayer::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientReportServer::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientReportResponse::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends::generated_message_descriptor_data());
            messages.push(WatchableMatchInfo::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientRequestJoinFriendData::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientRequestJoinServerData::generated_message_descriptor_data());
            messages.push(CMsgGCCstrike15_v2_ClientRequestNewMission::generated_message_descriptor_data());
            messages.push(CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_WatchInfoUsers::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientRequestPlayersProfile::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_PlayersProfile::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus::generated_message_descriptor_data());
            messages.push(CClientHeaderOverwatchEvidence::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GC2ClientTextMsg::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Client2GCTextMsg::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchEndRunRewardDrops::generated_message_descriptor_data());
            messages.push(CEconItemPreviewDataBlock::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchEndRewardDropsNotification::generated_message_descriptor_data());
            messages.push(CMsgItemAcknowledged::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchListRequestRecentUserGames::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchListRequestTournamentGames::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchListRequestFullGameInfo::generated_message_descriptor_data());
            messages.push(CDataGCCStrike15_v2_MatchInfo::generated_message_descriptor_data());
            messages.push(CDataGCCStrike15_v2_TournamentGroupTeam::generated_message_descriptor_data());
            messages.push(CDataGCCStrike15_v2_TournamentGroup::generated_message_descriptor_data());
            messages.push(CDataGCCStrike15_v2_TournamentSection::generated_message_descriptor_data());
            messages.push(CDataGCCStrike15_v2_TournamentInfo::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_MatchList::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Predictions::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Fantasy::generated_message_descriptor_data());
            messages.push(CAttribute_String::generated_message_descriptor_data());
            messages.push(CMsgGCToGCReloadVersions::generated_message_descriptor_data());
            messages.push(CMsgCStrike15Welcome::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientVarValueNotificationInfo::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ServerVarValueNotificationInfo::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GiftsLeaderboardRequest::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GiftsLeaderboardResponse::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientSubmitSurveyVote::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Server2GCClientValidate::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GC2ClientTournamentInfo::generated_message_descriptor_data());
            messages.push(CSOEconCoupon::generated_message_descriptor_data());
            messages.push(CSOQuestProgress::generated_message_descriptor_data());
            messages.push(CSOPersonaDataPublic::generated_message_descriptor_data());
            messages.push(CMsgGC_GlobalGame_Subscribe::generated_message_descriptor_data());
            messages.push(CMsgGC_GlobalGame_Unsubscribe::generated_message_descriptor_data());
            messages.push(CMsgGC_GlobalGame_Play::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_AcknowledgePenalty::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_Client2GCStreamUnlock::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientToGCRequestElevate::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_ClientToGCChat::generated_message_descriptor_data());
            messages.push(CMsgGCCStrike15_v2_GCToClientChat::generated_message_descriptor_data());
            messages.push(score_leaderboard_data::Entry::generated_message_descriptor_data());
            messages.push(score_leaderboard_data::AccountEntries::generated_message_descriptor_data());
            messages.push(player_quest_data::QuestItemData::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_v2_matchmaking_gc2client_update::Note::generated_message_descriptor_data());
            messages.push(cdata_gccstrike15_v2_tournament_match_draft::Entry::generated_message_descriptor_data());
            messages.push(cpre_match_info_data::TeamStats::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_v2_matchmaking_server_round_stats::DropInfo::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_v2_account_privacy_settings::Setting::generated_message_descriptor_data());
            messages.push(cecon_item_preview_data_block::Sticker::generated_message_descriptor_data());
            messages.push(cdata_gccstrike15_v2_tournament_group::Picks::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_v2_predictions::GroupMatchTeamPick::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_v2_fantasy::FantasySlot::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_v2_fantasy::FantasyTeam::generated_message_descriptor_data());
            messages.push(cmsg_gccstrike15_v2_gifts_leaderboard_response::GiftLeaderboardEntry::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(ECsgoGCMsg::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
